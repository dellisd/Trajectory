(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol = typeof Symbol === 'function' ? Symbol.for('nodejs.util.inspect.custom') : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":1,"buffer":3,"ieee754":4}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],5:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],6:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],9:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":8,"_process":6,"inherits":7}],10:[function(require,module,exports){
var AwaitValue = require("./AwaitValue");

function AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume("next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen["return"] !== "function") {
    this["return"] = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

AsyncGenerator.prototype["throw"] = function (arg) {
  return this._invoke("throw", arg);
};

AsyncGenerator.prototype["return"] = function (arg) {
  return this._invoke("return", arg);
};

module.exports = AsyncGenerator;
},{"./AwaitValue":11}],11:[function(require,module,exports){
function _AwaitValue(value) {
  this.wrapped = value;
}

module.exports = _AwaitValue;
},{}],12:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
},{}],13:[function(require,module,exports){
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;
},{}],14:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
},{}],15:[function(require,module,exports){
function _asyncIterator(iterable) {
  var method;

  if (typeof Symbol !== "undefined") {
    if (Symbol.asyncIterator) {
      method = iterable[Symbol.asyncIterator];
      if (method != null) return method.call(iterable);
    }

    if (Symbol.iterator) {
      method = iterable[Symbol.iterator];
      if (method != null) return method.call(iterable);
    }
  }

  throw new TypeError("Object is not async iterable");
}

module.exports = _asyncIterator;
},{}],16:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
},{}],17:[function(require,module,exports){
var AwaitValue = require("./AwaitValue");

function _awaitAsyncGenerator(value) {
  return new AwaitValue(value);
}

module.exports = _awaitAsyncGenerator;
},{"./AwaitValue":11}],18:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],19:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
},{"./setPrototypeOf":36}],20:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],21:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
},{}],22:[function(require,module,exports){
var superPropBase = require("./superPropBase");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
},{"./superPropBase":38}],23:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
},{}],24:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
},{"./setPrototypeOf":36}],25:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],26:[function(require,module,exports){
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

module.exports = _interopRequireWildcard;
},{}],27:[function(require,module,exports){
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
},{}],28:[function(require,module,exports){
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;
},{}],29:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
},{}],30:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;
},{}],31:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;
},{}],32:[function(require,module,exports){
var defineProperty = require("./defineProperty");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;
},{"./defineProperty":21}],33:[function(require,module,exports){
var objectWithoutPropertiesLoose = require("./objectWithoutPropertiesLoose");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
},{"./objectWithoutPropertiesLoose":34}],34:[function(require,module,exports){
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
},{}],35:[function(require,module,exports){
var _typeof = require("../helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
},{"../helpers/typeof":40,"./assertThisInitialized":14}],36:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
},{}],37:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
},{"./arrayWithHoles":12,"./iterableToArrayLimit":29,"./nonIterableRest":30}],38:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
},{"./getPrototypeOf":23}],39:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
},{"./arrayWithoutHoles":13,"./iterableToArray":28,"./nonIterableSpread":31}],40:[function(require,module,exports){
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],41:[function(require,module,exports){
var AsyncGenerator = require("./AsyncGenerator");

function _wrapAsyncGenerator(fn) {
  return function () {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}

module.exports = _wrapAsyncGenerator;
},{"./AsyncGenerator":10}],42:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

var setPrototypeOf = require("./setPrototypeOf");

var isNativeFunction = require("./isNativeFunction");

var construct = require("./construct");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
},{"./construct":19,"./getPrototypeOf":23,"./isNativeFunction":27,"./setPrototypeOf":36}],43:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":456}],44:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _transitionManager = _interopRequireDefault(require("./transition-manager"));

var _log = _interopRequireDefault(require("../utils/log"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var ZOOM_ACCEL = 0.01;
var EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown']
};

var Controller = function () {
  function Controller(ControllerState) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Controller);
    (0, _assert.default)(ControllerState);
    this.ControllerState = ControllerState;
    this.controllerState = null;
    this.controllerStateProps = null;
    this.eventManager = null;
    this.transitionManager = new _transitionManager.default(ControllerState, options);
    this._events = null;
    this._state = {
      isDragging: false
    };
    this.events = [];
    this.onViewStateChange = null;
    this.onStateChange = null;
    this.invertPan = false;
    this.handleEvent = this.handleEvent.bind(this);
    this.setProps(options);
  }

  (0, _createClass2.default)(Controller, [{
    key: "finalize",
    value: function finalize() {
      for (var eventName in this._events) {
        if (this._events[eventName]) {
          this.eventManager.off(eventName, this.handleEvent);
        }
      }

      this.transitionManager.finalize();
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      var ControllerState = this.ControllerState;
      this.controllerState = new ControllerState(Object.assign({}, this.controllerStateProps, this._state));

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);

        case 'panmove':
          return this._onPan(event);

        case 'panend':
          return this._onPanEnd(event);

        case 'pinchstart':
          return this._onPinchStart(event);

        case 'pinchmove':
          return this._onPinch(event);

        case 'pinchend':
          return this._onPinchEnd(event);

        case 'doubletap':
          return this._onDoubleTap(event);

        case 'wheel':
          return this._onWheel(event);

        case 'keydown':
          return this._onKeyDown(event);

        default:
          return false;
      }
    }
  }, {
    key: "getCenter",
    value: function getCenter(event) {
      var _this$controllerState = this.controllerStateProps,
          x = _this$controllerState.x,
          y = _this$controllerState.y;
      var offsetCenter = event.offsetCenter;
      return [offsetCenter.x - x, offsetCenter.y - y];
    }
  }, {
    key: "isPointInBounds",
    value: function isPointInBounds(pos, event) {
      var _this$controllerState2 = this.controllerStateProps,
          width = _this$controllerState2.width,
          height = _this$controllerState2.height;

      if (event && event.handled) {
        return false;
      }

      var inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;

      if (inside && event) {
        event.stopPropagation();
      }

      return inside;
    }
  }, {
    key: "isFunctionKeyPressed",
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: "isDragging",
    value: function isDragging() {
      return this._state.isDragging;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('onViewportChange' in props) {
        _log.default.removed('onViewportChange')();
      }

      if ('onViewStateChange' in props) {
        this.onViewStateChange = props.onViewStateChange;
      }

      if ('onStateChange' in props) {
        this.onStateChange = props.onStateChange;
      }

      this.controllerStateProps = props;

      if ('eventManager' in props && this.eventManager !== props.eventManager) {
        this.eventManager = props.eventManager;
        this._events = {};
        this.toggleEvents(this.events, true);
      }

      this.transitionManager.processViewStateChange(this.controllerStateProps);
      var _props$scrollZoom = props.scrollZoom,
          scrollZoom = _props$scrollZoom === void 0 ? true : _props$scrollZoom,
          _props$dragPan = props.dragPan,
          dragPan = _props$dragPan === void 0 ? true : _props$dragPan,
          _props$dragRotate = props.dragRotate,
          dragRotate = _props$dragRotate === void 0 ? true : _props$dragRotate,
          _props$doubleClickZoo = props.doubleClickZoom,
          doubleClickZoom = _props$doubleClickZoo === void 0 ? true : _props$doubleClickZoo,
          _props$touchZoom = props.touchZoom,
          touchZoom = _props$touchZoom === void 0 ? true : _props$touchZoom,
          _props$touchRotate = props.touchRotate,
          touchRotate = _props$touchRotate === void 0 ? false : _props$touchRotate,
          _props$keyboard = props.keyboard,
          keyboard = _props$keyboard === void 0 ? true : _props$keyboard;
      var isInteractive = Boolean(this.onViewStateChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
  }, {
    key: "updateTransition",
    value: function updateTransition(timestamp) {
      this.transitionManager.updateTransition(timestamp);
    }
  }, {
    key: "toggleEvents",
    value: function toggleEvents(eventNames, enabled) {
      var _this = this;

      if (this.eventManager) {
        eventNames.forEach(function (eventName) {
          if (_this._events[eventName] !== enabled) {
            _this._events[eventName] = enabled;

            if (enabled) {
              _this.eventManager.on(eventName, _this.handleEvent);
            } else {
              _this.eventManager.off(eventName, _this.handleEvent);
            }
          }
        });
      }
    }
  }, {
    key: "setOptions",
    value: function setOptions(props) {
      return this.setProps(props);
    }
  }, {
    key: "updateViewport",
    value: function updateViewport(newControllerState) {
      var extraProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var interactionState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var viewState = Object.assign({}, newControllerState.getViewportProps(), extraProps);
      var changed = this.controllerState !== newControllerState;

      if (changed) {
        var oldViewState = this.controllerState ? this.controllerState.getViewportProps() : null;

        if (this.onViewStateChange) {
          this.onViewStateChange({
            viewState: viewState,
            interactionState: interactionState,
            oldViewState: oldViewState
          });
        }
      }

      Object.assign(this._state, newControllerState.getInteractiveState(), interactionState);

      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }
  }, {
    key: "_onPanStart",
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var newControllerState = this.controllerState.panStart({
        pos: pos
      }).rotateStart({
        pos: pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
  }, {
    key: "_onPan",
    value: function _onPan(event) {
      if (!this.isDragging()) {
        return false;
      }

      var alternateMode = this.isFunctionKeyPressed(event) || event.rightButton;
      alternateMode = this.invertPan ? !alternateMode : alternateMode;
      return alternateMode ? this._onPanMove(event) : this._onPanRotate(event);
    }
  }, {
    key: "_onPanEnd",
    value: function _onPanEnd(event) {
      var newControllerState = this.controllerState.panEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isRotating: false
      });
      return true;
    }
  }, {
    key: "_onPanMove",
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }

      var pos = this.getCenter(event);
      var newControllerState = this.controllerState.pan({
        pos: pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: true
      });
      return true;
    }
  }, {
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _this$controllerState3 = this.controllerState.getViewportProps(),
          width = _this$controllerState3.width,
          height = _this$controllerState3.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = deltaY / height;
      var newControllerState = this.controllerState.rotate({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
  }, {
    key: "_onWheel",
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }

      event.preventDefault();
      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var delta = event.delta;
      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));

      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newControllerState = this.controllerState.zoom({
        pos: pos,
        scale: scale
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isZooming: true,
        isPanning: true
      });
      return true;
    }
  }, {
    key: "_onPinchStart",
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var newControllerState = this.controllerState.zoomStart({
        pos: pos
      }).rotateStart({
        pos: pos
      });
      this._state.startPinchRotation = event.rotation;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
  }, {
    key: "_onPinch",
    value: function _onPinch(event) {
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }

      if (!this.isDragging()) {
        return false;
      }

      var newControllerState = this.controllerState;

      if (this.touchZoom) {
        var scale = event.scale;
        var pos = this.getCenter(event);
        newControllerState = newControllerState.zoom({
          pos: pos,
          scale: scale
        });
      }

      if (this.touchRotate) {
        var rotation = event.rotation;
        var startPinchRotation = this._state.startPinchRotation;
        newControllerState = newControllerState.rotate({
          deltaScaleX: -(rotation - startPinchRotation) / 180
        });
      }

      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: this.touchRotate
      });
      return true;
    }
  }, {
    key: "_onPinchEnd",
    value: function _onPinchEnd(event) {
      var newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this._state.startPinchRotation = 0;
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
      return true;
    }
  }, {
    key: "_onDoubleTap",
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }

      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var isZoomOut = this.isFunctionKeyPressed(event);
      var newControllerState = this.controllerState.zoom({
        pos: pos,
        scale: isZoomOut ? 0.5 : 2
      });
      this.updateViewport(newControllerState, this._getTransitionProps(), {
        isZooming: true,
        isPanning: true
      });
      return true;
    }
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }

      var funcKey = this.isFunctionKeyPressed(event);
      var controllerState = this.controllerState;
      var newControllerState;
      var interactionState = {};

      switch (event.srcEvent.keyCode) {
        case 189:
          newControllerState = funcKey ? controllerState.zoomOut().zoomOut() : controllerState.zoomOut();
          interactionState.isZooming = true;
          break;

        case 187:
          newControllerState = funcKey ? controllerState.zoomIn().zoomIn() : controllerState.zoomIn();
          interactionState.isZooming = true;
          break;

        case 37:
          if (funcKey) {
            newControllerState = controllerState.rotateLeft();
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveLeft();
            interactionState.isPanning = true;
          }

          break;

        case 39:
          if (funcKey) {
            newControllerState = controllerState.rotateRight();
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveRight();
            interactionState.isPanning = true;
          }

          break;

        case 38:
          if (funcKey) {
            newControllerState = controllerState.rotateUp();
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveUp();
            interactionState.isPanning = true;
          }

          break;

        case 40:
          if (funcKey) {
            newControllerState = controllerState.rotateDown();
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveDown();
            interactionState.isPanning = true;
          }

          break;

        default:
          return false;
      }

      this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
      return true;
    }
  }, {
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return NO_TRANSITION_PROPS;
    }
  }]);
  return Controller;
}();

exports.default = Controller;

},{"../utils/assert":109,"../utils/log":117,"./transition-manager":49,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],45:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _math = require("math.gl");

var MOVEMENT_SPEED = 1;
var ROTATION_STEP_DEGREES = 2;

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var FirstPersonState = function (_ViewState) {
  (0, _inherits2.default)(FirstPersonState, _ViewState);

  function FirstPersonState(_ref) {
    var _this;

    var width = _ref.width,
        height = _ref.height,
        position = _ref.position,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        longitude = _ref.longitude,
        latitude = _ref.latitude,
        zoom = _ref.zoom,
        _ref$syncBearing = _ref.syncBearing,
        syncBearing = _ref$syncBearing === void 0 ? true : _ref$syncBearing,
        bounds = _ref.bounds,
        startPanEventPosition = _ref.startPanEventPosition,
        startPanPosition = _ref.startPanPosition,
        startRotateCenter = _ref.startRotateCenter,
        startRotateViewport = _ref.startRotateViewport,
        startZoomPos = _ref.startZoomPos,
        startZoom = _ref.startZoom;
    (0, _classCallCheck2.default)(this, FirstPersonState);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FirstPersonState).call(this, {
      width: width,
      height: height,
      position: position,
      bearing: bearing,
      pitch: pitch,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom
    }));
    _this._interactiveState = {
      startPanEventPosition: startPanEventPosition,
      startPanPosition: startPanPosition,
      startRotateCenter: startRotateCenter,
      startRotateViewport: startRotateViewport,
      startZoomPos: startZoomPos,
      startZoom: startZoom
    };
    return _this;
  }

  (0, _createClass2.default)(FirstPersonState, [{
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var _this$_viewportProps = this._viewportProps,
          translationX = _this$_viewportProps.translationX,
          translationY = _this$_viewportProps.translationY;
      return this._getUpdatedState({
        startPanPosition: [translationX, translationY],
        startPanEventPosition: pos
      });
    }
  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;
      var startPanEventPosition = this._interactiveState.startPanEventPosition || startPos;

      if (!startPanEventPosition) {
        return this;
      }

      var _ref4 = this._interactiveState.startPanPosition || [],
          _ref5 = (0, _slicedToArray2.default)(_ref4, 2),
          translationX = _ref5[0],
          translationY = _ref5[1];

      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);
      var deltaX = pos[0] - startPanEventPosition[0];
      var deltaY = pos[1] - startPanEventPosition[1];
      return this._getUpdatedState({
        translationX: translationX + deltaX,
        translationY: translationY - deltaY
      });
    }
  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedState({
        startPanPosition: null,
        startPanPos: null
      });
    }
  }, {
    key: "rotateStart",
    value: function rotateStart(_ref6) {
      var pos = _ref6.pos;
      return this._getUpdatedState({
        startRotateCenter: this._viewportProps.position,
        startRotateViewport: this._viewportProps
      });
    }
  }, {
    key: "rotate",
    value: function rotate(_ref7) {
      var deltaScaleX = _ref7.deltaScaleX,
          deltaScaleY = _ref7.deltaScaleY;

      if (!this._interactiveState.startRotateCenter) {
        return this;
      }

      var _this$_viewportProps2 = this._viewportProps,
          bearing = _this$_viewportProps2.bearing,
          pitch = _this$_viewportProps2.pitch;
      return this._getUpdatedState({
        bearing: bearing + deltaScaleX * 10,
        pitch: pitch - deltaScaleY * 10
      });
    }
  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedState({
        startRotateCenter: null,
        startRotateViewport: null
      });
    }
  }, {
    key: "zoomStart",
    value: function zoomStart(_ref8) {
      var pos = _ref8.pos;
      return this._getUpdatedState({
        startZoomPos: pos,
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function zoom(_ref9) {
      var pos = _ref9.pos,
          startPos = _ref9.startPos,
          scale = _ref9.scale;
      var _this$_viewportProps3 = this._viewportProps,
          zoom = _this$_viewportProps3.zoom,
          minZoom = _this$_viewportProps3.minZoom,
          maxZoom = _this$_viewportProps3.maxZoom,
          width = _this$_viewportProps3.width,
          height = _this$_viewportProps3.height,
          translationX = _this$_viewportProps3.translationX,
          translationY = _this$_viewportProps3.translationY;
      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;
      var newZoom = (0, _math.clamp)(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1];
      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;
      return newZoom / zoom < 1 ? this.moveBackward() : this.moveForward();
    }
  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomPos: null,
        startZoom: null
      });
    }
  }, {
    key: "moveLeft",
    value: function moveLeft() {
      var bearing = this._viewportProps.bearing;
      var newBearing = bearing - ROTATION_STEP_DEGREES;
      return this._getUpdatedState({
        bearing: newBearing
      });
    }
  }, {
    key: "moveRight",
    value: function moveRight() {
      var bearing = this._viewportProps.bearing;
      var newBearing = bearing + ROTATION_STEP_DEGREES;
      return this._getUpdatedState({
        bearing: newBearing
      });
    }
  }, {
    key: "moveForward",
    value: function moveForward() {
      var position = this._viewportProps.position;
      var direction = this.getDirection();
      var delta = new _math.Vector3(direction).normalize().scale(MOVEMENT_SPEED);
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "moveBackward",
    value: function moveBackward() {
      var position = this._viewportProps.position;
      var direction = this.getDirection();
      var delta = new _math.Vector3(direction).normalize().scale(-MOVEMENT_SPEED);
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      var position = this._viewportProps.position;
      var delta = [0, 0, 1];
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      var position = this._viewportProps.position;
      var delta = position[2] >= 1 ? [0, 0, -1] : [0, 0, 0];
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom + 0.2
      });
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom - 0.2
      });
    }
  }, {
    key: "_getUpdatedState",
    value: function _getUpdatedState(newProps) {
      return new FirstPersonState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }
  }]);
  return FirstPersonState;
}(_viewState.default);

var FirstPersonController = function (_Controller) {
  (0, _inherits2.default)(FirstPersonController, _Controller);

  function FirstPersonController(props) {
    (0, _classCallCheck2.default)(this, FirstPersonController);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FirstPersonController).call(this, FirstPersonState, props));
  }

  return FirstPersonController;
}(_controller.default);

exports.default = FirstPersonController;

},{"./controller":44,"./view-state":50,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37,"math.gl":415}],46:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testExports = exports.default = exports.MAPBOX_LIMITS = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _math = require("math.gl");

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _viewportMercatorProject = _interopRequireWildcard(require("viewport-mercator-project"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transitionManager = require("./transition-manager");

var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(),
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};
var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60
};
exports.MAPBOX_LIMITS = MAPBOX_LIMITS;
var DEFAULT_STATE = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var MapState = function (_ViewState) {
  (0, _inherits2.default)(MapState, _ViewState);

  function MapState() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom,
        _ref$maxPitch = _ref.maxPitch,
        maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,
        _ref$minPitch = _ref.minPitch,
        minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch,
        startPanLngLat = _ref.startPanLngLat,
        startZoomLngLat = _ref.startZoomLngLat,
        startBearing = _ref.startBearing,
        startPitch = _ref.startPitch,
        startZoom = _ref.startZoom;

    (0, _classCallCheck2.default)(this, MapState);
    (0, _assert.default)(Number.isFinite(longitude), '`longitude` must be supplied');
    (0, _assert.default)(Number.isFinite(latitude), '`latitude` must be supplied');
    (0, _assert.default)(Number.isFinite(zoom), '`zoom` must be supplied');
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MapState).call(this, {
      width: width,
      height: height,
      latitude: latitude,
      longitude: longitude,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch,
      altitude: altitude,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch
    }));
    _this._interactiveState = {
      startPanLngLat: startPanLngLat,
      startZoomLngLat: startZoomLngLat,
      startBearing: startBearing,
      startPitch: startPitch,
      startZoom: startZoom
    };
    return _this;
  }

  (0, _createClass2.default)(MapState, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }
  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

      if (!startPanLngLat) {
        return this;
      }

      var _this$_calculateNewLn = this._calculateNewLngLat({
        startPanLngLat: startPanLngLat,
        pos: pos
      }),
          _this$_calculateNewLn2 = (0, _slicedToArray2.default)(_this$_calculateNewLn, 2),
          longitude = _this$_calculateNewLn2[0],
          latitude = _this$_calculateNewLn2[1];

      return this._getUpdatedState({
        longitude: longitude,
        latitude: latitude
      });
    }
  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
  }, {
    key: "rotateStart",
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;
      return this._getUpdatedState({
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }
  }, {
    key: "rotate",
    value: function rotate(_ref5) {
      var _ref5$deltaScaleX = _ref5.deltaScaleX,
          deltaScaleX = _ref5$deltaScaleX === void 0 ? 0 : _ref5$deltaScaleX,
          _ref5$deltaScaleY = _ref5.deltaScaleY,
          deltaScaleY = _ref5$deltaScaleY === void 0 ? 0 : _ref5$deltaScaleY;
      var _this$_interactiveSta = this._interactiveState,
          startBearing = _this$_interactiveSta.startBearing,
          startPitch = _this$_interactiveSta.startPitch;

      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
        return this;
      }

      var _this$_calculateNewPi = this._calculateNewPitchAndBearing({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _this$_calculateNewPi.pitch,
          bearing = _this$_calculateNewPi.bearing;

      return this._getUpdatedState({
        bearing: bearing,
        pitch: pitch
      });
    }
  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
  }, {
    key: "zoomStart",
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;
      (0, _assert.default)(scale > 0, '`scale` must be a positive number');
      var _this$_interactiveSta2 = this._interactiveState,
          startZoom = _this$_interactiveSta2.startZoom,
          startZoomLngLat = _this$_interactiveSta2.startZoomLngLat;

      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }

      (0, _assert.default)(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

      var zoom = this._calculateNewZoom({
        scale: scale,
        startZoom: startZoom
      });

      var zoomedViewport = new _viewportMercatorProject.default(Object.assign({}, this._viewportProps, {
        zoom: zoom
      }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({
        lngLat: startZoomLngLat,
        pos: pos
      }),
          _zoomedViewport$getLo2 = (0, _slicedToArray2.default)(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      return this._getUpdatedState({
        zoom: zoom,
        longitude: longitude,
        latitude: latitude
      });
    }
  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this._zoomFromCenter(2);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this._zoomFromCenter(0.5);
    }
  }, {
    key: "moveLeft",
    value: function moveLeft() {
      return this._panFromCenter([100, 0]);
    }
  }, {
    key: "moveRight",
    value: function moveRight() {
      return this._panFromCenter([-100, 0]);
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      return this._panFromCenter([0, 100]);
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      return this._panFromCenter([0, -100]);
    }
  }, {
    key: "rotateLeft",
    value: function rotateLeft() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing - 15
      });
    }
  }, {
    key: "rotateRight",
    value: function rotateRight() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing + 15
      });
    }
  }, {
    key: "rotateUp",
    value: function rotateUp() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch + 10
      });
    }
  }, {
    key: "rotateDown",
    value: function rotateDown() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch - 10
      });
    }
  }, {
    key: "shortestPathFrom",
    value: function shortestPathFrom(viewState) {
      var fromProps = viewState.getViewportProps();
      var props = Object.assign({}, this._viewportProps);
      var bearing = props.bearing,
          longitude = props.longitude;

      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }

      if (Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }

      return props;
    }
  }, {
    key: "_zoomFromCenter",
    value: function _zoomFromCenter(scale) {
      var _this$_viewportProps = this._viewportProps,
          width = _this$_viewportProps.width,
          height = _this$_viewportProps.height;
      return this.zoom({
        pos: [width / 2, height / 2],
        scale: scale
      });
    }
  }, {
    key: "_panFromCenter",
    value: function _panFromCenter(offset) {
      var _this$_viewportProps2 = this._viewportProps,
          width = _this$_viewportProps2.width,
          height = _this$_viewportProps2.height;
      return this.pan({
        startPos: [width / 2, height / 2],
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
  }, {
    key: "_getUpdatedState",
    value: function _getUpdatedState(newProps) {
      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }
  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;
      props.zoom = (0, _math.clamp)(zoom, minZoom, maxZoom);
      var maxPitch = props.maxPitch,
          minPitch = props.minPitch,
          pitch = props.pitch;
      props.pitch = (0, _math.clamp)(pitch, minPitch, maxPitch);
      Object.assign(props, (0, _viewportMercatorProject.normalizeViewportProps)(props));
      return props;
    }
  }, {
    key: "_unproject",
    value: function _unproject(pos) {
      var viewport = new _viewportMercatorProject.default(this._viewportProps);
      return pos && viewport.unproject(pos);
    }
  }, {
    key: "_calculateNewLngLat",
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat,
          pos = _ref8.pos;
      var viewport = new _viewportMercatorProject.default(this._viewportProps);
      return viewport.getMapCenterByLngLatPosition({
        lngLat: startPanLngLat,
        pos: pos
      });
    }
  }, {
    key: "_calculateNewZoom",
    value: function _calculateNewZoom(_ref9) {
      var scale = _ref9.scale,
          startZoom = _ref9.startZoom;
      var _this$_viewportProps3 = this._viewportProps,
          maxZoom = _this$_viewportProps3.maxZoom,
          minZoom = _this$_viewportProps3.minZoom;
      var zoom = startZoom + Math.log2(scale);
      return (0, _math.clamp)(zoom, minZoom, maxZoom);
    }
  }, {
    key: "_calculateNewPitchAndBearing",
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX,
          deltaScaleY = _ref10.deltaScaleY,
          startBearing = _ref10.startBearing,
          startPitch = _ref10.startPitch;
      deltaScaleY = (0, _math.clamp)(deltaScaleY, -1, 1);
      var _this$_viewportProps4 = this._viewportProps,
          minPitch = _this$_viewportProps4.minPitch,
          maxPitch = _this$_viewportProps4.maxPitch;
      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;

      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }
  }]);
  return MapState;
}(_viewState.default);

var MapController = function (_Controller) {
  (0, _inherits2.default)(MapController, _Controller);

  function MapController(props) {
    var _this2;

    (0, _classCallCheck2.default)(this, MapController);
    _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MapController).call(this, MapState, props));
    _this2.invertPan = true;
    return _this2;
  }

  (0, _createClass2.default)(MapController, [{
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return LINEAR_TRANSITION_PROPS;
    }
  }, {
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _this$getCenter = this.getCenter(event),
          _this$getCenter2 = (0, _slicedToArray2.default)(_this$getCenter, 2),
          centerY = _this$getCenter2[1];

      var startY = centerY - deltaY;

      var _this$controllerState = this.controllerState.getViewportProps(),
          width = _this$controllerState.width,
          height = _this$controllerState.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;

      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }

      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
      var newControllerState = this.controllerState.rotate({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY
      });
      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
    }
  }]);
  return MapController;
}(_controller.default);

exports.default = MapController;
var testExports = {
  MapState: MapState
};
exports.testExports = testExports;

},{"../transitions/linear-interpolator":104,"../utils/assert":109,"./controller":44,"./transition-manager":49,"./view-state":50,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37,"math.gl":415,"viewport-mercator-project":461}],47:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OrbitState = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _math = require("math.gl");

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transitionManager = require("./transition-manager");

var MOVEMENT_SPEED = 50;
var DEFAULT_STATE = {
  orbitAxis: 'Z',
  rotationX: 0,
  rotationOrbit: 0,
  fovy: 50,
  zoom: 0,
  target: [0, 0, 0],
  minZoom: -Infinity,
  maxZoom: Infinity
};
var LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(['target', 'zoom', 'rotationX', 'rotationOrbit']),
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};

var zoom2Scale = function zoom2Scale(zoom) {
  return Math.pow(2, zoom);
};

var OrbitState = function (_ViewState) {
  (0, _inherits2.default)(OrbitState, _ViewState);

  function OrbitState(_ref) {
    var _this;

    var ViewportType = _ref.ViewportType,
        width = _ref.width,
        height = _ref.height,
        _ref$orbitAxis = _ref.orbitAxis,
        orbitAxis = _ref$orbitAxis === void 0 ? DEFAULT_STATE.orbitAxis : _ref$orbitAxis,
        _ref$rotationX = _ref.rotationX,
        rotationX = _ref$rotationX === void 0 ? DEFAULT_STATE.rotationX : _ref$rotationX,
        _ref$rotationOrbit = _ref.rotationOrbit,
        rotationOrbit = _ref$rotationOrbit === void 0 ? DEFAULT_STATE.rotationOrbit : _ref$rotationOrbit,
        _ref$target = _ref.target,
        target = _ref$target === void 0 ? DEFAULT_STATE.target : _ref$target,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === void 0 ? DEFAULT_STATE.zoom : _ref$zoom,
        _ref$fovy = _ref.fovy,
        fovy = _ref$fovy === void 0 ? DEFAULT_STATE.fovy : _ref$fovy,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === void 0 ? DEFAULT_STATE.minZoom : _ref$minZoom,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === void 0 ? DEFAULT_STATE.maxZoom : _ref$maxZoom,
        startPanPosition = _ref.startPanPosition,
        startTarget = _ref.startTarget,
        startRotationX = _ref.startRotationX,
        startRotationOrbit = _ref.startRotationOrbit,
        startZoomPosition = _ref.startZoomPosition,
        startZoom = _ref.startZoom;
    (0, _classCallCheck2.default)(this, OrbitState);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitState).call(this, {
      width: width,
      height: height,
      orbitAxis: orbitAxis,
      rotationX: rotationX,
      rotationOrbit: rotationOrbit,
      target: target,
      fovy: fovy,
      zoom: zoom,
      minZoom: minZoom,
      maxZoom: maxZoom
    }));
    _this._interactiveState = {
      startPanPosition: startPanPosition,
      startTarget: startTarget,
      startRotationX: startRotationX,
      startRotationOrbit: startRotationOrbit,
      startZoomPosition: startZoomPosition,
      startZoom: startZoom
    };
    _this.ViewportType = ViewportType;
    return _this;
  }

  (0, _createClass2.default)(OrbitState, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var target = this._viewportProps.target;
      return this._getUpdatedState({
        startPanPosition: pos,
        startTarget: target
      });
    }
  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;
      var _this$_interactiveSta = this._interactiveState,
          startPanPosition = _this$_interactiveSta.startPanPosition,
          startTarget = _this$_interactiveSta.startTarget;
      var delta = new _math.Vector2(pos).subtract(startPanPosition);
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          startTarget: startTarget,
          pixelOffset: delta
        })
      });
    }
  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedState({
        startPanPosition: null,
        startTarget: null
      });
    }
  }, {
    key: "rotateStart",
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;
      return this._getUpdatedState({
        startRotationX: this._viewportProps.rotationX,
        startRotationOrbit: this._viewportProps.rotationOrbit
      });
    }
  }, {
    key: "rotate",
    value: function rotate(_ref5) {
      var deltaScaleX = _ref5.deltaScaleX,
          deltaScaleY = _ref5.deltaScaleY;
      var _this$_interactiveSta2 = this._interactiveState,
          startRotationX = _this$_interactiveSta2.startRotationX,
          startRotationOrbit = _this$_interactiveSta2.startRotationOrbit;

      if (!Number.isFinite(startRotationX) || !Number.isFinite(startRotationOrbit)) {
        return this;
      }

      var newRotationX = (0, _math.clamp)(startRotationX + deltaScaleY * 180, -89.999, 89.999);
      var newRotationOrbit = (startRotationOrbit + deltaScaleX * 180) % 360;
      return this._getUpdatedState({
        rotationX: newRotationX,
        rotationOrbit: newRotationOrbit,
        isRotating: true
      });
    }
  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedState({
        startRotationX: null,
        startRotationOrbit: null
      });
    }
  }, {
    key: "shortestPathFrom",
    value: function shortestPathFrom(viewState) {
      var props = Object.assign({}, this._viewportProps);
      return props;
    }
  }, {
    key: "zoomStart",
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;
      return this._getUpdatedState({
        startZoomPosition: pos,
        startTarget: this._viewportProps.target,
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;
      var _this$_viewportProps = this._viewportProps,
          zoom = _this$_viewportProps.zoom,
          width = _this$_viewportProps.width,
          height = _this$_viewportProps.height,
          target = _this$_viewportProps.target;
      var _this$_interactiveSta3 = this._interactiveState,
          startZoom = _this$_interactiveSta3.startZoom,
          startZoomPosition = _this$_interactiveSta3.startZoomPosition,
          startTarget = _this$_interactiveSta3.startTarget;

      if (!Number.isFinite(startZoom)) {
        startZoom = zoom;
        startTarget = target;
        startZoomPosition = startPos || pos;
      }

      var newZoom = this._calculateNewZoom({
        scale: scale,
        startZoom: startZoom
      });

      var startScale = zoom2Scale(startZoom);
      var newScale = zoom2Scale(newZoom);
      var dX = (width / 2 - startZoomPosition[0]) * (newScale / startScale - 1);
      var dY = (height / 2 - startZoomPosition[1]) * (newScale / startScale - 1);
      return this._getUpdatedState({
        zoom: newZoom,
        target: this._calculateNewTarget({
          startTarget: startTarget,
          zoom: newZoom,
          pixelOffset: [dX, dY]
        })
      });
    }
  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null,
        startTarget: null,
        startZoom: null
      });
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: 2
        })
      });
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: 0.5
        })
      });
    }
  }, {
    key: "moveLeft",
    value: function moveLeft() {
      var pixelOffset = [-MOVEMENT_SPEED, 0];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "moveRight",
    value: function moveRight() {
      var pixelOffset = [MOVEMENT_SPEED, 0];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      var pixelOffset = [0, -MOVEMENT_SPEED];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      var pixelOffset = [0, MOVEMENT_SPEED];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "rotateLeft",
    value: function rotateLeft() {
      return this._getUpdatedState({
        rotationOrbit: this._viewportProps.rotationOrbit - 15
      });
    }
  }, {
    key: "rotateRight",
    value: function rotateRight() {
      return this._getUpdatedState({
        rotationOrbit: this._viewportProps.rotationOrbit + 15
      });
    }
  }, {
    key: "rotateUp",
    value: function rotateUp() {
      return this._getUpdatedState({
        rotationX: this._viewportProps.rotationX - 10
      });
    }
  }, {
    key: "rotateDown",
    value: function rotateDown() {
      return this._getUpdatedState({
        rotationX: this._viewportProps.rotationX + 10
      });
    }
  }, {
    key: "_calculateNewZoom",
    value: function _calculateNewZoom(_ref8) {
      var scale = _ref8.scale,
          startZoom = _ref8.startZoom;
      var _this$_viewportProps2 = this._viewportProps,
          maxZoom = _this$_viewportProps2.maxZoom,
          minZoom = _this$_viewportProps2.minZoom;

      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
      }

      var zoom = startZoom + Math.log2(scale);
      return (0, _math.clamp)(zoom, minZoom, maxZoom);
    }
  }, {
    key: "_calculateNewTarget",
    value: function _calculateNewTarget(_ref9) {
      var startTarget = _ref9.startTarget,
          zoom = _ref9.zoom,
          pixelOffset = _ref9.pixelOffset;
      var viewportProps = Object.assign({}, this._viewportProps);

      if (Number.isFinite(zoom)) {
        viewportProps.zoom = zoom;
      }

      if (startTarget) {
        viewportProps.target = startTarget;
      }

      var viewport = new this.ViewportType(viewportProps);
      var center = viewport.project(viewportProps.target);
      return viewport.unproject([center[0] - pixelOffset[0], center[1] - pixelOffset[1], center[2]]);
    }
  }, {
    key: "_getUpdatedState",
    value: function _getUpdatedState(newProps) {
      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }
  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;
      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = zoom < minZoom ? minZoom : zoom;
      return props;
    }
  }]);
  return OrbitState;
}(_viewState.default);

exports.OrbitState = OrbitState;

var OrbitController = function (_Controller) {
  (0, _inherits2.default)(OrbitController, _Controller);

  function OrbitController(props) {
    (0, _classCallCheck2.default)(this, OrbitController);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitController).call(this, OrbitState, props));
  }

  (0, _createClass2.default)(OrbitController, [{
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return LINEAR_TRANSITION_PROPS;
    }
  }]);
  return OrbitController;
}(_controller.default);

exports.default = OrbitController;

},{"../transitions/linear-interpolator":104,"./controller":44,"./transition-manager":49,"./view-state":50,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],48:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _controller = _interopRequireDefault(require("./controller"));

var _orbitController = require("./orbit-controller");

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transitionManager = require("./transition-manager");

var LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(['target', 'zoom']),
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};

var OrthographicController = function (_Controller) {
  (0, _inherits2.default)(OrthographicController, _Controller);

  function OrthographicController(props) {
    var _this;

    (0, _classCallCheck2.default)(this, OrthographicController);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrthographicController).call(this, _orbitController.OrbitState, props));
    _this.invertPan = true;
    return _this;
  }

  (0, _createClass2.default)(OrthographicController, [{
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      return false;
    }
  }, {
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return LINEAR_TRANSITION_PROPS;
    }
  }]);
  return OrthographicController;
}(_controller.default);

exports.default = OrthographicController;

},{"../transitions/linear-interpolator":104,"./controller":44,"./orbit-controller":47,"./transition-manager":49,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],49:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSITION_EVENTS = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transition = _interopRequireDefault(require("../transitions/transition"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var noop = function noop() {};

var TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
exports.TRANSITION_EVENTS = TRANSITION_EVENTS;
var DEFAULT_PROPS = {
  transitionDuration: 0,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(),
  transitionInterruption: TRANSITION_EVENTS.BREAK,
  onTransitionStart: noop,
  onTransitionInterrupt: noop,
  onTransitionEnd: noop
};

var TransitionManager = function () {
  function TransitionManager(ControllerState) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TransitionManager);
    (0, _assert.default)(ControllerState);
    this.ControllerState = ControllerState;
    this.props = Object.assign({}, DEFAULT_PROPS, props);
    this.propsInTransition = null;
    this.time = 0;
    this.transition = new _transition.default();
    this.onViewStateChange = props.onViewStateChange;
    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);
  }

  (0, _createClass2.default)(TransitionManager, [{
    key: "finalize",
    value: function finalize() {}
  }, {
    key: "getViewportInTransition",
    value: function getViewportInTransition() {
      return this.propsInTransition;
    }
  }, {
    key: "processViewStateChange",
    value: function processViewStateChange(nextProps) {
      var transitionTriggered = false;
      var currentProps = this.props;
      nextProps = Object.assign({}, DEFAULT_PROPS, nextProps);
      this.props = nextProps;

      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return transitionTriggered;
      }

      if (this._isTransitionEnabled(nextProps)) {
        var startProps = Object.assign({}, currentProps, this.transition.interruption === TRANSITION_EVENTS.SNAP_TO_END ? this.transition.endProps : this.propsInTransition || currentProps);

        this._triggerTransition(startProps, nextProps);

        transitionTriggered = true;
      } else {
        this.transition.cancel();
      }

      return transitionTriggered;
    }
  }, {
    key: "updateTransition",
    value: function updateTransition(timestamp) {
      this.time = timestamp;

      this._updateTransition();
    }
  }, {
    key: "_isTransitionEnabled",
    value: function _isTransitionEnabled(props) {
      return props.transitionDuration > 0 && props.transitionInterpolator;
    }
  }, {
    key: "_isUpdateDueToCurrentTransition",
    value: function _isUpdateDueToCurrentTransition(props) {
      if (this.transition.inProgress) {
        return this.transition.interpolator.arePropsEqual(props, this.propsInTransition);
      }

      return false;
    }
  }, {
    key: "_shouldIgnoreViewportChange",
    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this.transition.inProgress) {
        return this.transition.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
      } else if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
      }

      return true;
    }
  }, {
    key: "_triggerTransition",
    value: function _triggerTransition(startProps, endProps) {
      (0, _assert.default)(this._isTransitionEnabled(endProps), 'Transition is not enabled');
      var startViewstate = new this.ControllerState(startProps);
      var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);
      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);
      this.propsInTransition = {};
      this.transition.start({
        duration: endProps.transitionDuration,
        easing: endProps.transitionEasing,
        interpolator: endProps.transitionInterpolator,
        interruption: endProps.transitionInterruption,
        startProps: initialProps.start,
        endProps: initialProps.end,
        onStart: endProps.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
      });

      this._updateTransition();
    }
  }, {
    key: "_updateTransition",
    value: function _updateTransition() {
      this.transition.update(this.time);
    }
  }, {
    key: "_onTransitionEnd",
    value: function _onTransitionEnd(callback) {
      var _this = this;

      return function (transition) {
        _this.propsInTransition = null;
        callback(transition);
      };
    }
  }, {
    key: "_onTransitionUpdate",
    value: function _onTransitionUpdate(transition) {
      var interpolator = transition.interpolator,
          startProps = transition.startProps,
          endProps = transition.endProps,
          time = transition.time;
      var viewport = interpolator.interpolateProps(startProps, endProps, time);
      this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport)).getViewportProps();

      if (this.onViewStateChange) {
        this.onViewStateChange({
          viewState: this.propsInTransition,
          interactionState: {
            inTransition: true
          },
          oldViewState: this.props
        });
      }
    }
  }]);
  return TransitionManager;
}();

exports.default = TransitionManager;
TransitionManager.defaultProps = DEFAULT_PROPS;

},{"../transitions/linear-interpolator":104,"../transitions/transition":106,"../utils/assert":109,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],50:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _assert = _interopRequireDefault(require("../utils/assert"));

var defaultState = {
  position: [0, 0, 0],
  lookAt: [0, 0, 0],
  up: [0, 0, 1],
  rotationX: 0,
  rotationY: 0,
  fov: 50,
  near: 1,
  far: 100
};

var ViewState = function () {
  function ViewState(opts) {
    (0, _classCallCheck2.default)(this, ViewState);
    var width = opts.width,
        height = opts.height,
        _opts$position = opts.position,
        position = _opts$position === void 0 ? defaultState.position : _opts$position;
    (0, _assert.default)(Number.isFinite(width), '`width` must be supplied');
    (0, _assert.default)(Number.isFinite(height), '`height` must be supplied');
    this._viewportProps = this._applyConstraints(Object.assign({}, opts, {
      position: new _math.Vector3(position)
    }));
  }

  (0, _createClass2.default)(ViewState, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getDirection",
    value: function getDirection() {
      var spherical = new _math._SphericalCoordinates({
        bearing: this._viewportProps.bearing,
        pitch: this._viewportProps.pitch
      });
      var direction = spherical.toVector3().normalize();
      return direction;
    }
  }, {
    key: "getDirectionFromBearing",
    value: function getDirectionFromBearing(bearing) {
      var spherical = new _math._SphericalCoordinates({
        bearing: bearing,
        pitch: 90
      });
      var direction = spherical.toVector3().normalize();
      return direction;
    }
  }, {
    key: "shortestPathFrom",
    value: function shortestPathFrom(viewState) {
      return this._viewportProps;
    }
  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      return props;
    }
  }]);
  return ViewState;
}();

exports.default = ViewState;

},{"../utils/assert":109,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"math.gl":415}],51:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _pointLight = _interopRequireDefault(require("./point-light"));

var _viewportUniforms = require("../../shaderlib/project/viewport-uniforms");

var CameraLight = function (_PointLight) {
  (0, _inherits2.default)(CameraLight, _PointLight);

  function CameraLight() {
    (0, _classCallCheck2.default)(this, CameraLight);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CameraLight).apply(this, arguments));
  }

  (0, _createClass2.default)(CameraLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight(_ref) {
      var layer = _ref.layer;
      var viewport = layer.context.viewport;
      var _layer$props = layer.props,
          coordinateSystem = _layer$props.coordinateSystem,
          coordinateOrigin = _layer$props.coordinateOrigin,
          modelMatrix = _layer$props.modelMatrix;

      var _getUniformsFromViewp = (0, _viewportUniforms.getUniformsFromViewport)({
        viewport: viewport,
        modelMatrix: modelMatrix,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin
      }),
          project_uCameraPosition = _getUniformsFromViewp.project_uCameraPosition;

      this.projectedLight.color = this.color;
      this.projectedLight.intensity = this.intensity;
      this.projectedLight.position = project_uCameraPosition;
      return this.projectedLight;
    }
  }]);
  return CameraLight;
}(_pointLight.default);

exports.default = CameraLight;

},{"../../shaderlib/project/viewport-uniforms":102,"./point-light":54,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],52:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var DirectionalLight = function (_BaseDirectionalLight) {
  (0, _inherits2.default)(DirectionalLight, _BaseDirectionalLight);

  function DirectionalLight(props) {
    var _this;

    (0, _classCallCheck2.default)(this, DirectionalLight);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(DirectionalLight).call(this, props));

    var _props$_shadow = props._shadow,
        _shadow = _props$_shadow === void 0 ? false : _props$_shadow;

    _this.shadow = _shadow;
    return _this;
  }

  (0, _createClass2.default)(DirectionalLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight() {
      return this;
    }
  }]);
  return DirectionalLight;
}(_core.DirectionalLight);

exports.default = DirectionalLight;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/core":253}],53:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var _directionalLight = _interopRequireDefault(require("./directional-light"));

var _effect = _interopRequireDefault(require("../../lib/effect"));

var _math = require("math.gl");

var _shadowPass = _interopRequireDefault(require("../../passes/shadow-pass"));

var _shadow = _interopRequireDefault(require("../../shaderlib/shadow/shadow"));

var DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1.0
};
var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
  color: [255, 255, 255],
  intensity: 1.0,
  direction: [-1, -3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, 8, -2.5]
}];
var DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];

var LightingEffect = function (_Effect) {
  (0, _inherits2.default)(LightingEffect, _Effect);

  function LightingEffect(props) {
    var _this;

    (0, _classCallCheck2.default)(this, LightingEffect);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LightingEffect).call(this, props));
    _this.ambientLight = null;
    _this.directionalLights = [];
    _this.pointLights = [];
    _this.shadowColor = DEFAULT_SHADOW_COLOR;
    _this.shadowPasses = [];
    _this.dummyShadowMap = null;
    _this.shadow = false;

    for (var key in props) {
      var lightSource = props[key];

      switch (lightSource.type) {
        case 'ambient':
          _this.ambientLight = lightSource;
          break;

        case 'directional':
          _this.directionalLights.push(lightSource);

          break;

        case 'point':
          _this.pointLights.push(lightSource);

          break;

        default:
      }
    }

    _this._applyDefaultLights();

    if (_this.directionalLights.some(function (light) {
      return light.shadow;
    })) {
      _this.shadow = true;

      _this._addShadowModule();
    }

    return _this;
  }

  (0, _createClass2.default)(LightingEffect, [{
    key: "prepare",
    value: function prepare(gl, _ref) {
      var layers = _ref.layers,
          viewports = _ref.viewports,
          onViewportActive = _ref.onViewportActive,
          views = _ref.views,
          pixelRatio = _ref.pixelRatio;
      if (!this.shadow) return {};

      var shadowMatrices = this._createLightMatrix();

      if (this.shadowPasses.length === 0) {
        this._createShadowPasses(gl, pixelRatio);
      }

      if (!this.dummyShadowMap) {
        this.dummyShadowMap = new _core.Texture2D(gl, {
          width: 1,
          height: 1
        });
      }

      var shadowMaps = [];

      for (var i = 0; i < this.shadowPasses.length; i++) {
        var shadowPass = this.shadowPasses[i];
        shadowPass.render({
          layers: layers.filter(function (layer) {
            return layer.props.shadowEnabled !== false;
          }),
          viewports: viewports,
          onViewportActive: onViewportActive,
          views: views,
          effectProps: {
            shadowLightId: i,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: shadowMatrices
          }
        });
        shadowMaps.push(shadowPass.shadowMap);
      }

      return {
        shadowMaps: shadowMaps,
        dummyShadowMap: this.dummyShadowMap,
        shadowColor: this.shadowColor,
        shadowMatrices: shadowMatrices
      };
    }
  }, {
    key: "getParameters",
    value: function getParameters(layer) {
      var ambientLight = this.ambientLight;

      var pointLights = this._getProjectedPointLights(layer);

      var directionalLights = this._getProjectedDirectionalLights(layer);

      return {
        lightSources: {
          ambientLight: ambientLight,
          directionalLights: directionalLights,
          pointLights: pointLights
        }
      };
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.shadowPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var shadowPass = _step.value;
          shadowPass.delete();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.shadowPasses.length = 0;

      if (this.dummyShadowMap) {
        this.dummyShadowMap.delete();
        this.dummyShadowMap = null;
      }

      if (this.shadow) {
        this._removeShadowModule();
      }
    }
  }, {
    key: "_createLightMatrix",
    value: function _createLightMatrix() {
      var lightMatrices = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.directionalLights[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var light = _step2.value;
          var viewMatrix = new _math.Matrix4().lookAt({
            eye: new _math.Vector3(light.direction).negate()
          });
          lightMatrices.push(viewMatrix);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return lightMatrices;
    }
  }, {
    key: "_createShadowPasses",
    value: function _createShadowPasses(gl, pixelRatio) {
      for (var i = 0; i < this.directionalLights.length; i++) {
        this.shadowPasses.push(new _shadowPass.default(gl, {
          pixelRatio: pixelRatio
        }));
      }
    }
  }, {
    key: "_addShadowModule",
    value: function _addShadowModule() {
      var defaultShaderModules = (0, _core.getDefaultShaderModules)();
      var hasShadowModule = false;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = defaultShaderModules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var module = _step3.value;

          if (module.name === "shadow") {
            hasShadowModule = true;
            break;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (!hasShadowModule) {
        defaultShaderModules.push(_shadow.default);
        (0, _core.setDefaultShaderModules)(defaultShaderModules);
      }
    }
  }, {
    key: "_removeShadowModule",
    value: function _removeShadowModule() {
      var defaultShaderModules = (0, _core.getDefaultShaderModules)();

      for (var i = 0; i < defaultShaderModules.length; i++) {
        if (defaultShaderModules[i].name === "shadow") {
          defaultShaderModules.splice(i, 1);
          (0, _core.setDefaultShaderModules)(defaultShaderModules);
          break;
        }
      }
    }
  }, {
    key: "_applyDefaultLights",
    value: function _applyDefaultLights() {
      var ambientLight = this.ambientLight,
          pointLights = this.pointLights,
          directionalLights = this.directionalLights;

      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
        this.ambientLight = new _core.AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
        this.directionalLights.push(new _directionalLight.default(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]));
        this.directionalLights.push(new _directionalLight.default(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
      }
    }
  }, {
    key: "_getProjectedPointLights",
    value: function _getProjectedPointLights(layer) {
      var projectedPointLights = [];

      for (var i = 0; i < this.pointLights.length; i++) {
        var pointLight = this.pointLights[i];
        projectedPointLights.push(pointLight.getProjectedLight({
          layer: layer
        }));
      }

      return projectedPointLights;
    }
  }, {
    key: "_getProjectedDirectionalLights",
    value: function _getProjectedDirectionalLights(layer) {
      var projectedDirectionalLights = [];

      for (var i = 0; i < this.directionalLights.length; i++) {
        var directionalLight = this.directionalLights[i];
        projectedDirectionalLights.push(directionalLight.getProjectedLight({
          layer: layer
        }));
      }

      return projectedDirectionalLights;
    }
  }]);
  return LightingEffect;
}(_effect.default);

exports.default = LightingEffect;

},{"../../lib/effect":70,"../../passes/shadow-pass":92,"../../shaderlib/shadow/shadow":103,"./directional-light":52,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/core":253,"math.gl":415}],54:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var _projectFunctions = require("../../shaderlib/project/project-functions");

var _lib = require("../../lib");

var PointLight = function (_BasePointLight) {
  (0, _inherits2.default)(PointLight, _BasePointLight);

  function PointLight(props) {
    var _this;

    (0, _classCallCheck2.default)(this, PointLight);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PointLight).call(this, props));
    _this.projectedLight = new _core.PointLight(props);
    return _this;
  }

  (0, _createClass2.default)(PointLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight(_ref) {
      var layer = _ref.layer;
      var viewport = layer.context.viewport;
      var _layer$props = layer.props,
          coordinateSystem = _layer$props.coordinateSystem,
          coordinateOrigin = _layer$props.coordinateOrigin;
      var position = (0, _projectFunctions.projectPosition)(this.position, {
        viewport: viewport,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin,
        fromCoordinateSystem: viewport.isGeospatial ? _lib.COORDINATE_SYSTEM.LNGLAT : _lib.COORDINATE_SYSTEM.IDENTITY,
        fromCoordinateOrigin: [0, 0, 0]
      });
      this.projectedLight.color = this.color;
      this.projectedLight.intensity = this.intensity;
      this.projectedLight.position = position;
      return this.projectedLight;
    }
  }]);
  return PointLight;
}(_core.PointLight);

exports.default = PointLight;

},{"../../lib":71,"../../shaderlib/project/project-functions":99,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/core":253}],55:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _directionalLight = _interopRequireDefault(require("./directional-light"));

var _suncalc = require("./suncalc");

var SunLight = function (_DirectionalLight) {
  (0, _inherits2.default)(SunLight, _DirectionalLight);

  function SunLight(_ref) {
    var _this;

    var timestamp = _ref.timestamp,
        others = (0, _objectWithoutProperties2.default)(_ref, ["timestamp"]);
    (0, _classCallCheck2.default)(this, SunLight);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SunLight).call(this, others));
    _this.timestamp = timestamp;
    return _this;
  }

  (0, _createClass2.default)(SunLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight(_ref2) {
      var layer = _ref2.layer;
      var _layer$context$viewpo = layer.context.viewport,
          latitude = _layer$context$viewpo.latitude,
          longitude = _layer$context$viewpo.longitude;
      this.direction = (0, _suncalc.getSunlightDirection)(this.timestamp, latitude, longitude);
      return this;
    }
  }]);
  return SunLight;
}(_directionalLight.default);

exports.default = SunLight;

},{"./directional-light":52,"./suncalc":56,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectWithoutProperties":33,"@babel/runtime/helpers/possibleConstructorReturn":35}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSolarPosition = getSolarPosition;
exports.getSunlightDirection = getSunlightDirection;
var DEGREES_TO_RADIANS = Math.PI / 180;
var DAY_IN_MS = 1000 * 60 * 60 * 24;
var JD1970 = 2440588;
var JD2000 = 2451545;
var e = DEGREES_TO_RADIANS * 23.4397;
var M0 = 357.5291;
var M1 = 0.98560028;
var THETA0 = 280.147;
var THETA1 = 360.9856235;

function getSolarPosition(timestamp, latitude, longitude) {
  var longitudeWestInRadians = DEGREES_TO_RADIANS * -longitude;
  var phi = DEGREES_TO_RADIANS * latitude;
  var d = toDays(timestamp);
  var c = getSunCoords(d);
  var H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}

function getSunlightDirection(timestamp, latitude, longitude) {
  var _getSolarPosition = getSolarPosition(timestamp, latitude, longitude),
      azimuth = _getSolarPosition.azimuth,
      altitude = _getSolarPosition.altitude;

  var azimuthN = azimuth + Math.PI;
  return [-Math.sin(azimuthN), Math.cos(azimuthN), -Math.sin(altitude)];
}

function toJulianDay(timestamp) {
  return timestamp / DAY_IN_MS - 0.5 + JD1970;
}

function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}

function getRightAscension(eclipticLongitude, b) {
  var lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}

function getDeclination(eclipticLongitude, b) {
  var lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}

function getAzimuth(hourAngle, latitudeInRadians, declination) {
  var H = hourAngle;
  var phi = latitudeInRadians;
  var delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}

function getAltitude(hourAngle, latitudeInRadians, declination) {
  var H = hourAngle;
  var phi = latitudeInRadians;
  var delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}

function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}

function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS * (M0 + M1 * days);
}

function getEclipticLongitude(meanAnomaly) {
  var M = meanAnomaly;
  var C = DEGREES_TO_RADIANS * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
  var P = DEGREES_TO_RADIANS * 102.9372;
  return M + C + P + Math.PI;
}

function getSunCoords(dates) {
  var M = getSolarMeanAnomaly(dates);
  var L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}

},{}],57:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _effect = _interopRequireDefault(require("../lib/effect"));

var _screenPass = _interopRequireDefault(require("../passes/screen-pass"));

var _shadertools = require("@luma.gl/shadertools");

var PostProcessEffect = function (_Effect) {
  (0, _inherits2.default)(PostProcessEffect, _Effect);

  function PostProcessEffect(module) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, PostProcessEffect);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PostProcessEffect).call(this, props));
    _this.id = "".concat(module.name, "-pass");
    (0, _shadertools.normalizeShaderModule)(module);
    _this.module = module;
    return _this;
  }

  (0, _createClass2.default)(PostProcessEffect, [{
    key: "prepare",
    value: function prepare(gl) {
      if (!this.passes) {
        this.passes = createPasses(gl, this.module, this.id, this.props);
      }
    }
  }, {
    key: "render",
    value: function render(params) {
      var _params$target = params.target,
          target = _params$target === void 0 ? null : _params$target;
      var switchBuffer = false;

      for (var index = 0; index < this.passes.length; index++) {
        var inputBuffer = switchBuffer ? params.outputBuffer : params.inputBuffer;
        var outputBuffer = switchBuffer ? params.inputBuffer : params.outputBuffer;

        if (target && index === this.passes.length - 1) {
          outputBuffer = target;
        }

        this.passes[index].render({
          inputBuffer: inputBuffer,
          outputBuffer: outputBuffer
        });
        switchBuffer = !switchBuffer;
      }

      return {
        inputBuffer: switchBuffer ? params.outputBuffer : params.inputBuffer,
        outputBuffer: switchBuffer ? params.inputBuffer : params.outputBuffer
      };
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.passes) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var pass = _step.value;
            pass.delete();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.passes = null;
      }
    }
  }]);
  return PostProcessEffect;
}(_effect.default);

exports.default = PostProcessEffect;

function createPasses(gl, module, id, moduleProps) {
  if (module.filter || module.sampler) {
    var fs = getFragmentShaderForRenderPass(module);
    var pass = new _screenPass.default(gl, {
      id: id,
      module: module,
      fs: fs,
      moduleProps: moduleProps
    });
    return [pass];
  }

  var passes = module.passes || [];
  return passes.map(function (pass, index) {
    var fs = getFragmentShaderForRenderPass(module, pass);
    var idn = "".concat(id, "-").concat(index);
    return new _screenPass.default(gl, {
      id: idn,
      module: module,
      fs: fs,
      moduleProps: moduleProps
    });
  });
}

var FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
};

var SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
};

function getFragmentShaderForRenderPass(module) {
  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;

  if (pass.filter) {
    var func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }

  if (pass.sampler) {
    var _func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");

    return SAMPLER_FS_TEMPLATE(_func);
  }

  return null;
}

},{"../lib/effect":70,"../passes/screen-pass":91,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/shadertools":282}],58:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function get() {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "LightingEffect", {
  enumerable: true,
  get: function get() {
    return _lightingEffect.default;
  }
});
Object.defineProperty(exports, "PointLight", {
  enumerable: true,
  get: function get() {
    return _pointLight.default;
  }
});
Object.defineProperty(exports, "DirectionalLight", {
  enumerable: true,
  get: function get() {
    return _directionalLight.default;
  }
});
Object.defineProperty(exports, "_CameraLight", {
  enumerable: true,
  get: function get() {
    return _cameraLight.default;
  }
});
Object.defineProperty(exports, "_SunLight", {
  enumerable: true,
  get: function get() {
    return _sunLight.default;
  }
});
Object.defineProperty(exports, "PostProcessEffect", {
  enumerable: true,
  get: function get() {
    return _postProcessEffect.default;
  }
});
Object.defineProperty(exports, "_LayersPass", {
  enumerable: true,
  get: function get() {
    return _layersPass.default;
  }
});
Object.defineProperty(exports, "Deck", {
  enumerable: true,
  get: function get() {
    return _deck.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function get() {
    return _layerManager.default;
  }
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function get() {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function get() {
    return _layer.default;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function get() {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "DeckRenderer", {
  enumerable: true,
  get: function get() {
    return _deckRenderer.default;
  }
});
Object.defineProperty(exports, "Viewport", {
  enumerable: true,
  get: function get() {
    return _viewport.default;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function get() {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function get() {
    return _project.default;
  }
});
Object.defineProperty(exports, "project64", {
  enumerable: true,
  get: function get() {
    return _project2.default;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function get() {
    return _view.default;
  }
});
Object.defineProperty(exports, "MapView", {
  enumerable: true,
  get: function get() {
    return _mapView.default;
  }
});
Object.defineProperty(exports, "FirstPersonView", {
  enumerable: true,
  get: function get() {
    return _firstPersonView.default;
  }
});
Object.defineProperty(exports, "ThirdPersonView", {
  enumerable: true,
  get: function get() {
    return _thirdPersonView.default;
  }
});
Object.defineProperty(exports, "OrbitView", {
  enumerable: true,
  get: function get() {
    return _orbitView.default;
  }
});
Object.defineProperty(exports, "PerspectiveView", {
  enumerable: true,
  get: function get() {
    return _perspectiveView.default;
  }
});
Object.defineProperty(exports, "OrthographicView", {
  enumerable: true,
  get: function get() {
    return _orthographicView.default;
  }
});
Object.defineProperty(exports, "Controller", {
  enumerable: true,
  get: function get() {
    return _controller.default;
  }
});
Object.defineProperty(exports, "MapController", {
  enumerable: true,
  get: function get() {
    return _mapController.default;
  }
});
Object.defineProperty(exports, "_FirstPersonController", {
  enumerable: true,
  get: function get() {
    return _firstPersonController.default;
  }
});
Object.defineProperty(exports, "_OrbitController", {
  enumerable: true,
  get: function get() {
    return _orbitController.default;
  }
});
Object.defineProperty(exports, "_OrthographicController", {
  enumerable: true,
  get: function get() {
    return _orthographicController.default;
  }
});
Object.defineProperty(exports, "Effect", {
  enumerable: true,
  get: function get() {
    return _effect.default;
  }
});
Object.defineProperty(exports, "TRANSITION_EVENTS", {
  enumerable: true,
  get: function get() {
    return _transitionManager.TRANSITION_EVENTS;
  }
});
Object.defineProperty(exports, "LinearInterpolator", {
  enumerable: true,
  get: function get() {
    return _linearInterpolator.default;
  }
});
Object.defineProperty(exports, "FlyToInterpolator", {
  enumerable: true,
  get: function get() {
    return _viewportFlyToInterpolator.default;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return _log.default;
  }
});
Object.defineProperty(exports, "createIterable", {
  enumerable: true,
  get: function get() {
    return _iterableUtils.createIterable;
  }
});
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function get() {
    return _mathUtils.fp64LowPart;
  }
});
Object.defineProperty(exports, "AmbientLight", {
  enumerable: true,
  get: function get() {
    return _core.AmbientLight;
  }
});
Object.defineProperty(exports, "LayerExtension", {
  enumerable: true,
  get: function get() {
    return _layerExtension.LayerExtension;
  }
});
exports.experimental = void 0;

require("./lib/init");

require("./shaderlib");

var _constants = require("./lib/constants");

var _lightingEffect = _interopRequireDefault(require("./effects/lighting/lighting-effect"));

var _pointLight = _interopRequireDefault(require("./effects/lighting/point-light"));

var _directionalLight = _interopRequireDefault(require("./effects/lighting/directional-light"));

var _cameraLight = _interopRequireDefault(require("./effects/lighting/camera-light"));

var _sunLight = _interopRequireDefault(require("./effects/lighting/sun-light"));

var _postProcessEffect = _interopRequireDefault(require("./effects/post-process-effect"));

var _layersPass = _interopRequireDefault(require("./passes/layers-pass"));

var _deck = _interopRequireDefault(require("./lib/deck"));

var _layerManager = _interopRequireDefault(require("./lib/layer-manager"));

var _attributeManager = _interopRequireDefault(require("./lib/attribute-manager"));

var _layer = _interopRequireDefault(require("./lib/layer"));

var _compositeLayer = _interopRequireDefault(require("./lib/composite-layer"));

var _deckRenderer = _interopRequireDefault(require("./lib/deck-renderer"));

var _viewport = _interopRequireDefault(require("./viewports/viewport"));

var _webMercatorViewport = _interopRequireDefault(require("./viewports/web-mercator-viewport"));

var _project = _interopRequireDefault(require("./shaderlib/project/project"));

var _project2 = _interopRequireDefault(require("./shaderlib/project64/project64"));

var _view = _interopRequireDefault(require("./views/view"));

var _mapView = _interopRequireDefault(require("./views/map-view"));

var _firstPersonView = _interopRequireDefault(require("./views/first-person-view"));

var _thirdPersonView = _interopRequireDefault(require("./views/third-person-view"));

var _orbitView = _interopRequireDefault(require("./views/orbit-view"));

var _perspectiveView = _interopRequireDefault(require("./views/perspective-view"));

var _orthographicView = _interopRequireDefault(require("./views/orthographic-view"));

var _controller = _interopRequireDefault(require("./controllers/controller"));

var _mapController = _interopRequireDefault(require("./controllers/map-controller"));

var _firstPersonController = _interopRequireDefault(require("./controllers/first-person-controller"));

var _orbitController = _interopRequireDefault(require("./controllers/orbit-controller"));

var _orthographicController = _interopRequireDefault(require("./controllers/orthographic-controller"));

var _effect = _interopRequireDefault(require("./lib/effect"));

var _transitionManager = require("./controllers/transition-manager");

var _linearInterpolator = _interopRequireDefault(require("./transitions/linear-interpolator"));

var _viewportFlyToInterpolator = _interopRequireDefault(require("./transitions/viewport-fly-to-interpolator"));

var _log = _interopRequireDefault(require("./utils/log"));

var _flatten = require("./utils/flatten");

var _iterableUtils = require("./utils/iterable-utils");

var _mathUtils = require("./utils/math-utils");

var _tesselator = _interopRequireDefault(require("./utils/tesselator"));

var _count = require("./utils/count");

var _memoize = _interopRequireDefault(require("./utils/memoize"));

var _core = require("@luma.gl/core");

var _layerExtension = require("./lib/layer-extension");

var experimental = {
  Tesselator: _tesselator.default,
  flattenVertices: _flatten.flattenVertices,
  fillArray: _flatten.fillArray,
  count: _count.count,
  memoize: _memoize.default
};
exports.experimental = experimental;

},{"./controllers/controller":44,"./controllers/first-person-controller":45,"./controllers/map-controller":46,"./controllers/orbit-controller":47,"./controllers/orthographic-controller":48,"./controllers/transition-manager":49,"./effects/lighting/camera-light":51,"./effects/lighting/directional-light":52,"./effects/lighting/lighting-effect":53,"./effects/lighting/point-light":54,"./effects/lighting/sun-light":55,"./effects/post-process-effect":57,"./lib/attribute-manager":59,"./lib/composite-layer":64,"./lib/constants":65,"./lib/deck":68,"./lib/deck-renderer":67,"./lib/effect":70,"./lib/init":72,"./lib/layer":76,"./lib/layer-extension":73,"./lib/layer-manager":74,"./passes/layers-pass":88,"./shaderlib":93,"./shaderlib/project/project":101,"./shaderlib/project64/project64":97,"./transitions/linear-interpolator":104,"./transitions/viewport-fly-to-interpolator":107,"./utils/count":110,"./utils/flatten":112,"./utils/iterable-utils":115,"./utils/log":117,"./utils/math-utils":118,"./utils/memoize":119,"./utils/tesselator":123,"./viewports/viewport":125,"./viewports/web-mercator-viewport":126,"./views/first-person-view":127,"./views/map-view":128,"./views/orbit-view":129,"./views/orthographic-view":130,"./views/perspective-view":131,"./views/third-person-view":132,"./views/view":133,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],59:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _attribute = _interopRequireDefault(require("./attribute"));

var _log = _interopRequireDefault(require("../utils/log"));

var _attributeTransitionManager = _interopRequireDefault(require("./attribute-transition-manager"));

var LOG_START_END_PRIORITY = 2;
var LOG_DETAIL_PRIORITY = 3;

function noop() {}

var logFunctions = {
  savedMessages: null,
  timeStart: null,
  onLog: function onLog(_ref) {
    var level = _ref.level,
        message = _ref.message;

    _log.default.log(level, message)();
  },
  onUpdateStart: function onUpdateStart(_ref2) {
    var level = _ref2.level,
        numInstances = _ref2.numInstances;
    logFunctions.savedMessages = [];
    logFunctions.timeStart = new Date();
  },
  onUpdate: function onUpdate(_ref3) {
    var level = _ref3.level,
        message = _ref3.message;

    if (logFunctions.savedMessages) {
      logFunctions.savedMessages.push(message);
    }
  },
  onUpdateEnd: function onUpdateEnd(_ref4) {
    var level = _ref4.level,
        id = _ref4.id,
        numInstances = _ref4.numInstances;
    var timeMs = Math.round(new Date() - logFunctions.timeStart);
    var time = "".concat(timeMs, "ms");

    _log.default.group(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time), {
      collapsed: true
    })();

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var message = _step.value;

        _log.default.log(level, message)();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    _log.default.groupEnd(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time))();

    logFunctions.savedMessages = null;
  }
};

var AttributeManager = function () {
  (0, _createClass2.default)(AttributeManager, null, [{
    key: "setDefaultLogFunctions",
    value: function setDefaultLogFunctions() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref5.onLog,
          onUpdateStart = _ref5.onUpdateStart,
          onUpdate = _ref5.onUpdate,
          onUpdateEnd = _ref5.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }

      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }

      if (onUpdate !== undefined) {
        logFunctions.onUpdate = onUpdate || noop;
      }

      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }
  }]);

  function AttributeManager(gl) {
    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref6$id = _ref6.id,
        id = _ref6$id === void 0 ? 'attribute-manager' : _ref6$id,
        stats = _ref6.stats;

    (0, _classCallCheck2.default)(this, AttributeManager);
    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.accessors = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
      id: "".concat(id, "-transitions")
    });
    Object.seal(this);
  }

  (0, _createClass2.default)(AttributeManager, [{
    key: "finalize",
    value: function finalize() {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }

      this.attributeTransitionManager.finalize();
    }
  }, {
    key: "getNeedsRedraw",
    value: function getNeedsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
      return redraw && this.id;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.needsRedraw = true;
      return this;
    }
  }, {
    key: "add",
    value: function add(attributes, updaters) {
      this._add(attributes, updaters);
    }
  }, {
    key: "addInstanced",
    value: function addInstanced(attributes, updaters) {
      this._add(attributes, updaters, {
        instanced: 1
      });
    }
  }, {
    key: "remove",
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];

        if (this.attributes[name] !== undefined) {
          this.attributes[name].delete();
          delete this.attributes[name];
        }
      }
    }
  }, {
    key: "invalidate",
    value: function invalidate(triggerName, dataRange) {
      var invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);

      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated attributes ".concat(invalidatedAttributes, " (").concat(triggerName, ") for ").concat(this.id)
      });
    }
  }, {
    key: "invalidateAll",
    value: function invalidateAll(dataRange) {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
      }

      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated all attributes for ".concat(this.id)
      });
    }
  }, {
    key: "update",
    value: function update() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref7.data,
          numInstances = _ref7.numInstances,
          bufferLayout = _ref7.bufferLayout,
          transitions = _ref7.transitions,
          _ref7$props = _ref7.props,
          props = _ref7$props === void 0 ? {} : _ref7$props,
          _ref7$buffers = _ref7.buffers,
          buffers = _ref7$buffers === void 0 ? {} : _ref7$buffers,
          _ref7$context = _ref7.context,
          context = _ref7$context === void 0 ? {} : _ref7$context;

      var updated = false;
      logFunctions.onUpdateStart({
        level: LOG_START_END_PRIORITY,
        id: this.id,
        numInstances: numInstances
      });

      if (this.stats) {
        this.stats.get('Update Attributes').timeStart();
      }

      for (var attributeName in this.attributes) {
        var attribute = this.attributes[attributeName];

        if (attribute.setExternalBuffer(buffers[attributeName] || data.attributes && data.attributes[attributeName])) {} else if (attribute.setGenericValue(props[attribute.getAccessor()])) {} else if (attribute.needsUpdate()) {
          updated = true;

          this._updateAttribute({
            attribute: attribute,
            numInstances: numInstances,
            bufferLayout: bufferLayout,
            data: data,
            props: props,
            context: context
          });
        }

        this.needsRedraw |= attribute.needsRedraw();
      }

      if (updated) {
        logFunctions.onUpdateEnd({
          level: LOG_START_END_PRIORITY,
          id: this.id,
          numInstances: numInstances
        });
      }

      if (this.stats) {
        this.stats.get('Update Attributes').timeEnd();
      }

      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances: numInstances,
        transitions: transitions
      });
    }
  }, {
    key: "updateTransition",
    value: function updateTransition(timestamp) {
      var attributeTransitionManager = this.attributeTransitionManager;
      var transitionUpdated = attributeTransitionManager.setCurrentTime(timestamp);
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.attributes;
    }
  }, {
    key: "getChangedAttributes",
    value: function getChangedAttributes() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearChangedFlags: false
      };
      var attributes = this.attributes,
          attributeTransitionManager = this.attributeTransitionManager;
      var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }

      return changedAttributes;
    }
  }, {
    key: "getAccessors",
    value: function getAccessors() {
      return this.updateTriggers;
    }
  }, {
    key: "_add",
    value: function _add(attributes, updaters) {
      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (updaters) {
        _log.default.warn('AttributeManager.add({updaters}) - updater map no longer supported')();
      }

      var newAttributes = {};

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        var newAttribute = this._createAttribute(attributeName, attribute, extraProps);

        newAttributes[attributeName] = newAttribute;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }
  }, {
    key: "_createAttribute",
    value: function _createAttribute(name, attribute, extraProps) {
      var props = {
        id: name,
        constant: attribute.constant || false,
        isIndexed: attribute.isIndexed || attribute.elements,
        size: attribute.elements && 1 || attribute.size,
        value: attribute.value || null,
        divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor
      };
      return new _attribute.default(this.gl, Object.assign({}, attribute, props));
    }
  }, {
    key: "_mapUpdateTriggersToAttributes",
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach(function (triggerName) {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }

          triggers[triggerName].push(attributeName);
        });
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: "_invalidateTrigger",
    value: function _invalidateTrigger(triggerName, dataRange) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;
      var invalidatedAttributes = updateTriggers[triggerName];

      if (invalidatedAttributes) {
        invalidatedAttributes.forEach(function (name) {
          var attribute = attributes[name];

          if (attribute) {
            attribute.setNeedsUpdate(attribute.id, dataRange);
          }
        });
      } else {
        var message = "invalidating non-existent trigger ".concat(triggerName, " for ").concat(this.id, "\n");
        message += "Valid triggers: ".concat(Object.keys(attributes).join(', '));

        _log.default.warn(message, invalidatedAttributes)();
      }

      return invalidatedAttributes;
    }
  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(opts) {
      var attribute = opts.attribute,
          numInstances = opts.numInstances;

      if (attribute.allocate(numInstances)) {
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: "".concat(attribute.id, " allocated ").concat(numInstances),
          id: this.id
        });
      }

      var timeStart = Date.now();
      var updated = attribute.updateBuffer(opts);

      if (updated) {
        this.needsRedraw = true;
        var timeMs = Math.round(Date.now() - timeStart);
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms")
        });
      }
    }
  }]);
  return AttributeManager;
}();

exports.default = AttributeManager;

},{"../utils/log":117,"./attribute":62,"./attribute-transition-manager":60,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],60:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@luma.gl/core");

var _attributeTransitionUtils = require("./attribute-transition-utils");

var _attribute = _interopRequireDefault(require("./attribute"));

var _baseAttribute = _interopRequireDefault(require("./base-attribute"));

var _transition = _interopRequireDefault(require("../transitions/transition"));

var _log = _interopRequireDefault(require("../utils/log"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var noop = function noop() {};

var DEFAULT_TRANSITION_SETTINGS = {
  duration: 0,
  easing: function easing(t) {
    return t;
  },
  onStart: noop,
  onEnd: noop,
  onInterrupt: noop
};

var AttributeTransitionManager = function () {
  function AttributeTransitionManager(gl, _ref) {
    var id = _ref.id;
    (0, _classCallCheck2.default)(this, AttributeTransitionManager);
    this.id = id;
    this.gl = gl;
    this.attributeTransitions = {};
    this.needsRedraw = false;
    this.transform = null;
    this.numInstances = 0;

    if (_core.Transform.isSupported(gl)) {
      this.isSupported = true;
    } else if (gl) {
      _log.default.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();
    }
  }

  (0, _createClass2.default)(AttributeTransitionManager, [{
    key: "finalize",
    value: function finalize() {
      if (this.transform) {
        this.transform.delete();
      }

      for (var attributeName in this.attributeTransitions) {
        this._removeTransition(attributeName);
      }
    }
  }, {
    key: "update",
    value: function update(_ref2) {
      var attributes = _ref2.attributes,
          _ref2$transitions = _ref2.transitions,
          transitions = _ref2$transitions === void 0 ? {} : _ref2$transitions,
          numInstances = _ref2.numInstances;
      this.opts = transitions;
      this.numInstances = numInstances || 1;

      if (!this.isSupported) {
        return;
      }

      var attributeTransitions = this.attributeTransitions;
      var changedTransitions = {};

      for (var attributeName in attributes) {
        var hasChanged = this._updateAttribute(attributeName, attributes[attributeName]);

        if (hasChanged) {
          changedTransitions[attributeName] = attributeTransitions[attributeName];
        }
      }

      for (var _attributeName in attributeTransitions) {
        var attribute = attributes[_attributeName];

        if (!attribute || !attribute.supportsTransition()) {
          this._removeTransition(_attributeName);
        }
      }

      if (!this.transform) {
        this._createModel();
      } else if (this.transform) {
        var _getBuffers = (0, _attributeTransitionUtils.getBuffers)(changedTransitions),
            sourceBuffers = _getBuffers.sourceBuffers,
            feedbackBuffers = _getBuffers.feedbackBuffers;

        this.transform.update({
          elementCount: this.numInstances,
          sourceBuffers: sourceBuffers,
          feedbackBuffers: feedbackBuffers
        });
      }
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(attributeName) {
      return attributeName in this.attributeTransitions;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      var animatedAttributes = {};

      for (var attributeName in this.attributeTransitions) {
        var transition = this.attributeTransitions[attributeName];

        if (transition.buffer) {
          animatedAttributes[attributeName] = transition.attributeInTransition;
        }
      }

      return animatedAttributes;
    }
  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(currentTime) {
      if (!this.transform || this.numInstances === 0) {
        return false;
      }

      var uniforms = {};
      var needsRedraw = this.needsRedraw;
      this.needsRedraw = false;

      for (var attributeName in this.attributeTransitions) {
        var transition = this.attributeTransitions[attributeName];
        var updated = transition.update(currentTime);

        if (updated) {
          uniforms["".concat(attributeName, "Time")] = transition.time;
          needsRedraw = true;
        }
      }

      if (needsRedraw) {
        this.transform.run({
          uniforms: uniforms
        });
      }

      return needsRedraw;
    }
  }, {
    key: "_createTransition",
    value: function _createTransition(attributeName, attribute) {
      var transition = this.attributeTransitions[attributeName];

      if (!transition) {
        transition = new _transition.default({
          name: attributeName,
          attribute: attribute,
          attributeInTransition: new _attribute.default(this.gl, attribute),
          bufferLayout: attribute.bufferLayout
        });
        this.attributeTransitions[attributeName] = transition;

        this._invalidateModel();

        return transition;
      }

      return null;
    }
  }, {
    key: "_removeTransition",
    value: function _removeTransition(attributeName) {
      var transition = this.attributeTransitions[attributeName];

      if (transition) {
        if (transition.buffer) {
          transition.buffer.delete();
        }

        if (transition._swapBuffer) {
          transition._swapBuffer.delete();
        }

        delete this.attributeTransitions[attributeName];

        this._invalidateModel();
      }
    }
  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(attributeName, attribute) {
      var settings = attribute.getTransitionSetting(this.opts);

      if (settings) {
        var hasChanged;
        var transition = this.attributeTransitions[attributeName];

        if (transition) {
          hasChanged = attribute.needsRedraw();
        } else {
          transition = this._createTransition(attributeName, attribute);
          hasChanged = true;
        }

        if (hasChanged) {
          this._triggerTransition(transition, settings);

          return true;
        }
      }

      return false;
    }
  }, {
    key: "_invalidateModel",
    value: function _invalidateModel() {
      if (this.transform) {
        this.transform.delete();
        this.transform = null;
      }
    }
  }, {
    key: "_createModel",
    value: function _createModel() {
      if (Object.keys(this.attributeTransitions).length === 0) {
        return;
      }

      this.transform = new _core.Transform(this.gl, Object.assign({
        elementCount: this.numInstances
      }, (0, _attributeTransitionUtils.getBuffers)(this.attributeTransitions), (0, _attributeTransitionUtils.getShaders)(this.attributeTransitions)));
    }
  }, {
    key: "_getNextTransitionStates",
    value: function _getNextTransitionStates(transition, settings) {
      var attribute = transition.attribute;
      var size = attribute.size,
          offset = attribute.offset,
          normalized = attribute.normalized;
      var toState;

      if (attribute.constant) {
        toState = new _baseAttribute.default(this.gl, {
          constant: true,
          value: attribute.value,
          size: size,
          offset: offset
        });
      } else {
        toState = new _baseAttribute.default(this.gl, {
          constant: false,
          buffer: attribute.getBuffer(),
          divisor: 0,
          size: size,
          offset: offset,
          normalized: normalized,
          value: attribute.externalBuffer ? null : attribute.value
        });
      }

      var fromState = transition.buffer || toState;
      var toLength = attribute.userData.noAlloc ? attribute.value.length : this.numInstances * size;
      var fromLength = fromState instanceof _core.Buffer && fromState.getElementCount() || toLength;
      var buffer = transition._swapBuffer;
      transition._swapBuffer = transition.buffer;

      if (!buffer) {
        buffer = new _core.Buffer(this.gl, {
          data: new Float32Array(toLength),
          usage: 35050
        });
      } else if (buffer.getElementCount() < toLength) {
        buffer.setData({
          data: new Float32Array(toLength)
        });
      }

      transition.attributeInTransition.update({
        buffer: buffer
      });
      (0, _attributeTransitionUtils.padBuffer)({
        fromState: fromState,
        toState: toState,
        fromLength: fromLength,
        toLength: toLength,
        fromBufferLayout: transition.bufferLayout,
        toBufferLayout: attribute.bufferLayout,
        offset: attribute.elementOffset,
        getData: settings.enter
      });
      transition.bufferLayout = attribute.bufferLayout;
      return {
        fromState: fromState,
        toState: toState,
        buffer: buffer
      };
    }
  }, {
    key: "_triggerTransition",
    value: function _triggerTransition(transition, settings) {
      (0, _assert.default)(settings && settings.duration > 0);
      this.needsRedraw = true;
      var transitionSettings = Object.assign({}, DEFAULT_TRANSITION_SETTINGS, settings);
      transition.start(Object.assign({}, this._getNextTransitionStates(transition, settings), transitionSettings));
    }
  }]);
  return AttributeTransitionManager;
}();

exports.default = AttributeTransitionManager;

},{"../transitions/transition":106,"../utils/assert":109,"../utils/log":117,"./attribute":62,"./attribute-transition-utils":61,"./base-attribute":63,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShaders = getShaders;
exports.getBuffers = getBuffers;
exports.padBuffer = padBuffer;

var _core = require("@luma.gl/core");

var _arrayUtils = require("../utils/array-utils");

var ATTRIBUTE_MAPPING = {
  1: 'float',
  2: 'vec2',
  3: 'vec3',
  4: 'vec4'
};

function getShaders(transitions) {
  var varyings = [];
  var attributeDeclarations = [];
  var uniformsDeclarations = [];
  var varyingDeclarations = [];
  var calculations = [];

  for (var attributeName in transitions) {
    var transition = transitions[attributeName];
    var attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];

    if (attributeType) {
      transition.bufferIndex = varyings.length;
      varyings.push(attributeName);
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "From;"));
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "To;"));
      uniformsDeclarations.push("uniform float ".concat(attributeName, "Time;"));
      varyingDeclarations.push("varying ".concat(attributeType, " ").concat(attributeName, ";"));
      calculations.push("".concat(attributeName, " = mix(").concat(attributeName, "From, ").concat(attributeName, "To,\n        ").concat(attributeName, "Time);"));
    }
  }

  var vs = "\n#define SHADER_NAME feedback-vertex-shader\n".concat(attributeDeclarations.join('\n'), "\n").concat(uniformsDeclarations.join('\n'), "\n").concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  ").concat(calculations.join('\n'), "\n  gl_Position = vec4(0.0);\n}\n");
  var fs = "#define SHADER_NAME feedback-fragment-shader\n\nprecision highp float;\n\n".concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n");
  return {
    vs: vs,
    fs: fs,
    varyings: varyings
  };
}

function getBuffers(transitions) {
  var sourceBuffers = {};
  var feedbackBuffers = {};

  for (var attributeName in transitions) {
    var _transitions$attribut = transitions[attributeName],
        fromState = _transitions$attribut.fromState,
        toState = _transitions$attribut.toState,
        buffer = _transitions$attribut.buffer;
    sourceBuffers["".concat(attributeName, "From")] = fromState instanceof _core.Buffer ? [fromState, {
      divisor: 0,
      offset: toState.offset
    }] : fromState;
    sourceBuffers["".concat(attributeName, "To")] = toState;
    feedbackBuffers["".concat(attributeName)] = {
      buffer: buffer,
      byteOffset: toState.offset
    };
  }

  return {
    sourceBuffers: sourceBuffers,
    feedbackBuffers: feedbackBuffers
  };
}

function padBuffer(_ref) {
  var fromState = _ref.fromState,
      toState = _ref.toState,
      fromLength = _ref.fromLength,
      toLength = _ref.toLength,
      fromBufferLayout = _ref.fromBufferLayout,
      toBufferLayout = _ref.toBufferLayout,
      offset = _ref.offset,
      _ref$getData = _ref.getData,
      getData = _ref$getData === void 0 ? function (x) {
    return x;
  } : _ref$getData;
  var hasBufferLayout = fromBufferLayout && toBufferLayout;

  if (!hasBufferLayout && fromLength >= toLength || !(fromState instanceof _core.Buffer)) {
    return;
  }

  var data = new Float32Array(toLength);
  var fromData = fromState.getData({});
  var size = toState.size,
      constant = toState.constant;
  var toData = constant ? toState.getValue() : toState.getBuffer().getData({});
  var getMissingData = constant ? function (i, chunk) {
    return getData(toData, chunk);
  } : function (i, chunk) {
    return getData(toData.subarray(i, i + size), chunk);
  };
  (0, _arrayUtils.padArray)({
    source: fromData,
    target: data,
    sourceLayout: fromBufferLayout,
    targetLayout: toBufferLayout,
    offset: offset,
    size: toState.size,
    getData: getMissingData
  });
  fromState.setData({
    data: data
  });
}

},{"../utils/array-utils":108,"@luma.gl/core":253}],62:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glArrayFromType = glArrayFromType;
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _iterableUtils = require("../utils/iterable-utils");

var _flatten = require("../utils/flatten");

var range = _interopRequireWildcard(require("../utils/range"));

var _log = _interopRequireDefault(require("../utils/log"));

var _baseAttribute = _interopRequireDefault(require("./base-attribute"));

var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));

var DEFAULT_STATE = {
  isExternalBuffer: false,
  lastExternalBuffer: null,
  allocatedValue: null,
  needsUpdate: true,
  needsRedraw: false,
  updateRanges: range.FULL
};

var Attribute = function (_BaseAttribute) {
  (0, _inherits2.default)(Attribute, _BaseAttribute);

  function Attribute(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Attribute);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Attribute).call(this, gl, opts));
    var _opts$transition = opts.transition,
        transition = _opts$transition === void 0 ? false : _opts$transition,
        _opts$noAlloc = opts.noAlloc,
        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,
        _opts$update = opts.update,
        update = _opts$update === void 0 ? null : _opts$update,
        _opts$accessor = opts.accessor,
        accessor = _opts$accessor === void 0 ? null : _opts$accessor,
        _opts$bufferLayout = opts.bufferLayout,
        bufferLayout = _opts$bufferLayout === void 0 ? null : _opts$bufferLayout;
    var _opts$defaultValue = opts.defaultValue,
        defaultValue = _opts$defaultValue === void 0 ? [0, 0, 0, 0] : _opts$defaultValue;
    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
    _this.shaderAttributes = {};
    _this.hasShaderAttributes = false;

    if (opts.shaderAttributes) {
      var shaderAttributes = opts.shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        _this.shaderAttributes[shaderAttributeName] = new Attribute(_this.gl, Object.assign({
          offset: _this.offset,
          stride: _this.stride,
          normalized: _this.normalized
        }, shaderAttribute, {
          id: shaderAttributeName,
          constant: shaderAttribute.constant || false,
          isIndexed: shaderAttribute.isIndexed || shaderAttribute.elements,
          size: shaderAttribute.elements && 1 || shaderAttribute.size || _this.size,
          value: shaderAttribute.value || null,
          divisor: shaderAttribute.instanced || shaderAttribute.divisor || _this.divisor,
          buffer: _this.getBuffer(),
          noAlloc: true
        }));
        _this.hasShaderAttributes = true;
      }
    }

    Object.assign(_this.userData, DEFAULT_STATE, opts, {
      transition: transition,
      noAlloc: noAlloc,
      update: update || accessor && _this._standardAccessor,
      accessor: accessor,
      defaultValue: defaultValue,
      bufferLayout: bufferLayout
    });
    Object.seal(_this.userData);

    _this._validateAttributeUpdaters();

    return _this;
  }

  (0, _createClass2.default)(Attribute, [{
    key: "delete",
    value: function _delete() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Attribute.prototype), "delete", this).call(this);

      _typedArrayManager.default.release(this.userData.allocatedValue);
    }
  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      return this.userData.needsUpdate;
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$clearChangedFlag = _ref.clearChangedFlags,
          clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;

      var needsRedraw = this.userData.needsRedraw;
      this.userData.needsRedraw = this.userData.needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
  }, {
    key: "getUpdateTriggers",
    value: function getUpdateTriggers() {
      var accessor = this.userData.accessor;
      return [this.id].concat(typeof accessor !== 'function' && accessor || []);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor() {
      return this.userData.accessor;
    }
  }, {
    key: "getShaderAttributes",
    value: function getShaderAttributes() {
      var shaderAttributes = {};

      if (this.hasShaderAttributes) {
        Object.assign(shaderAttributes, this.shaderAttributes);
      } else {
        shaderAttributes[this.id] = this;
      }

      return shaderAttributes;
    }
  }, {
    key: "supportsTransition",
    value: function supportsTransition() {
      return this.userData.transition;
    }
  }, {
    key: "getTransitionSetting",
    value: function getTransitionSetting(opts) {
      var _this$userData = this.userData,
          transition = _this$userData.transition,
          accessor = _this$userData.accessor;

      if (!transition) {
        return null;
      }

      var settings = Array.isArray(accessor) ? opts[accessor.find(function (a) {
        return opts[a];
      })] : opts[accessor];

      if (Number.isFinite(settings)) {
        settings = {
          duration: settings
        };
      }

      if (settings && settings.duration > 0) {
        return Object.assign({}, transition, settings);
      }

      return null;
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      var dataRange = arguments.length > 1 ? arguments[1] : undefined;
      this.userData.needsUpdate = this.userData.needsUpdate || reason;

      if (dataRange) {
        var _dataRange$startRow = dataRange.startRow,
            startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,
            _dataRange$endRow = dataRange.endRow,
            endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;
        this.userData.updateRanges = range.add(this.userData.updateRanges, [startRow, endRow]);
      } else {
        this.userData.updateRanges = range.FULL;
      }
    }
  }, {
    key: "clearNeedsUpdate",
    value: function clearNeedsUpdate() {
      this.userData.needsUpdate = false;
      this.userData.updateRanges = range.EMPTY;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      this.userData.needsRedraw = this.userData.needsRedraw || reason;
    }
  }, {
    key: "allocate",
    value: function allocate(numInstances) {
      var state = this.userData;

      if (state.isExternalBuffer || state.noAlloc) {
        return false;
      }

      if (state.update) {
        (0, _assert.default)(Number.isFinite(numInstances));
        var allocCount = Math.max(numInstances, 1);
        var ArrayType = glArrayFromType(this.type || 5126);
        var oldValue = state.allocatedValue;
        var shouldCopy = state.updateRanges !== range.FULL;
        this.constant = false;
        this.value = _typedArrayManager.default.allocate(oldValue, allocCount, {
          size: this.size,
          type: ArrayType,
          padding: this.elementOffset,
          copy: shouldCopy
        });

        if (this.buffer && this.buffer.byteLength < this.value.byteLength) {
          this.buffer.reallocate(this.value.byteLength);

          if (shouldCopy && oldValue) {
            this.buffer.subData(oldValue);
          }
        }

        state.allocatedValue = this.value;
        return true;
      }

      return false;
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer(_ref2) {
      var numInstances = _ref2.numInstances,
          bufferLayout = _ref2.bufferLayout,
          data = _ref2.data,
          props = _ref2.props,
          context = _ref2.context;

      if (!this.needsUpdate()) {
        return false;
      }

      var state = this.userData;
      var update = state.update,
          updateRanges = state.updateRanges,
          noAlloc = state.noAlloc;
      var updated = true;

      if (update) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = updateRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
                startRow = _step$value[0],
                endRow = _step$value[1];

            update.call(context, this, {
              data: data,
              startRow: startRow,
              endRow: endRow,
              props: props,
              numInstances: numInstances,
              bufferLayout: bufferLayout
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength) {
          this.update({
            value: this.value,
            constant: this.constant
          });
        } else {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = updateRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
                  startRow = _step2$value[0],
                  endRow = _step2$value[1];

              var startOffset = Number.isFinite(startRow) ? this._getVertexOffset(startRow, this.bufferLayout) : 0;
              var endOffset = Number.isFinite(endRow) ? this._getVertexOffset(endRow, this.bufferLayout) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
              this.buffer.subData({
                data: this.value.subarray(startOffset, endOffset),
                offset: startOffset * this.value.BYTES_PER_ELEMENT
              });
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        this._checkAttributeArray();
      } else {
        updated = false;
      }

      this._updateShaderAttributes();

      this.clearNeedsUpdate();
      state.needsRedraw = true;
      return updated;
    }
  }, {
    key: "update",
    value: function update(props) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Attribute.prototype), "update", this).call(this, props);

      this._updateShaderAttributes();
    }
  }, {
    key: "setGenericValue",
    value: function setGenericValue(value) {
      var state = this.userData;

      if (value === undefined || typeof value === 'function') {
        state.isExternalBuffer = false;
        return false;
      }

      value = this._normalizeValue(value);
      var hasChanged = !this.constant || !this._areValuesEqual(value, this.value);

      if (hasChanged) {
        this.update({
          constant: true,
          value: value
        });
      }

      state.needsRedraw = state.needsUpdate || hasChanged;
      this.clearNeedsUpdate();
      state.isExternalBuffer = true;

      this._updateShaderAttributes();

      return true;
    }
  }, {
    key: "setExternalBuffer",
    value: function setExternalBuffer(buffer) {
      var state = this.userData;

      if (!buffer) {
        state.isExternalBuffer = false;
        state.lastExternalBuffer = null;
        return false;
      }

      this.clearNeedsUpdate();

      if (state.lastExternalBuffer === buffer) {
        return true;
      }

      state.isExternalBuffer = true;
      state.lastExternalBuffer = buffer;
      var opts;

      if (ArrayBuffer.isView(buffer)) {
        opts = {
          constant: false,
          value: buffer
        };
      } else if (buffer instanceof _core.Buffer) {
        opts = {
          constant: false,
          buffer: buffer
        };
      } else {
        opts = Object.assign({
          constant: false
        }, buffer);
      }

      if (opts.value) {
        var ArrayType = glArrayFromType(this.type || 5126);

        if (!(opts.value instanceof ArrayType)) {
          _log.default.warn("Attribute prop ".concat(this.id, " is casted to ").concat(ArrayType.name))();

          opts.value = new ArrayType(opts.value);
        }
      }

      this.update(opts);
      state.needsRedraw = true;

      this._updateShaderAttributes();

      return true;
    }
  }, {
    key: "_getVertexOffset",
    value: function _getVertexOffset(row, bufferLayout) {
      var offset = this.elementOffset;

      if (bufferLayout) {
        var index = 0;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = bufferLayout[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var geometrySize = _step3.value;

            if (index >= row) {
              break;
            }

            offset += geometrySize * this.size;
            index++;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return offset;
      }

      return offset + row * this.size;
    }
  }, {
    key: "_normalizeValue",
    value: function _normalizeValue(value) {
      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var defaultValue = this.userData.defaultValue;

      if (!Array.isArray(value) && !ArrayBuffer.isView(value)) {
        out[start] = Number.isFinite(value) ? value : defaultValue[0];
        return out;
      }

      switch (this.size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];

        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];

        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];

        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
      }

      return out;
    }
  }, {
    key: "_areValuesEqual",
    value: function _areValuesEqual(value1, value2) {
      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.size;

      for (var i = 0; i < size; i++) {
        if (value1[i] !== value2[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_standardAccessor",
    value: function _standardAccessor(attribute, _ref3) {
      var data = _ref3.data,
          startRow = _ref3.startRow,
          endRow = _ref3.endRow,
          props = _ref3.props,
          numInstances = _ref3.numInstances,
          bufferLayout = _ref3.bufferLayout;
      var state = attribute.userData;
      var accessor = state.accessor;
      var value = attribute.value,
          size = attribute.size;
      var accessorFunc = typeof accessor === 'function' ? accessor : props[accessor];
      (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));

      var i = attribute._getVertexOffset(startRow, bufferLayout);

      var _createIterable = (0, _iterableUtils.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = iterable[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var object = _step4.value;
          objectInfo.index++;
          var objectValue = accessorFunc(object, objectInfo);

          if (bufferLayout) {
            attribute._normalizeValue(objectValue, objectInfo.target);

            var numVertices = bufferLayout[objectInfo.index];
            (0, _flatten.fillArray)({
              target: attribute.value,
              source: objectInfo.target,
              start: i,
              count: numVertices
            });
            i += numVertices * size;
          } else {
            attribute._normalizeValue(objectValue, value, i);

            i += size;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      attribute.constant = false;
      attribute.bufferLayout = bufferLayout;
    }
  }, {
    key: "_validateAttributeUpdaters",
    value: function _validateAttributeUpdaters() {
      var state = this.userData;
      var hasUpdater = state.noAlloc || typeof state.update === 'function';

      if (!hasUpdater) {
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
      }
    }
  }, {
    key: "_checkAttributeArray",
    value: function _checkAttributeArray() {
      var value = this.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);

        if (!valid) {
          throw new Error("Illegal attribute generated for ".concat(this.id));
        }
      }
    }
  }, {
    key: "_updateShaderAttributes",
    value: function _updateShaderAttributes() {
      var shaderAttributes = this.shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        shaderAttribute.update({
          buffer: this.getBuffer(),
          value: this.value,
          constant: this.constant
        });
      }
    }
  }, {
    key: "bufferLayout",
    get: function get() {
      return this.userData.bufferLayout;
    },
    set: function set(layout) {
      this.userData.bufferLayout = layout;
    }
  }]);
  return Attribute;
}(_baseAttribute.default);

exports.default = Attribute;

function glArrayFromType(glType) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$clamped = _ref4.clamped,
      clamped = _ref4$clamped === void 0 ? true : _ref4$clamped;

  switch (glType) {
    case 5126:
      return Float32Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce type from array');
  }
}

},{"../utils/assert":109,"../utils/flatten":112,"../utils/iterable-utils":115,"../utils/log":117,"../utils/range":121,"../utils/typed-array-manager":124,"./base-attribute":63,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37,"@luma.gl/core":253}],63:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@luma.gl/core");

var BaseAttribute = function () {
  function BaseAttribute(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, BaseAttribute);
    var _opts$id = opts.id,
        id = _opts$id === void 0 ? (0, _core.uid)('attribute') : _opts$id,
        type = opts.type,
        _opts$isIndexed = opts.isIndexed,
        isIndexed = _opts$isIndexed === void 0 ? false : _opts$isIndexed;
    this.gl = gl;
    this.id = id;
    this.isIndexed = isIndexed;
    this.target = isIndexed ? 34963 : 34962;
    this.type = type;

    if (isIndexed && !type) {
      this.type = gl && (0, _core.hasFeature)(gl, _core.FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
    }

    this.value = null;
    this.externalBuffer = null;
    this.buffer = null;
    this.userData = {};
    this.update(opts);

    this._validateAttributeDefinition();
  }

  (0, _createClass2.default)(BaseAttribute, [{
    key: "delete",
    value: function _delete() {
      if (this.buffer) {
        this.buffer.delete();
        this.buffer = null;
      }
    }
  }, {
    key: "update",
    value: function update(opts) {
      var value = opts.value,
          buffer = opts.buffer,
          _opts$constant = opts.constant,
          constant = _opts$constant === void 0 ? this.constant || false : _opts$constant;
      this.constant = constant;

      if (buffer) {
        this.externalBuffer = buffer;
        this.constant = false;
        this.type = opts.type || buffer.accessor.type;

        if (buffer.accessor.divisor !== undefined) {
          this.divisor = buffer.accessor.divisor;
        }

        if (opts.divisor !== undefined) {
          this.divisor = opts.divisor;
        }
      } else if (value) {
        this.externalBuffer = null;
        var size = this.size || opts.size || 0;

        if (constant && value.length !== size) {
          this.value = new Float32Array(size);

          this._setAccessor(opts);

          var index = this.elementOffset;

          for (var i = 0; i < this.size; ++i) {
            this.value[i] = value[index + i];
          }
        } else {
          this.value = value;
        }

        if (!constant && this.gl) {
          this.buffer = this.buffer || this._createBuffer(opts);
          this.buffer.setData({
            data: value
          });
          this.type = this.buffer.accessor.type;
        }
      }

      this._setAccessor(opts);

      if (constant && this.normalized) {
        this.value = this._normalizeConstant(this.value);
      }
    }
  }, {
    key: "getBuffer",
    value: function getBuffer() {
      if (this.constant) {
        return null;
      }

      return this.externalBuffer || this.buffer;
    }
  }, {
    key: "getValue",
    value: function getValue() {
      if (this.constant) {
        return this.value;
      }

      var buffer = this.externalBuffer || this.buffer;

      if (buffer) {
        return [buffer, this];
      }

      return null;
    }
  }, {
    key: "_createBuffer",
    value: function _createBuffer(opts) {
      var props = Object.assign({}, opts, {
        id: this.id,
        target: this.target,
        accessor: {
          type: this.type
        }
      });

      if (Number.isFinite(props.divisor)) {
        props.accessor.divisor = props.divisor;
      }

      delete props.divisor;

      if (Number.isFinite(props.size)) {
        props.accessor.size = props.size;
      }

      delete props.size;
      return new _core.Buffer(this.gl, props);
    }
  }, {
    key: "_setAccessor",
    value: function _setAccessor(opts) {
      var _opts$size = opts.size,
          size = _opts$size === void 0 ? this.size : _opts$size,
          _opts$offset = opts.offset,
          offset = _opts$offset === void 0 ? this.offset || 0 : _opts$offset,
          _opts$stride = opts.stride,
          stride = _opts$stride === void 0 ? this.stride || 0 : _opts$stride,
          _opts$normalized = opts.normalized,
          normalized = _opts$normalized === void 0 ? this.normalized || false : _opts$normalized,
          _opts$integer = opts.integer,
          integer = _opts$integer === void 0 ? this.integer || false : _opts$integer,
          _opts$divisor = opts.divisor,
          divisor = _opts$divisor === void 0 ? this.divisor || 0 : _opts$divisor,
          instanced = opts.instanced,
          isInstanced = opts.isInstanced;
      this.size = size;
      this.offset = offset;
      this.elementOffset = offset / _core._Accessor.getBytesPerElement(this);
      this.stride = stride;
      this.normalized = normalized;
      this.integer = integer;
      this.divisor = divisor;

      if (isInstanced !== undefined) {
        _core.log.deprecated('Attribute.isInstanced')();

        this.divisor = isInstanced ? 1 : 0;
      }

      if (instanced !== undefined) {
        _core.log.deprecated('Attribute.instanced')();

        this.divisor = instanced ? 1 : 0;
      }
    }
  }, {
    key: "_normalizeConstant",
    value: function _normalizeConstant(value) {
      switch (this.type) {
        case 5120:
          return new Float32Array(value).map(function (x) {
            return (x + 128) / 255 * 2 - 1;
          });

        case 5122:
          return new Float32Array(value).map(function (x) {
            return (x + 32768) / 65535 * 2 - 1;
          });

        case 5121:
          return new Float32Array(value).map(function (x) {
            return x / 255;
          });

        case 5123:
          return new Float32Array(value).map(function (x) {
            return x / 65535;
          });

        default:
          return value;
      }
    }
  }, {
    key: "_validateAttributeDefinition",
    value: function _validateAttributeDefinition() {}
  }]);
  return BaseAttribute;
}();

exports.default = BaseAttribute;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],64:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _layer = _interopRequireDefault(require("./layer"));

var _log = _interopRequireDefault(require("../utils/log"));

var _flatten = require("../utils/flatten");

var CompositeLayer = function (_Layer) {
  (0, _inherits2.default)(CompositeLayer, _Layer);

  function CompositeLayer() {
    (0, _classCallCheck2.default)(this, CompositeLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CompositeLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(CompositeLayer, [{
    key: "getSubLayers",
    value: function getSubLayers() {
      return this.internalState && this.internalState.subLayers || [];
    }
  }, {
    key: "initializeState",
    value: function initializeState() {}
  }, {
    key: "setState",
    value: function setState(updateObject) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(CompositeLayer.prototype), "setState", this).call(this, updateObject);
      this.setLayerNeedsUpdate();
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref) {
      var info = _ref.info;
      var object = info.object;
      var isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;

      if (!isDataWrapped) {
        return info;
      }

      return Object.assign(info, {
        object: object.__source.object,
        index: object.__source.index
      });
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      return null;
    }
  }, {
    key: "shouldRenderSubLayer",
    value: function shouldRenderSubLayer(id, data) {
      var overridingProps = this.props._subLayerProps;
      return data && data.length || overridingProps && overridingProps[id];
    }
  }, {
    key: "getSubLayerClass",
    value: function getSubLayerClass(id, DefaultLayerClass) {
      var overridingProps = this.props._subLayerProps;
      return overridingProps && overridingProps[id] && overridingProps[id].type || DefaultLayerClass;
    }
  }, {
    key: "getSubLayerRow",
    value: function getSubLayerRow(row, sourceObject, sourceObjectIndex) {
      row.__source = {
        parent: this,
        object: sourceObject,
        index: sourceObjectIndex
      };
      return row;
    }
  }, {
    key: "getSubLayerAccessor",
    value: function getSubLayerAccessor(accessor) {
      if (typeof accessor === 'function') {
        var objectInfo = {
          data: this.props.data,
          target: []
        };
        return function (x, i) {
          if (x.__source) {
            objectInfo.index = x.__source.index;
            return accessor(x.__source.object, objectInfo);
          }

          return accessor(x, i);
        };
      }

      return accessor;
    }
  }, {
    key: "getSubLayerProps",
    value: function getSubLayerProps(sublayerProps) {
      var _this$props = this.props,
          opacity = _this$props.opacity,
          pickable = _this$props.pickable,
          visible = _this$props.visible,
          parameters = _this$props.parameters,
          getPolygonOffset = _this$props.getPolygonOffset,
          highlightedObjectIndex = _this$props.highlightedObjectIndex,
          autoHighlight = _this$props.autoHighlight,
          highlightColor = _this$props.highlightColor,
          coordinateSystem = _this$props.coordinateSystem,
          coordinateOrigin = _this$props.coordinateOrigin,
          wrapLongitude = _this$props.wrapLongitude,
          positionFormat = _this$props.positionFormat,
          modelMatrix = _this$props.modelMatrix,
          extensions = _this$props.extensions,
          overridingProps = _this$props._subLayerProps;
      var newProps = {
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        parameters: parameters,
        getPolygonOffset: getPolygonOffset,
        highlightedObjectIndex: highlightedObjectIndex,
        autoHighlight: autoHighlight,
        highlightColor: highlightColor,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin,
        wrapLongitude: wrapLongitude,
        positionFormat: positionFormat,
        modelMatrix: modelMatrix,
        extensions: extensions
      };

      if (sublayerProps) {
        var overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];
        var overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
        Object.assign(newProps, sublayerProps, overridingSublayerProps, {
          id: "".concat(this.props.id, "-").concat(sublayerProps.id),
          updateTriggers: Object.assign({
            all: this.props.updateTriggers.all
          }, sublayerProps.updateTriggers, overridingSublayerTriggers)
        });
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var extension = _step.value;
          var passThroughProps = extension.getSubLayerProps.call(this, extension);
          Object.assign(newProps, passThroughProps, {
            updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return newProps;
    }
  }, {
    key: "_getAttributeManager",
    value: function _getAttributeManager() {
      return null;
    }
  }, {
    key: "_renderLayers",
    value: function _renderLayers() {
      var subLayers = this.internalState.subLayers;

      if (subLayers && !this.needsUpdate()) {
        _log.default.log(3, "Composite layer reused subLayers ".concat(this), this.internalState.subLayers)();
      } else {
        subLayers = this.renderLayers();
        subLayers = (0, _flatten.flatten)(subLayers, {
          filter: Boolean
        });
        this.internalState.subLayers = subLayers;

        _log.default.log(2, "Composite layer rendered new subLayers ".concat(this), subLayers)();
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = subLayers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;
          layer.parent = this;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "isComposite",
    get: function get() {
      return true;
    }
  }]);
  return CompositeLayer;
}(_layer.default);

exports.default = CompositeLayer;
CompositeLayer.layerName = 'CompositeLayer';

},{"../utils/flatten":112,"../utils/log":117,"./layer":76,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EVENTS = exports.COORDINATE_SYSTEM = void 0;
var COORDINATE_SYSTEM = {
  LNGLAT: 1,
  LNGLAT_DEPRECATED: 5,
  METER_OFFSETS: 2,
  METERS: 2,
  LNGLAT_OFFSETS: 3,
  IDENTITY: 0
};
exports.COORDINATE_SYSTEM = COORDINATE_SYSTEM;
var EVENTS = {
  click: {
    handler: 'onClick'
  },
  panstart: {
    handler: 'onDragStart'
  },
  panmove: {
    handler: 'onDrag'
  },
  panend: {
    handler: 'onDragEnd'
  }
};
exports.EVENTS = EVENTS;

},{}],66:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@luma.gl/core");

var _getPixelRatio = _interopRequireDefault(require("../utils/get-pixel-ratio"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));

var _queryObject = require("./picking/query-object");

var _pickInfo = require("./picking/pick-info");

var DeckPicker = function () {
  function DeckPicker(gl) {
    (0, _classCallCheck2.default)(this, DeckPicker);
    this.gl = gl;
    this.pickingFBO = null;
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.pixelRatio = null;
    this.layerFilter = null;
    this.pickingEvent = null;
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }

  (0, _createClass2.default)(DeckPicker, [{
    key: "setProps",
    value: function setProps(props) {
      if ('useDevicePixels' in props) {
        this.pixelRatio = (0, _getPixelRatio.default)(props.useDevicePixels);
      }

      if ('layerFilter' in props) {
        this.layerFilter = props.layerFilter;
      }

      this.pickLayersPass.setProps({
        pixelRatio: this.pixelRatio,
        layerFilter: this.layerFilter
      });
    }
  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          mode = _ref.mode,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          layers = _ref.layers,
          viewports = _ref.viewports,
          activateViewport = _ref.activateViewport,
          _ref$depth = _ref.depth,
          depth = _ref$depth === void 0 ? 1 : _ref$depth,
          _ref$event = _ref.event,
          event = _ref$event === void 0 ? null : _ref$event;
      this.pickingEvent = event;
      var result = this.pickClosestObject({
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        depth: depth,
        viewports: viewports,
        onViewportActive: activateViewport
      });
      this.pickingEvent = null;
      return result;
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          width = _ref2.width,
          height = _ref2.height,
          layers = _ref2.layers,
          viewports = _ref2.viewports,
          activateViewport = _ref2.activateViewport;
      return this.pickVisibleObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        mode: 'pickObjects',
        viewports: viewports,
        onViewportActive: activateViewport
      });
    }
  }, {
    key: "getLastPickedObject",
    value: function getLastPickedObject(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          layers = _ref3.layers,
          viewports = _ref3.viewports;
      var lastPickedInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lastPickedInfo.info;
      var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
      var layer = lastPickedLayerId ? layers.find(function (l) {
        return l.id === lastPickedLayerId;
      }) : null;
      var coordinate = viewports[0] && viewports[0].unproject([x, y]);
      var info = {
        x: x,
        y: y,
        coordinate: coordinate,
        lngLat: coordinate,
        layer: layer
      };

      if (layer) {
        return Object.assign({}, lastPickedInfo, info);
      }

      return Object.assign(info, {
        color: null,
        object: null,
        index: -1
      });
    }
  }, {
    key: "updatePickingBuffer",
    value: function updatePickingBuffer() {
      var gl = this.gl;

      if (!this.pickingFBO) {
        this.pickingFBO = new _core.Framebuffer(gl);
      }

      this.pickingFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
      return this.pickingFBO;
    }
  }, {
    key: "pickClosestObject",
    value: function pickClosestObject(_ref4) {
      var layers = _ref4.layers,
          viewports = _ref4.viewports,
          x = _ref4.x,
          y = _ref4.y,
          radius = _ref4.radius,
          _ref4$depth = _ref4.depth,
          depth = _ref4$depth === void 0 ? 1 : _ref4$depth,
          mode = _ref4.mode,
          onViewportActive = _ref4.onViewportActive;
      this.updatePickingBuffer();
      var pixelRatio = this.pixelRatio;
      var deviceX = Math.round(x * pixelRatio);
      var deviceY = Math.round(this.gl.canvas.height - (y + 1) * pixelRatio);
      var deviceRadius = Math.round(radius * pixelRatio);
      var _this$pickingFBO = this.pickingFBO,
          width = _this$pickingFBO.width,
          height = _this$pickingFBO.height;
      var deviceRect = this.getPickingRect({
        deviceX: deviceX,
        deviceY: deviceY,
        deviceRadius: deviceRadius,
        deviceWidth: width,
        deviceHeight: height
      });
      var infos;
      var result = [];
      var affectedLayers = {};

      for (var i = 0; i < depth; i++) {
        var pickedColors = deviceRect && this.drawAndSamplePickingBuffer({
          layers: layers,
          viewports: viewports,
          onViewportActive: onViewportActive,
          deviceRect: deviceRect,
          redrawReason: mode
        });
        var pickInfo = (0, _queryObject.getClosestObject)({
          pickedColors: pickedColors,
          layers: layers,
          deviceX: deviceX,
          deviceY: deviceY,
          deviceRadius: deviceRadius,
          deviceRect: deviceRect
        });

        if (pickInfo.pickedColor && i + 1 < depth) {
          var layerId = pickInfo.pickedColor[3] - 1;

          if (!affectedLayers[layerId]) {
            affectedLayers[layerId] = layers[layerId].copyPickingColors();
          }

          layers[layerId].clearPickingColor(pickInfo.pickedColor);
        }

        infos = (0, _pickInfo.processPickInfo)({
          pickInfo: pickInfo,
          lastPickedInfo: this.lastPickedInfo,
          mode: mode,
          layers: layers,
          viewports: viewports,
          x: x,
          y: y,
          deviceX: deviceX,
          deviceY: deviceY,
          pixelRatio: pixelRatio
        });
        var processedPickInfos = this.callLayerPickingCallbacks(infos, mode);

        if (processedPickInfos) {
          processedPickInfos.forEach(function (info) {
            return result.push(info);
          });
        }

        if (!pickInfo.pickedColor) {
          break;
        }
      }

      Object.keys(affectedLayers).forEach(function (layerId) {
        return layers[layerId].restorePickingColors(affectedLayers[layerId]);
      });
      return {
        result: result,
        emptyInfo: infos && infos.get(null)
      };
    }
  }, {
    key: "pickVisibleObjects",
    value: function pickVisibleObjects(_ref5) {
      var layers = _ref5.layers,
          viewports = _ref5.viewports,
          x = _ref5.x,
          y = _ref5.y,
          width = _ref5.width,
          height = _ref5.height,
          mode = _ref5.mode,
          onViewportActive = _ref5.onViewportActive;
      this.updatePickingBuffer();
      var pixelRatio = this.pixelRatio;
      var deviceLeft = Math.round(x * pixelRatio);
      var deviceBottom = Math.round(this.gl.canvas.height - y * pixelRatio);
      var deviceRight = Math.round((x + width) * pixelRatio);
      var deviceTop = Math.round(this.gl.canvas.height - (y + height) * pixelRatio);
      var deviceRect = {
        x: deviceLeft,
        y: deviceTop,
        width: deviceRight - deviceLeft,
        height: deviceBottom - deviceTop
      };
      var pickedColors = this.drawAndSamplePickingBuffer({
        layers: layers,
        viewports: viewports,
        onViewportActive: onViewportActive,
        deviceRect: deviceRect,
        redrawReason: mode
      });
      var pickInfos = (0, _queryObject.getUniqueObjects)({
        pickedColors: pickedColors,
        layers: layers
      });
      var uniqueInfos = new Map();
      pickInfos.forEach(function (pickInfo) {
        var info = {
          color: pickInfo.pickedColor,
          layer: null,
          index: pickInfo.pickedObjectIndex,
          picked: true,
          x: x,
          y: y,
          width: width,
          height: height,
          pixelRatio: pixelRatio
        };
        info = (0, _pickInfo.getLayerPickingInfo)({
          layer: pickInfo.pickedLayer,
          info: info,
          mode: mode
        });

        if (!uniqueInfos.has(info.object)) {
          uniqueInfos.set(info.object, info);
        }
      });
      return Array.from(uniqueInfos.values());
    }
  }, {
    key: "drawAndSamplePickingBuffer",
    value: function drawAndSamplePickingBuffer(_ref6) {
      var layers = _ref6.layers,
          viewports = _ref6.viewports,
          onViewportActive = _ref6.onViewportActive,
          deviceRect = _ref6.deviceRect,
          redrawReason = _ref6.redrawReason;
      (0, _assert.default)(deviceRect);
      (0, _assert.default)(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');
      (0, _assert.default)(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');
      var pickableLayers = layers.filter(function (layer) {
        return layer.isPickable();
      });

      if (pickableLayers.length < 1) {
        return null;
      }

      var pickingFBO = this.pickingFBO;
      var effectProps = {
        lightSources: {}
      };
      this.pickLayersPass.render({
        layers: layers,
        viewports: viewports,
        onViewportActive: onViewportActive,
        pickingFBO: pickingFBO,
        deviceRect: deviceRect,
        redrawReason: redrawReason,
        effectProps: effectProps
      });
      var x = deviceRect.x,
          y = deviceRect.y,
          width = deviceRect.width,
          height = deviceRect.height;
      var pickedColors = new Uint8Array(width * height * 4);
      (0, _core.readPixelsToArray)(pickingFBO, {
        sourceX: x,
        sourceY: y,
        sourceWidth: width,
        sourceHeight: height,
        target: pickedColors
      });
      return pickedColors;
    }
  }, {
    key: "getPickingRect",
    value: function getPickingRect(_ref7) {
      var deviceX = _ref7.deviceX,
          deviceY = _ref7.deviceY,
          deviceRadius = _ref7.deviceRadius,
          deviceWidth = _ref7.deviceWidth,
          deviceHeight = _ref7.deviceHeight;
      var x = Math.max(0, deviceX - deviceRadius);
      var y = Math.max(0, deviceY - deviceRadius);
      var width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
      var height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;

      if (width <= 0 || height <= 0) {
        return null;
      }

      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }
  }, {
    key: "callLayerPickingCallbacks",
    value: function callLayerPickingCallbacks(infos, mode) {
      var unhandledPickInfos = [];
      var pickingEvent = this.pickingEvent;
      infos.forEach(function (info) {
        if (!info.layer) {
          return;
        }

        var handled = false;

        switch (mode) {
          case 'hover':
            handled = info.layer.onHover(info, pickingEvent);
            break;

          case 'query':
            break;

          default:
            throw new Error('unknown pick type');
        }

        if (!handled) {
          unhandledPickInfos.push(info);
        }
      });
      return unhandledPickInfos;
    }
  }]);
  return DeckPicker;
}();

exports.default = DeckPicker;

},{"../passes/pick-layers-pass":90,"../utils/assert":109,"../utils/get-pixel-ratio":113,"./picking/pick-info":77,"./picking/query-object":78,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],67:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _log = _interopRequireDefault(require("../utils/log"));

var _drawLayersPass = _interopRequireDefault(require("../passes/draw-layers-pass"));

var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));

var _getPixelRatio = _interopRequireDefault(require("../utils/get-pixel-ratio"));

var _postProcessEffect = _interopRequireDefault(require("../effects/post-process-effect"));

var _core = require("@luma.gl/core");

var LOG_PRIORITY_DRAW = 2;

var DeckRenderer = function () {
  function DeckRenderer(gl) {
    (0, _classCallCheck2.default)(this, DeckRenderer);
    this.gl = gl;
    this.pixelRatio = null;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new _drawLayersPass.default(gl);
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.renderCount = 0;
    this._needsRedraw = 'Initial render';
    this.screenBuffer = null;
    this.offscreenBuffer = null;
    this.lastPostProcessEffect = null;
  }

  (0, _createClass2.default)(DeckRenderer, [{
    key: "setProps",
    value: function setProps(props) {
      if ('useDevicePixels' in props) {
        this.pixelRatio = (0, _getPixelRatio.default)(props.useDevicePixels);
      }

      if ('layerFilter' in props) {
        if (this.layerFilter !== props.layerFilter) {
          this.layerFilter = props.layerFilter;
          this._needsRedraw = 'layerFilter changed';
        }
      }

      if ('drawPickingColors' in props) {
        if (this.drawPickingColors !== props.drawPickingColors) {
          this.drawPickingColors = props.drawPickingColors;
          this._needsRedraw = 'drawPickingColors changed';
        }
      }

      var pixelRatio = this.pixelRatio,
          layerFilter = this.layerFilter;
      this.drawLayersPass.setProps({
        pixelRatio: pixelRatio,
        layerFilter: layerFilter
      });
      this.pickLayersPass.setProps({
        pixelRatio: pixelRatio,
        layerFilter: layerFilter
      });
    }
  }, {
    key: "renderLayers",
    value: function renderLayers(_ref) {
      var _this = this;

      var layers = _ref.layers,
          viewports = _ref.viewports,
          activateViewport = _ref.activateViewport,
          views = _ref.views,
          _ref$redrawReason = _ref.redrawReason,
          redrawReason = _ref$redrawReason === void 0 ? 'unknown reason' : _ref$redrawReason,
          _ref$clearCanvas = _ref.clearCanvas,
          clearCanvas = _ref$clearCanvas === void 0 ? true : _ref$clearCanvas,
          _ref$effects = _ref.effects,
          effects = _ref$effects === void 0 ? [] : _ref$effects,
          pass = _ref.pass,
          stats = _ref.stats;
      var layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      var effectProps = this.prepareEffects({
        layers: layers,
        viewports: viewports,
        onViewportActive: activateViewport,
        views: views,
        effects: effects,
        pixelRatio: this.pixelRatio
      });
      var outputBuffer = this.lastPostProcessEffect ? this.screenBuffer : _core.Framebuffer.getDefaultFramebuffer(this.gl);
      var renderStats = layerPass.render({
        layers: layers,
        viewports: viewports,
        views: views,
        onViewportActive: activateViewport,
        redrawReason: redrawReason,
        clearCanvas: clearCanvas,
        effects: effects,
        effectProps: effectProps,
        outputBuffer: outputBuffer
      });
      this.postRender(effects);
      this.renderCount++;

      if (_log.default.priority >= LOG_PRIORITY_DRAW) {
        renderStats.forEach(function (status) {
          _this.logRenderStats({
            status: status,
            pass: pass,
            redrawReason: redrawReason,
            stats: stats,
            renderStats: renderStats
          });
        });
      }
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      return redraw;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      if (this.screenBuffer) {
        this.screenBuffer.delete();
        this.screenBuffer = null;
      }

      if (this.offscreenBuffer) {
        this.offscreenBuffer.delete();
        this.offscreenBuffer = null;
      }
    }
  }, {
    key: "prepareEffects",
    value: function prepareEffects(params) {
      var effects = params.effects;
      var effectProps = {};
      this.lastPostProcessEffect = null;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          Object.assign(effectProps, effect.prepare(this.gl, params));

          if (effect instanceof _postProcessEffect.default) {
            this.lastPostProcessEffect = effect;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (this.lastPostProcessEffect) {
        this.prepareRenderBuffers();
      }

      return effectProps;
    }
  }, {
    key: "prepareRenderBuffers",
    value: function prepareRenderBuffers() {
      if (!this.screenBuffer) {
        this.screenBuffer = new _core.Framebuffer(this.gl);
      }

      this.screenBuffer.resize();

      if (!this.offscreenBuffer) {
        this.offscreenBuffer = new _core.Framebuffer(this.gl);
      }

      this.offscreenBuffer.resize();
    }
  }, {
    key: "postRender",
    value: function postRender(effects) {
      var params = {
        inputBuffer: this.screenBuffer,
        outputBuffer: this.offscreenBuffer,
        target: null
      };
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var effect = _step2.value;

          if (effect instanceof _postProcessEffect.default) {
            if (effect === this.lastPostProcessEffect) {
              Object.assign(params, {
                target: _core.Framebuffer.getDefaultFramebuffer(this.gl)
              });
              params = effect.render(params);
              break;
            }

            params = effect.render(params);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "logRenderStats",
    value: function logRenderStats(_ref2) {
      var renderStats = _ref2.renderStats,
          pass = _ref2.pass,
          redrawReason = _ref2.redrawReason,
          stats = _ref2.stats;
      var totalCount = renderStats.totalCount,
          visibleCount = renderStats.visibleCount,
          compositeCount = renderStats.compositeCount,
          pickableCount = renderStats.pickableCount;
      var primitiveCount = totalCount - compositeCount;
      var hiddenCount = primitiveCount - visibleCount;
      var message = '';
      message += "RENDER #".concat(this.renderCount, " ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, " ");

      if (_log.default.priority > LOG_PRIORITY_DRAW) {
        message += "(".concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)");
      }

      _log.default.log(LOG_PRIORITY_DRAW, message)();

      if (stats) {
        stats.get('Redraw Layers').add(visibleCount);
      }
    }
  }]);
  return DeckRenderer;
}();

exports.default = DeckRenderer;

},{"../effects/post-process-effect":57,"../passes/draw-layers-pass":87,"../passes/pick-layers-pass":90,"../utils/get-pixel-ratio":113,"../utils/log":117,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],68:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _layerManager = _interopRequireDefault(require("./layer-manager"));

var _viewManager = _interopRequireDefault(require("./view-manager"));

var _mapView = _interopRequireDefault(require("../views/map-view"));

var _effectManager = _interopRequireDefault(require("./effect-manager"));

var _effect = _interopRequireDefault(require("./effect"));

var _deckRenderer = _interopRequireDefault(require("./deck-renderer"));

var _deckPicker = _interopRequireDefault(require("./deck-picker"));

var _log = _interopRequireDefault(require("../utils/log"));

var _init = _interopRequireDefault(require("./init"));

var _core = require("@luma.gl/core");

var _probe = require("probe.gl");

var _mjolnir = require("mjolnir.js");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _constants = require("./constants");

function noop() {}

var getCursor = function getCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? 'grabbing' : 'grab';
};

function getPropTypes(PropTypes) {
  return {
    id: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    layerFilter: PropTypes.func,
    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    viewState: PropTypes.object,
    effects: PropTypes.arrayOf(PropTypes.instanceOf(_effect.default)),
    controller: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
    gl: PropTypes.object,
    glOptions: PropTypes.object,
    parameters: PropTypes.object,
    pickingRadius: PropTypes.number,
    useDevicePixels: PropTypes.bool,
    touchAction: PropTypes.string,
    onWebGLInitialized: PropTypes.func,
    onResize: PropTypes.func,
    onViewStateChange: PropTypes.func,
    onBeforeRender: PropTypes.func,
    onAfterRender: PropTypes.func,
    onLoad: PropTypes.func,
    debug: PropTypes.bool,
    drawPickingColors: PropTypes.bool,
    _animate: PropTypes.bool
  };
}

var defaultProps = {
  id: 'deckgl-overlay',
  width: '100%',
  height: '100%',
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  gl: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: true,
  touchAction: 'none',
  _animate: false,
  onWebGLInitialized: noop,
  onResize: noop,
  onViewStateChange: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLoad: noop,
  _onMetrics: null,
  getCursor: getCursor,
  debug: false,
  drawPickingColors: false
};

var Deck = function () {
  function Deck(props) {
    (0, _classCallCheck2.default)(this, Deck);
    props = Object.assign({}, defaultProps, props);
    this.width = 0;
    this.height = 0;
    this.viewManager = null;
    this.layerManager = null;
    this.effectManager = null;
    this.deckRenderer = null;
    this.deckPicker = null;
    this._needsRedraw = true;
    this._pickRequest = {};
    this._lastPointerDownInfo = null;
    this.viewState = props.initialViewState || null;
    this.interactiveState = {
      isDragging: false
    };
    this._onEvent = this._onEvent.bind(this);
    this._onPointerDown = this._onPointerDown.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._pickAndCallback = this._pickAndCallback.bind(this);
    this._onRendererInitialized = this._onRendererInitialized.bind(this);
    this._onRenderFrame = this._onRenderFrame.bind(this);
    this._onViewStateChange = this._onViewStateChange.bind(this);
    this._onInteractiveStateChange = this._onInteractiveStateChange.bind(this);

    if (isIE11()) {
      _log.default.warn('IE 11 support will be deprecated in v8.0')();
    }

    if (!props.gl) {
      if (typeof document !== 'undefined') {
        this.canvas = this._createCanvas(props);
      }
    }

    this.animationLoop = this._createAnimationLoop(props);
    this.stats = new _probe.Stats({
      id: 'deck.gl'
    });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this.setProps(props);
    this.animationLoop.start();
  }

  (0, _createClass2.default)(Deck, [{
    key: "finalize",
    value: function finalize() {
      this.animationLoop.stop();
      this.animationLoop = null;
      this._lastPointerDownInfo = null;

      if (this.layerManager) {
        this.layerManager.finalize();
        this.layerManager = null;
      }

      if (this.viewManager) {
        this.viewManager.finalize();
        this.viewManager = null;
      }

      if (this.effectManager) {
        this.effectManager.finalize();
        this.effectManager = null;
      }

      if (this.deckRenderer) {
        this.deckRenderer.finalize();
        this.deckRenderer = null;
      }

      if (this.eventManager) {
        this.eventManager.destroy();
      }

      if (!this.props.canvas && !this.props.gl && this.canvas) {
        this.canvas.parentElement.removeChild(this.canvas);
        this.canvas = null;
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.stats.get('setProps Time').timeStart();

      if ('onLayerHover' in props) {
        _log.default.removed('onLayerHover', 'onHover')();
      }

      if ('onLayerClick' in props) {
        _log.default.removed('onLayerClick', 'onClick')();
      }

      props = Object.assign({}, this.props, props);
      this.props = props;

      this._setCanvasSize(props);

      var newProps = Object.assign({}, props, {
        views: this._getViews(this.props),
        width: this.width,
        height: this.height
      });

      var viewState = this._getViewState(props);

      if (viewState) {
        newProps.viewState = viewState;
      }

      if (this.viewManager) {
        this.viewManager.setProps(newProps);
      }

      if (this.layerManager) {
        this.layerManager.setProps(newProps);
      }

      if (this.effectManager) {
        this.effectManager.setProps(newProps);
      }

      if (this.animationLoop) {
        this.animationLoop.setProps(newProps);
      }

      if (this.deckRenderer) {
        this.deckRenderer.setProps(newProps);
      }

      if (this.deckPicker) {
        this.deckPicker.setProps(newProps);
      }

      this.stats.get('setProps Time').timeEnd();
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };

      if (this.props._animate) {
        return 'Deck._animate';
      }

      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      var viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
      var layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
      var effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
      var deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
      redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
      return redraw;
    }
  }, {
    key: "redraw",
    value: function redraw(force) {
      if (!this.layerManager) {
        return;
      }

      var redrawReason = force || this.needsRedraw({
        clearRedrawFlags: true
      });

      if (!redrawReason) {
        return;
      }

      this.stats.get('Redraw Count').incrementCount();

      if (this.props._customRender) {
        this.props._customRender(redrawReason);
      } else {
        this._drawLayers(redrawReason);
      }
    }
  }, {
    key: "getViews",
    value: function getViews() {
      return this.viewManager.views;
    }
  }, {
    key: "getViewports",
    value: function getViewports(rect) {
      return this.viewManager.getViewports(rect);
    }
  }, {
    key: "pickObject",
    value: function pickObject(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
      this.stats.get('Pick Count').incrementCount();
      this.stats.get('pickObject Time').timeStart();
      var layers = this.layerManager.getLayers({
        layerIds: layerIds
      });
      var activateViewport = this.layerManager.activateViewport;
      var selectedInfos = this.deckPicker.pickObject({
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        viewports: this.getViewports({
          x: x,
          y: y
        }),
        activateViewport: activateViewport,
        mode: 'query',
        depth: 1
      }).result;
      this.stats.get('pickObject Time').timeEnd();
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$radius = _ref3.radius,
          radius = _ref3$radius === void 0 ? 0 : _ref3$radius,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds,
          _ref3$depth = _ref3.depth,
          depth = _ref3$depth === void 0 ? 10 : _ref3$depth;
      this.stats.get('Pick Count').incrementCount();
      this.stats.get('pickMultipleObjects Time').timeStart();
      var layers = this.layerManager.getLayers({
        layerIds: layerIds
      });
      var activateViewport = this.layerManager.activateViewport;
      var selectedInfos = this.deckPicker.pickObject({
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        viewports: this.getViewports({
          x: x,
          y: y
        }),
        activateViewport: activateViewport,
        mode: 'query',
        depth: depth
      }).result;
      this.stats.get('pickMultipleObjects Time').timeEnd();
      return selectedInfos;
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          _ref4$width = _ref4.width,
          width = _ref4$width === void 0 ? 1 : _ref4$width,
          _ref4$height = _ref4.height,
          height = _ref4$height === void 0 ? 1 : _ref4$height,
          _ref4$layerIds = _ref4.layerIds,
          layerIds = _ref4$layerIds === void 0 ? null : _ref4$layerIds;
      this.stats.get('Pick Count').incrementCount();
      this.stats.get('pickObjects Time').timeStart();
      var layers = this.layerManager.getLayers({
        layerIds: layerIds
      });
      var activateViewport = this.layerManager.activateViewport;
      var infos = this.deckPicker.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        viewports: this.getViewports({
          x: x,
          y: y,
          width: width,
          height: height
        }),
        activateViewport: activateViewport
      });
      this.stats.get('pickObjects Time').timeEnd();
      return infos;
    }
  }, {
    key: "_createCanvas",
    value: function _createCanvas(props) {
      var canvas = props.canvas;

      if (typeof canvas === 'string') {
        canvas = document.getElementById(canvas);
        (0, _assert.default)(canvas);
      }

      if (!canvas) {
        canvas = document.createElement('canvas');
        var parent = props.parent || document.body;
        parent.appendChild(canvas);
      }

      var id = props.id,
          style = props.style;
      canvas.id = id;
      Object.assign(canvas.style, style);
      return canvas;
    }
  }, {
    key: "_setCanvasSize",
    value: function _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }

      var width = props.width,
          height = props.height;

      if (width || width === 0) {
        width = Number.isFinite(width) ? "".concat(width, "px") : width;
        this.canvas.style.width = width;
      }

      if (height || height === 0) {
        height = Number.isFinite(height) ? "".concat(height, "px") : height;
        this.canvas.style.position = 'absolute';
        this.canvas.style.height = height;
      }
    }
  }, {
    key: "_updateCanvasSize",
    value: function _updateCanvasSize() {
      if (this._checkForCanvasSizeChange()) {
        var width = this.width,
            height = this.height;
        this.viewManager.setProps({
          width: width,
          height: height
        });
        this.props.onResize({
          width: this.width,
          height: this.height
        });
      }
    }
  }, {
    key: "_checkForCanvasSizeChange",
    value: function _checkForCanvasSizeChange() {
      var canvas = this.canvas;

      if (!canvas) {
        return false;
      }

      var newWidth = canvas.clientWidth || canvas.width;
      var newHeight = canvas.clientHeight || canvas.height;

      if (newWidth !== this.width || newHeight !== this.height) {
        this.width = newWidth;
        this.height = newHeight;
        return true;
      }

      return false;
    }
  }, {
    key: "_createAnimationLoop",
    value: function _createAnimationLoop(props) {
      var _this = this;

      var width = props.width,
          height = props.height,
          gl = props.gl,
          glOptions = props.glOptions,
          debug = props.debug,
          useDevicePixels = props.useDevicePixels,
          autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      return new _core.AnimationLoop({
        width: width,
        height: height,
        useDevicePixels: useDevicePixels,
        autoResizeDrawingBuffer: autoResizeDrawingBuffer,
        gl: gl,
        onCreateContext: function onCreateContext(opts) {
          return (0, _core.createGLContext)(Object.assign({}, glOptions, opts, {
            canvas: _this.canvas,
            debug: debug
          }));
        },
        onInitialize: this._onRendererInitialized,
        onRender: this._onRenderFrame,
        onBeforeRender: props.onBeforeRender,
        onAfterRender: props.onAfterRender
      });
    }
  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      return props.viewState || this.viewState;
    }
  }, {
    key: "_getViews",
    value: function _getViews(props) {
      var views = props.views || [new _mapView.default({
        id: 'default-view'
      })];
      views = Array.isArray(views) ? views : [views];

      if (views.length && props.controller) {
        views[0].props.controller = props.controller;
      }

      return views;
    }
  }, {
    key: "_onPointerMove",
    value: function _onPointerMove(event) {
      var _pickRequest = this._pickRequest;

      if (event.type === 'pointerleave') {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        var pos = event.offsetCenter;

        if (!pos) {
          return;
        }

        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }

      if (this.layerManager) {
        this.layerManager.context.mousePosition = {
          x: _pickRequest.x,
          y: _pickRequest.y
        };
      }

      _pickRequest.callback = this.props.onHover;
      _pickRequest.event = event;
      _pickRequest.mode = 'hover';
    }
  }, {
    key: "_pickAndCallback",
    value: function _pickAndCallback() {
      var _pickRequest = this._pickRequest;

      if (_pickRequest.mode) {
        var _this$deckPicker$pick = this.deckPicker.pickObject(Object.assign({
          layers: this.layerManager.getLayers(),
          viewports: this.getViewports(_pickRequest),
          activateViewport: this.layerManager.activateViewport,
          depth: 1
        }, _pickRequest)),
            result = _this$deckPicker$pick.result,
            emptyInfo = _this$deckPicker$pick.emptyInfo;

        if (_pickRequest.callback) {
          var pickedInfo = result.find(function (info) {
            return info.index >= 0;
          }) || emptyInfo;

          _pickRequest.callback(pickedInfo, _pickRequest.event);
        }

        _pickRequest.mode = null;
      }
    }
  }, {
    key: "_updateCursor",
    value: function _updateCursor() {
      if (this.canvas) {
        this.canvas.style.cursor = this.props.getCursor(this.interactiveState);
      }
    }
  }, {
    key: "_updateAnimationProps",
    value: function _updateAnimationProps(animationProps) {
      this.layerManager.context.animationProps = animationProps;
    }
  }, {
    key: "_setGLContext",
    value: function _setGLContext(gl) {
      if (this.layerManager) {
        return;
      }

      if (!this.canvas) {
        this.canvas = gl.canvas;
        (0, _core.trackContextState)(gl, {
          enable: true,
          copyState: true
        });
      }

      (0, _core.setParameters)(gl, {
        blend: true,
        blendFunc: [770, 771, 1, 771],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: 515
      });
      this.props.onWebGLInitialized(gl);
      this.eventManager = new _mjolnir.EventManager(gl.canvas, {
        touchAction: this.props.touchAction,
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerMove
        }
      });

      for (var eventType in _constants.EVENTS) {
        this.eventManager.on(eventType, this._onEvent);
      }

      this.viewManager = new _viewManager.default({
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange,
        onInteractiveStateChange: this._onInteractiveStateChange,
        views: this._getViews(this.props),
        viewState: this._getViewState(this.props),
        width: this.width,
        height: this.height
      });
      (0, _assert.default)(this.viewManager);
      var viewport = this.viewManager.getViewports()[0];
      this.layerManager = new _layerManager.default(gl, {
        deck: this,
        stats: this.stats,
        viewport: viewport
      });
      this.effectManager = new _effectManager.default();
      this.deckRenderer = new _deckRenderer.default(gl);
      this.deckPicker = new _deckPicker.default(gl);
      this.setProps(this.props);

      this._updateCanvasSize();

      this.props.onLoad();
    }
  }, {
    key: "_drawLayers",
    value: function _drawLayers(redrawReason, renderOptions) {
      var gl = this.layerManager.context.gl;
      (0, _core.setParameters)(gl, this.props.parameters);
      this.props.onBeforeRender({
        gl: gl
      });
      var layers = this.layerManager.getLayers();
      var activateViewport = this.layerManager.activateViewport;
      this.deckRenderer.renderLayers(Object.assign({
        layers: layers,
        viewports: this.viewManager.getViewports(),
        activateViewport: activateViewport,
        views: this.viewManager.getViews(),
        pass: 'screen',
        redrawReason: redrawReason,
        effects: this.effectManager.getEffects()
      }, renderOptions));
      this.props.onAfterRender({
        gl: gl
      });
    }
  }, {
    key: "_onRendererInitialized",
    value: function _onRendererInitialized(_ref5) {
      var gl = _ref5.gl;

      this._setGLContext(gl);
    }
  }, {
    key: "_onRenderFrame",
    value: function _onRenderFrame(animationProps) {
      this._getFrameStats();

      if (this._metricsCounter++ % 60 === 0) {
        this._getMetrics();

        this.stats.reset();

        _log.default.table(3, this.metrics)();

        if (this.props._onMetrics) {
          this.props._onMetrics(this.metrics);
        }
      }

      this._updateCanvasSize();

      this._updateCursor();

      this.layerManager.updateLayers(animationProps);

      this._updateAnimationProps(animationProps);

      this._pickAndCallback();

      this.redraw(false);

      if (this.viewManager) {
        this.viewManager.updateViewStates(animationProps);
      }
    }
  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(params) {
      var viewState = this.props.onViewStateChange(params) || params.viewState;

      if (this.viewState) {
        this.viewState[params.viewId] = viewState;
        this.viewManager.setProps({
          viewState: viewState
        });
      }
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref6) {
      var _ref6$isDragging = _ref6.isDragging,
          isDragging = _ref6$isDragging === void 0 ? false : _ref6$isDragging;

      if (isDragging !== this.interactiveState.isDragging) {
        this.interactiveState.isDragging = isDragging;
      }
    }
  }, {
    key: "_onEvent",
    value: function _onEvent(event) {
      var eventOptions = _constants.EVENTS[event.type];
      var pos = event.offsetCenter;

      if (!eventOptions || !pos) {
        return;
      }

      var layers = this.layerManager.getLayers();
      var info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers: layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      var layer = info.layer;
      var layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      var rootHandler = this.props[eventOptions.handler];
      var handled = false;

      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }

      if (!handled && rootHandler) {
        rootHandler(info, event);
      }
    }
  }, {
    key: "_onPointerDown",
    value: function _onPointerDown(event) {
      var pos = event.offsetCenter;
      this._lastPointerDownInfo = this.pickObject({
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
    }
  }, {
    key: "_getFrameStats",
    value: function _getFrameStats() {
      var stats = this.stats;
      stats.get('frameRate').timeEnd();
      stats.get('frameRate').timeStart();
      var animationLoopStats = this.animationLoop.stats;
      stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);
      stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);
    }
  }, {
    key: "_getMetrics",
    value: function _getMetrics() {
      var metrics = this.metrics,
          stats = this.stats;
      metrics.fps = stats.get('frameRate').getHz();
      metrics.setPropsTime = stats.get('setProps Time').time;
      metrics.updateAttributesTime = stats.get('Update Attributes').time;
      metrics.framesRedrawn = stats.get('Redraw Count').count;
      metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;
      metrics.pickCount = stats.get('Pick Count').count;
      metrics.gpuTime = stats.get('GPU Time').time;
      metrics.cpuTime = stats.get('CPU Time').time;
      metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();
      metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();

      var memoryStats = _core.lumaStats.get('Memory Usage');

      metrics.bufferMemory = memoryStats.get('Buffer Memory').count;
      metrics.textureMemory = memoryStats.get('Texture Memory').count;
      metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;
      metrics.gpuMemory = memoryStats.get('GPU Memory').count;
    }
  }]);
  return Deck;
}();

exports.default = Deck;

function isIE11() {
  if ((typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) === undefined) {
    return false;
  }

  var navigator = window.navigator || {};
  var userAgent = navigator.userAgent || '';
  return userAgent.indexOf('Trident/') !== -1;
}

Deck.getPropTypes = getPropTypes;
Deck.defaultProps = defaultProps;
Deck.VERSION = _init.default.VERSION;

},{"../utils/assert":109,"../utils/log":117,"../views/map-view":128,"./constants":65,"./deck-picker":66,"./deck-renderer":67,"./effect":70,"./effect-manager":69,"./init":72,"./layer-manager":74,"./view-manager":80,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"@luma.gl/core":253,"mjolnir.js":430,"probe.gl":444}],69:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _deepEqual = require("../utils/deep-equal");

var _lightingEffect = _interopRequireDefault(require("../effects/lighting/lighting-effect"));

var DEFAULT_LIGHTING_EFFECT = new _lightingEffect.default();

var EffectManager = function () {
  function EffectManager() {
    (0, _classCallCheck2.default)(this, EffectManager);
    this.effects = [];
    this._internalEffects = [];
    this._needsRedraw = 'Initial render';
    this.setEffects();
  }

  (0, _createClass2.default)(EffectManager, [{
    key: "setProps",
    value: function setProps(props) {
      if ('effects' in props) {
        if (props.effects.length !== this.effects.length || !(0, _deepEqual.deepEqual)(props.effects, this.effects)) {
          this.setEffects(props.effects);
          this._needsRedraw = 'effects changed';
        }
      }
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      return redraw;
    }
  }, {
    key: "getEffects",
    value: function getEffects() {
      return this._internalEffects;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.cleanup();
    }
  }, {
    key: "setEffects",
    value: function setEffects() {
      var effects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.cleanup();
      this.effects = effects;

      this._createInternalEffects();
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          effect.cleanup();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._internalEffects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _effect = _step2.value;

          _effect.cleanup();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.effects.length = 0;
      this._internalEffects.length = 0;
    }
  }, {
    key: "_createInternalEffects",
    value: function _createInternalEffects() {
      this._internalEffects = this.effects.slice();

      if (!this.effects.some(function (effect) {
        return effect instanceof _lightingEffect.default;
      })) {
        this._internalEffects.push(DEFAULT_LIGHTING_EFFECT);
      }
    }
  }]);
  return EffectManager;
}();

exports.default = EffectManager;

},{"../effects/lighting/lighting-effect":53,"../utils/deep-equal":111,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],70:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Effect = function () {
  function Effect() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Effect);
    var _props$id = props.id,
        id = _props$id === void 0 ? 'effect' : _props$id;
    this.id = id;
    this.props = {};
    Object.assign(this.props, props);
  }

  (0, _createClass2.default)(Effect, [{
    key: "prepare",
    value: function prepare() {}
  }, {
    key: "getParameters",
    value: function getParameters() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
  }]);
  return Effect;
}();

exports.default = Effect;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],71:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function get() {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function get() {
    return _layer.default;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function get() {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function get() {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function get() {
    return _layerManager.default;
  }
});

var _constants = require("./constants");

var _layer = _interopRequireDefault(require("./layer"));

var _compositeLayer = _interopRequireDefault(require("./composite-layer"));

var _attributeManager = _interopRequireDefault(require("./attribute-manager"));

var _layerManager = _interopRequireDefault(require("./layer-manager"));

},{"./attribute-manager":59,"./composite-layer":64,"./constants":65,"./layer":76,"./layer-manager":74,"@babel/runtime/helpers/interopRequireDefault":25}],72:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@loaders.gl/core");

var _images = require("@loaders.gl/images");

var _globals = require("../utils/globals");

var _log = _interopRequireDefault(require("../utils/log"));

var _jsonLoader = _interopRequireDefault(require("../utils/json-loader"));

var _shaderlib = require("../shaderlib");

var version = typeof "7.2.1" !== 'undefined' ? "7.2.1" : _globals.global.DECK_VERSION || 'untranspiled source';
var STARTUP_MESSAGE = 'set deck.log.priority=1 (or higher) to trace attribute updates';

if (_globals.global.deck && _globals.global.deck.VERSION !== version) {
  throw new Error("deck.gl - multiple versions detected: ".concat(_globals.global.deck.VERSION, " vs ").concat(version));
}

if (!_globals.global.deck) {
  _log.default.log(0, "deck.gl ".concat(version, " - ").concat(STARTUP_MESSAGE))();

  _globals.global.deck = _globals.global.deck || {
    VERSION: version,
    version: version,
    log: _log.default
  };
  (0, _core.registerLoaders)([_jsonLoader.default, _images.HTMLImageLoader]);
  (0, _shaderlib.initializeShaderModules)();
}

var _default = _globals.global.deck;
exports.default = _default;

},{"../shaderlib":93,"../utils/globals":114,"../utils/json-loader":116,"../utils/log":117,"@babel/runtime/helpers/interopRequireDefault":25,"@loaders.gl/core":148,"@loaders.gl/images":208}],73:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayerExtension = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _deepEqual = require("../utils/deep-equal");

var LayerExtension = function () {
  function LayerExtension() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, LayerExtension);
    this.opts = opts;
  }

  (0, _createClass2.default)(LayerExtension, [{
    key: "equals",
    value: function equals(extension) {
      if (this === extension) {
        return true;
      }

      return this.constructor === extension.constructor && (0, _deepEqual.deepEqual)(this.opts, extension.opts);
    }
  }, {
    key: "getShaders",
    value: function getShaders(extension) {
      return null;
    }
  }, {
    key: "getSubLayerProps",
    value: function getSubLayerProps(extension) {
      var _extension$constructo = extension.constructor.defaultProps,
          defaultProps = _extension$constructo === void 0 ? {} : _extension$constructo;
      var newProps = {
        updateTriggers: {}
      };

      for (var key in defaultProps) {
        if (key in this.props) {
          var propDef = defaultProps[key];
          var propValue = this.props[key];
          newProps[key] = propValue;

          if (propDef && propDef.type === 'accessor') {
            newProps.updateTriggers[key] = this.props.updateTriggers[key];

            if (typeof propValue === 'function') {
              newProps[key] = this.getSubLayerAccessor(propValue, true);
            }
          }
        }
      }

      return newProps;
    }
  }, {
    key: "initializeState",
    value: function initializeState(context, extension) {}
  }, {
    key: "updateState",
    value: function updateState(params, extension) {}
  }, {
    key: "finalizeState",
    value: function finalizeState(extension) {}
  }]);
  return LayerExtension;
}();

exports.LayerExtension = LayerExtension;

},{"../utils/deep-equal":111,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],74:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _core = require("@luma.gl/core");

var _seer = _interopRequireDefault(require("seer"));

var _layer = _interopRequireDefault(require("./layer"));

var _constants = require("../lifecycle/constants");

var _log = _interopRequireDefault(require("../utils/log"));

var _flatten = require("../utils/flatten");

var _probe = require("probe.gl");

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _seerIntegration = require("./seer-integration");

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;
var INITIAL_CONTEXT = Object.seal({
  layerManager: null,
  deck: null,
  gl: null,
  time: -1,
  useDevicePixels: true,
  stats: null,
  shaderCache: null,
  pickingFBO: null,
  animationProps: null,
  mousePosition: null,
  userData: {}
});

var layerName = function layerName(layer) {
  return layer instanceof _layer.default ? "".concat(layer) : !layer ? 'null' : 'invalid';
};

var LayerManager = function () {
  function LayerManager(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        deck = _ref.deck,
        stats = _ref.stats,
        _ref$viewport = _ref.viewport,
        viewport = _ref$viewport === void 0 ? null : _ref$viewport;

    (0, _classCallCheck2.default)(this, LayerManager);
    this.lastRenderedLayers = [];
    this.layers = [];
    this.context = Object.assign({}, INITIAL_CONTEXT, {
      layerManager: this,
      deck: deck,
      gl: gl,
      shaderCache: gl && new _core._ShaderCache({
        gl: gl,
        _cachePrograms: true
      }),
      stats: stats || new _probe.Stats({
        id: 'deck.gl'
      }),
      viewport: viewport || new _viewport.default({
        id: 'DEFAULT-INITIAL-VIEWPORT'
      })
    });
    this._needsRedraw = 'Initial render';
    this._needsUpdate = false;
    this._debug = false;
    this.activateViewport = this.activateViewport.bind(this);
    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);
    Object.seal(this);
    (0, _seerIntegration.seerInitListener)(this._initSeer);
    (0, _seerIntegration.layerEditListener)(this._editSeer);
  }

  (0, _createClass2.default)(LayerManager, [{
    key: "finalize",
    value: function finalize() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          this._finalizeLayer(layer);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      _seer.default.removeListener(this._initSeer);

      _seer.default.removeListener(this._editSeer);
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      return this._checkIfNeedsRedraw(opts);
    }
  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      return this._needsUpdate;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
    }
  }, {
    key: "getLayers",
    value: function getLayers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;

      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('debug' in props) {
        this._debug = props.debug;
      }

      if ('userData' in props) {
        this.context.userData = props.userData;
      }

      if ('useDevicePixels' in props) {
        this.context.useDevicePixels = props.useDevicePixels;
      }

      if ('layers' in props) {
        this.setLayers(props.layers);
      }
    }
  }, {
    key: "setLayers",
    value: function setLayers(newLayers) {
      if (newLayers === this.lastRenderedLayers) {
        _log.default.log(3, 'Ignoring layer update due to layer array not changed')();

        return this;
      }

      this.lastRenderedLayers = newLayers;
      newLayers = (0, _flatten.flatten)(newLayers, {
        filter: Boolean
      });
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = newLayers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;
          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _this$_updateLayers = this._updateLayers({
        oldLayers: this.layers,
        newLayers: newLayers
      }),
          error = _this$_updateLayers.error,
          generatedLayers = _this$_updateLayers.generatedLayers;

      this.layers = generatedLayers;

      if (error) {
        throw error;
      }

      return this;
    }
  }, {
    key: "updateLayers",
    value: function updateLayers() {
      var animationProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ('time' in animationProps) {
        this.context.time = animationProps.time;
      }

      var reason = this.needsUpdate();

      if (reason) {
        this.setNeedsRedraw("updating layers: ".concat(reason));
        this.setLayers((0, _toConsumableArray2.default)(this.lastRenderedLayers));
      }
    }
  }, {
    key: "_checkIfNeedsRedraw",
    value: function _checkIfNeedsRedraw(opts) {
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var layer = _step3.value;
          var layerNeedsRedraw = layer.getNeedsRedraw(opts);
          redraw = redraw || layerNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return redraw;
    }
  }, {
    key: "activateViewport",
    value: function activateViewport(viewport) {
      var oldViewport = this.context.viewport;
      var viewportChanged = !oldViewport || !viewport.equals(oldViewport);

      if (viewportChanged) {
        _log.default.log(4, 'Viewport changed', viewport)();

        this.context.viewport = viewport;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.layers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var layer = _step4.value;
            layer.setChangeFlags({
              viewportChanged: 'Viewport changed'
            });

            this._updateLayer(layer);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      (0, _assert.default)(this.context.viewport, 'LayerManager: viewport not set');
      return this;
    }
  }, {
    key: "_updateLayers",
    value: function _updateLayers(_ref3) {
      var oldLayers = _ref3.oldLayers,
          newLayers = _ref3.newLayers;
      var oldLayerMap = {};
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var oldLayer = _step5.value;

          if (oldLayerMap[oldLayer.id]) {
            _log.default.warn("Multiple old layers with same id ".concat(layerName(oldLayer)))();
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var generatedLayers = [];

      var error = this._updateSublayersRecursively({
        newLayers: newLayers,
        oldLayerMap: oldLayerMap,
        generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayerMap);

      this._needsUpdate = false;
      var firstError = error || error2;
      return {
        error: firstError,
        generatedLayers: generatedLayers
      };
    }
  }, {
    key: "_updateSublayersRecursively",
    value: function _updateSublayersRecursively(_ref4) {
      var newLayers = _ref4.newLayers,
          oldLayerMap = _ref4.oldLayerMap,
          generatedLayers = _ref4.generatedLayers;
      var error = null;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = newLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var newLayer = _step6.value;
          newLayer.context = this.context;
          var oldLayer = oldLayerMap[newLayer.id];

          if (oldLayer === null) {
            _log.default.warn("Multiple new layers with same id ".concat(layerName(newLayer)))();
          }

          oldLayerMap[newLayer.id] = null;
          var sublayers = null;

          try {
            if (this._debug && oldLayer !== newLayer) {
              newLayer.validateProps();
            }

            if (!oldLayer) {
              var err = this._initializeLayer(newLayer);

              error = error || err;
              (0, _seerIntegration.initLayerInSeer)(newLayer);
            } else {
              this._transferLayerState(oldLayer, newLayer);

              var _err = this._updateLayer(newLayer);

              error = error || _err;
              (0, _seerIntegration.updateLayerInSeer)(newLayer);
            }

            generatedLayers.push(newLayer);
            sublayers = newLayer.isComposite && newLayer.getSubLayers();
          } catch (err) {
            _log.default.warn("error during matching of ".concat(layerName(newLayer)), err)();

            error = error || err;
          }

          if (sublayers) {
            var _err2 = this._updateSublayersRecursively({
              newLayers: sublayers,
              oldLayerMap: oldLayerMap,
              generatedLayers: generatedLayers
            });

            error = error || _err2;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return error;
    }
  }, {
    key: "_finalizeOldLayers",
    value: function _finalizeOldLayers(oldLayerMap) {
      var error = null;

      for (var layerId in oldLayerMap) {
        var layer = oldLayerMap[layerId];

        if (layer) {
          error = error || this._finalizeLayer(layer);
        }
      }

      return error;
    }
  }, {
    key: "_initializeLayer",
    value: function _initializeLayer(layer) {
      _log.default.log(LOG_PRIORITY_LIFECYCLE, "initializing ".concat(layerName(layer)))();

      var error = null;

      try {
        layer._initialize();

        layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
      } catch (err) {
        _log.default.warn("error while initializing ".concat(layerName(layer), "\n"), err)();

        error = error || err;
      }

      layer.internalState.layer = layer;
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = layer.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var model = _step7.value;
          model.userData.layer = layer;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      return error;
    }
  }, {
    key: "_transferLayerState",
    value: function _transferLayerState(oldLayer, newLayer) {
      newLayer._transferState(oldLayer);

      newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;

      if (newLayer !== oldLayer) {
        _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "matched ".concat(layerName(newLayer)), oldLayer, '->', newLayer)();

        oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
      } else {
        _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "Matching layer is unchanged ".concat(newLayer.id))();
      }
    }
  }, {
    key: "_updateLayer",
    value: function _updateLayer(layer) {
      _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "updating ".concat(layer, " because: ").concat(layer.printChangeFlags()))();

      var error = null;

      try {
        layer._update();
      } catch (err) {
        _log.default.warn("error during update of ".concat(layerName(layer)), err)();

        error = err;
      }

      return error;
    }
  }, {
    key: "_finalizeLayer",
    value: function _finalizeLayer(layer) {
      (0, _assert.default)(layer.lifecycle !== _constants.LIFECYCLE.AWAITING_FINALIZATION);
      layer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
      var error = null;
      this.setNeedsRedraw("finalized ".concat(layerName(layer)));

      try {
        layer._finalize();
      } catch (err) {
        _log.default.warn("error during finalization of ".concat(layerName(layer)), err)();

        error = err;
      }

      layer.lifecycle = _constants.LIFECYCLE.FINALIZED;

      _log.default.log(LOG_PRIORITY_LIFECYCLE, "finalizing ".concat(layerName(layer)))();

      return error;
    }
  }, {
    key: "_initSeer",
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        (0, _seerIntegration.initLayerInSeer)(layer);
        (0, _seerIntegration.updateLayerInSeer)(layer);
      });
    }
  }, {
    key: "_editSeer",
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      (0, _seerIntegration.setPropOverrides)(payload.itemKey, payload.valuePath.slice(1), payload.value);
      this.updateLayers();
    }
  }]);
  return LayerManager;
}();

exports.default = LayerManager;

},{"../lifecycle/constants":83,"../utils/assert":109,"../utils/flatten":112,"../utils/log":117,"../viewports/viewport":125,"./layer":76,"./seer-integration":79,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/toConsumableArray":39,"@luma.gl/core":253,"probe.gl":444,"seer":457}],75:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _componentState = _interopRequireDefault(require("../lifecycle/component-state"));

var LayerState = function (_ComponentState) {
  (0, _inherits2.default)(LayerState, _ComponentState);

  function LayerState(_ref) {
    var _this;

    var attributeManager = _ref.attributeManager,
        layer = _ref.layer;
    (0, _classCallCheck2.default)(this, LayerState);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LayerState).call(this, layer));
    _this.attributeManager = attributeManager;
    _this.model = null;
    _this.needsRedraw = true;
    _this.subLayers = null;
    return _this;
  }

  (0, _createClass2.default)(LayerState, [{
    key: "layer",
    get: function get() {
      return this.component;
    },
    set: function set(layer) {
      this.component = layer;
    }
  }]);
  return LayerState;
}(_componentState.default);

exports.default = LayerState;

},{"../lifecycle/component-state":81,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],76:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _constants = require("./constants");

var _attributeManager = _interopRequireDefault(require("./attribute-manager"));

var _seerIntegration = require("./seer-integration");

var _props = require("../lifecycle/props");

var _count = require("../utils/count");

var _log = _interopRequireDefault(require("../utils/log"));

var _core = require("@luma.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _shader = require("../utils/shader");

var _projectFunctions = require("../shaderlib/project/project-functions");

var _component = _interopRequireDefault(require("../lifecycle/component"));

var _layerState = _interopRequireDefault(require("./layer-state"));

var _viewportMercatorProject = require("viewport-mercator-project");

var _core2 = require("@loaders.gl/core");

var LOG_PRIORITY_UPDATE = 1;
var EMPTY_ARRAY = Object.freeze([]);
var pickingColorCache = new Uint8ClampedArray(0);
var defaultProps = {
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: null,
  _dataDiff: {
    type: 'function',
    value: function value(data) {
      return data && data.__diff;
    },
    compare: false,
    optional: true
  },
  dataTransform: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDataLoad: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  fetch: {
    type: 'function',
    value: function value(url, _ref) {
      var layer = _ref.layer;
      return (0, _core2.load)(url, layer.getLoadOptions());
    },
    compare: false
  },
  updateTriggers: {},
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0.8
  },
  onHover: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onClick: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragStart: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDrag: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragEnd: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  coordinateSystem: _constants.COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: {
    type: 'array',
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: 'array',
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  positionFormat: 'XYZ',
  colorFormat: 'RGBA',
  parameters: {},
  uniforms: {},
  extensions: [],
  framebuffer: null,
  animation: null,
  getPolygonOffset: {
    type: 'function',
    value: function value(_ref2) {
      var layerIndex = _ref2.layerIndex;
      return [0, -layerIndex * 100];
    },
    compare: false
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: 'color',
    value: [0, 0, 128, 128]
  }
};

var Layer = function (_Component) {
  (0, _inherits2.default)(Layer, _Component);

  function Layer() {
    (0, _classCallCheck2.default)(this, Layer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Layer).apply(this, arguments));
  }

  (0, _createClass2.default)(Layer, [{
    key: "toString",
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return "".concat(className, "({id: '").concat(this.props.id, "'})");
    }
  }, {
    key: "setState",
    value: function setState(updateObject) {
      this.setChangeFlags({
        stateChanged: true
      });
      Object.assign(this.state, updateObject);
      this.setNeedsRedraw();
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.internalState) {
        this.internalState.needsRedraw = redraw;
      }
    }
  }, {
    key: "setLayerNeedsUpdate",
    value: function setLayerNeedsUpdate() {
      this.context.layerManager.setNeedsUpdate(String(this));
    }
  }, {
    key: "getNeedsRedraw",
    value: function getNeedsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      return this._getNeedsRedraw(opts);
    }
  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      return this.shouldUpdateState(this._getUpdateParams());
    }
  }, {
    key: "isPickable",
    value: function isPickable() {
      return this.props.pickable && this.props.visible;
    }
  }, {
    key: "getModels",
    value: function getModels() {
      return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
    }
  }, {
    key: "getSingleModel",
    value: function getSingleModel() {
      return this.state && this.state.model;
    }
  }, {
    key: "getAttributeManager",
    value: function getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
  }, {
    key: "getCurrentLayer",
    value: function getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
  }, {
    key: "getLoadOptions",
    value: function getLoadOptions() {
      return this.props.loadOptions;
    }
  }, {
    key: "getFirstObject",
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }
  }, {
    key: "project",
    value: function project(xyz) {
      var viewport = this.context.viewport;
      var worldPosition = (0, _projectFunctions.getWorldPosition)(xyz, {
        viewport: viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });

      var _worldToPixels = (0, _viewportMercatorProject.worldToPixels)(worldPosition, viewport.pixelProjectionMatrix),
          _worldToPixels2 = (0, _slicedToArray2.default)(_worldToPixels, 3),
          x = _worldToPixels2[0],
          y = _worldToPixels2[1],
          z = _worldToPixels2[2];

      return xyz.length === 2 ? [x, y] : [x, y, z];
    }
  }, {
    key: "unproject",
    value: function unproject(xy) {
      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(xy));
      return viewport.unproject(xy);
    }
  }, {
    key: "projectPosition",
    value: function projectPosition(xyz) {
      (0, _assert.default)(Array.isArray(xyz));
      return (0, _projectFunctions.projectPosition)(xyz, {
        viewport: this.context.viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(lngLat) {
      _log.default.deprecated('layer.projectFlat', 'layer.projectPosition')();

      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(lngLat));
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xy) {
      _log.default.deprecated('layer.unprojectFlat')();

      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(xy));
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: "use64bitPositions",
    value: function use64bitPositions() {
      return this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.IDENTITY;
    }
  }, {
    key: "screenToDevicePixels",
    value: function screenToDevicePixels(screenPixels) {
      _log.default.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion')();

      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }
  }, {
    key: "onHover",
    value: function onHover(info, pickingEvent) {
      if (this.props.onHover) {
        return this.props.onHover(info, pickingEvent);
      }

      return false;
    }
  }, {
    key: "onClick",
    value: function onClick(info, pickingEvent) {
      if (this.props.onClick) {
        return this.props.onClick(info, pickingEvent);
      }

      return false;
    }
  }, {
    key: "nullPickingColor",
    value: function nullPickingColor() {
      return [0, 0, 0];
    }
  }, {
    key: "encodePickingColor",
    value: function encodePickingColor(i) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      (0, _assert.default)(i < 16777215, 'index out of picking color range');
      target[0] = i + 1 & 255;
      target[1] = i + 1 >> 8 & 255;
      target[2] = i + 1 >> 8 >> 8 & 255;
      return target;
    }
  }, {
    key: "decodePickingColor",
    value: function decodePickingColor(color) {
      (0, _assert.default)(color instanceof Uint8Array);

      var _color = (0, _slicedToArray2.default)(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];

      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      throw new Error("Layer ".concat(this, " has not defined initializeState"));
    }
  }, {
    key: "getShaders",
    value: function getShaders(shaders) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.props.extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var extension = _step2.value;
          shaders = (0, _shader.mergeShaders)(shaders, extension.getShaders.call(this, extension));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return shaders;
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;
      return changeFlags.propsOrDataChanged;
    }
  }, {
    key: "updateState",
    value: function updateState(_ref4) {
      var oldProps = _ref4.oldProps,
          props = _ref4.props,
          context = _ref4.context,
          changeFlags = _ref4.changeFlags;
      var attributeManager = this.getAttributeManager();

      if (changeFlags.dataChanged && attributeManager) {
        var dataChanged = changeFlags.dataChanged;

        if (Array.isArray(dataChanged)) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = dataChanged[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var dataRange = _step3.value;
              attributeManager.invalidateAll(dataRange);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        } else {
          attributeManager.invalidateAll();
        }
      }
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var model = _step4.value;
          model.delete();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var attributeManager = this.getAttributeManager();

      if (attributeManager) {
        attributeManager.finalize();
      }
    }
  }, {
    key: "draw",
    value: function draw(opts) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var model = _step5.value;
          model.draw(opts);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var index = info.index;

      if (index >= 0) {
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      return info;
    }
  }, {
    key: "invalidateAttribute",
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attributeManager = this.getAttributeManager();

      if (!attributeManager) {
        return;
      }

      if (name === 'all') {
        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating all attributes: ".concat(diffReason))();

        attributeManager.invalidateAll();
      } else {
        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating attribute ".concat(name, ": ").concat(diffReason))();

        attributeManager.invalidate(name);
      }
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(changedAttributes) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;

          this._setModelAttributes(model, changedAttributes);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  }, {
    key: "_updateAttributes",
    value: function _updateAttributes(props) {
      var attributeManager = this.getAttributeManager();

      if (!attributeManager) {
        return;
      }

      var numInstances = this.getNumInstances(props);
      var bufferLayout = this.getBufferLayout(props);
      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        bufferLayout: bufferLayout,
        props: props,
        transitions: props.transitions,
        buffers: props,
        context: this,
        ignoreUnknownAttributes: true
      });
      var changedAttributes = attributeManager.getChangedAttributes({
        clearChangedFlags: true
      });
      this.updateAttributes(changedAttributes);
    }
  }, {
    key: "updateTransition",
    value: function updateTransition() {
      var attributeManager = this.getAttributeManager();

      if (attributeManager) {
        attributeManager.updateTransition(this.context.time);
      }
    }
  }, {
    key: "calculateInstancePickingColors",
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size;

      if (value[0] === 1) {
        return;
      }

      var cacheSize = pickingColorCache.length / size;

      if (cacheSize < numInstances) {
        var newPickingColorCache = new Uint8ClampedArray(numInstances * size);
        newPickingColorCache.set(pickingColorCache);
        var pickingColor = [];

        for (var i = cacheSize; i < numInstances; i++) {
          this.encodePickingColor(i, pickingColor);
          newPickingColorCache[i * size + 0] = pickingColor[0];
          newPickingColorCache[i * size + 1] = pickingColor[1];
          newPickingColorCache[i * size + 2] = pickingColor[2];
        }

        pickingColorCache = newPickingColorCache;
      }

      value.set(numInstances < cacheSize ? pickingColorCache.subarray(0, numInstances * size) : pickingColorCache);
    }
  }, {
    key: "_setModelAttributes",
    value: function _setModelAttributes(model, changedAttributes) {
      var shaderAttributes = {};
      var excludeAttributes = model.userData.excludeAttributes || {};

      for (var attributeName in changedAttributes) {
        if (!excludeAttributes[attributeName]) {
          Object.assign(shaderAttributes, changedAttributes[attributeName].getShaderAttributes());
        }
      }

      model.setAttributes(shaderAttributes);
    }
  }, {
    key: "_clearInstancePickingColor",
    value: function _clearInstancePickingColor(color) {
      var instancePickingColors = this.getAttributeManager().attributes.instancePickingColors;
      var value = instancePickingColors.value,
          size = instancePickingColors.size;
      var i = this.decodePickingColor(color);
      value[i * size + 0] = 0;
      value[i * size + 1] = 0;
      value[i * size + 2] = 0;
      instancePickingColors.update({
        value: value
      });
    }
  }, {
    key: "_clearPickingColor",
    value: function _clearPickingColor(color) {
      var pickingColors = this.getAttributeManager().attributes.pickingColors;
      var value = pickingColors.value;

      for (var i = 0; i < value.length; i += 3) {
        if (value[i + 0] === color[0] && value[i + 1] === color[1] && value[i + 2] === color[2]) {
          value[i + 0] = 0;
          value[i + 1] = 0;
          value[i + 2] = 0;
        }
      }

      pickingColors.update({
        value: value
      });
    }
  }, {
    key: "clearPickingColor",
    value: function clearPickingColor(color) {
      if (this.getAttributeManager().attributes.pickingColors) {
        this._clearPickingColor(color);
      } else {
        this._clearInstancePickingColor(color);
      }
    }
  }, {
    key: "copyPickingColors",
    value: function copyPickingColors() {
      var _this$getAttributeMan = this.getAttributeManager().attributes,
          pickingColors = _this$getAttributeMan.pickingColors,
          instancePickingColors = _this$getAttributeMan.instancePickingColors;
      var colors = pickingColors || instancePickingColors;
      return new Uint8ClampedArray(colors.value);
    }
  }, {
    key: "restorePickingColors",
    value: function restorePickingColors(value) {
      var _this$getAttributeMan2 = this.getAttributeManager().attributes,
          pickingColors = _this$getAttributeMan2.pickingColors,
          instancePickingColors = _this$getAttributeMan2.instancePickingColors;
      var colors = pickingColors || instancePickingColors;
      colors.update({
        value: value
      });
    }
  }, {
    key: "getNumInstances",
    value: function getNumInstances(props) {
      props = props || this.props;

      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      var data = this.props.data;
      return (0, _count.count)(data);
    }
  }, {
    key: "getBufferLayout",
    value: function getBufferLayout(props) {
      props = props || this.props;

      if (props.bufferLayout !== undefined) {
        return props.bufferLayout;
      }

      if (this.state && this.state.bufferLayout !== undefined) {
        return this.state.bufferLayout;
      }

      return null;
    }
  }, {
    key: "_initialize",
    value: function _initialize() {
      this._initState();

      this.initializeState(this.context);
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.props.extensions[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var extension = _step7.value;
          extension.initializeState.call(this, this.context, extension);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      this.state.attributeManager = this.getAttributeManager();
      this.setChangeFlags({
        dataChanged: true,
        propsChanged: true,
        viewportChanged: true,
        extensionsChanged: true
      });

      this._updateState();

      var model = this.getSingleModel();

      if (model) {
        model.id = this.props.id;
        model.program.id = "".concat(this.props.id, "-program");
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      var stateNeedsUpdate = this.needsUpdate();

      if (stateNeedsUpdate) {
        this._updateState();
      }
    }
  }, {
    key: "_updateState",
    value: function _updateState() {
      var updateParams = this._getUpdateParams();

      if (this.context.gl) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {}
      }

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.props.extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var extension = _step8.value;
          extension.updateState.call(this, updateParams, extension);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      if (this.isComposite) {
        this._renderLayers(updateParams);
      } else {
        this.setNeedsRedraw();

        this._updateAttributes(this.props);

        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }

      this.clearChangeFlags();
      this.internalState.resetOldProps();
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      (0, _assert.default)(this.internalState && this.state);
      this.finalizeState(this.context);
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this.props.extensions[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var extension = _step9.value;
          extension.finalizeState.call(this, extension);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      (0, _seerIntegration.removeLayerInSeer)(this.id);
    }
  }, {
    key: "drawLayer",
    value: function drawLayer(_ref7) {
      var _this = this;

      var _ref7$moduleParameter = _ref7.moduleParameters,
          moduleParameters = _ref7$moduleParameter === void 0 ? null : _ref7$moduleParameter,
          _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === void 0 ? {} : _ref7$uniforms,
          _ref7$parameters = _ref7.parameters,
          parameters = _ref7$parameters === void 0 ? {} : _ref7$parameters;

      if (!uniforms.picking_uActive) {
        this.updateTransition();
      }

      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      }

      var animationProps = this.context.animationProps;

      if (animationProps) {
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = this.getModels()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var model = _step10.value;

            model._setAnimationProps(animationProps);
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
              _iterator10.return();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }
      }

      var getPolygonOffset = this.props.getPolygonOffset;
      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      parameters.polygonOffset = offsets;
      (0, _core.withParameters)(this.context.gl, parameters, function () {
        _this.draw({
          moduleParameters: moduleParameters,
          uniforms: uniforms,
          parameters: parameters,
          context: _this.context
        });
      });
    }
  }, {
    key: "pickLayer",
    value: function pickLayer(opts) {
      return this.getPickingInfo(opts);
    }
  }, {
    key: "getChangeFlags",
    value: function getChangeFlags() {
      return this.internalState.changeFlags;
    }
  }, {
    key: "setChangeFlags",
    value: function setChangeFlags(flags) {
      var _this2 = this;

      this.internalState.changeFlags = this.internalState.changeFlags || {};
      var changeFlags = this.internalState.changeFlags;

      if (flags.dataChanged && !changeFlags.dataChanged) {
        changeFlags.dataChanged = flags.dataChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "dataChanged: ".concat(flags.dataChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'updateTriggersChanged: ' + "".concat(Object.keys(flags.updateTriggersChanged).join(', '), " in ").concat(_this2.id);
        })();
      }

      if (flags.propsChanged && !changeFlags.propsChanged) {
        changeFlags.propsChanged = flags.propsChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "propsChanged: ".concat(flags.propsChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.extensionsChanged && !changeFlags.extensionsChanged) {
        changeFlags.extensionsChanged = flags.extensionsChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "extensionsChanged: ".concat(flags.extensionsChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.viewportChanged && !changeFlags.viewportChanged) {
        changeFlags.viewportChanged = flags.viewportChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 2, function () {
          return "viewportChanged: ".concat(flags.viewportChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.stateChanged && !changeFlags.stateChanged) {
        changeFlags.stateChanged = flags.stateChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "stateChanged: ".concat(flags.stateChanged, " in ").concat(_this2.id);
        })();
      }

      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged || flags.extensionsChanged;
      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged || flags.stateChanged;
    }
  }, {
    key: "clearChangeFlags",
    value: function clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        extensionsChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
  }, {
    key: "printChangeFlags",
    value: function printChangeFlags() {
      var flags = this.internalState.changeFlags;
      return "".concat(flags.dataChanged ? 'data ' : '').concat(flags.propsChanged ? 'props ' : '').concat(flags.updateTriggersChanged ? 'triggers ' : '').concat(flags.viewportChanged ? 'viewport' : '');
    }
  }, {
    key: "diffProps",
    value: function diffProps(newProps, oldProps) {
      var changeFlags = (0, _props.diffProps)(newProps, oldProps);

      if (changeFlags.updateTriggersChanged) {
        for (var key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this._activeUpdateTrigger(key);
          }
        }
      }

      return this.setChangeFlags(changeFlags);
    }
  }, {
    key: "validateProps",
    value: function validateProps() {
      (0, _props.validateProps)(this.props);
    }
  }, {
    key: "setModuleParameters",
    value: function setModuleParameters(moduleParameters) {
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = this.getModels()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var model = _step11.value;
          model.updateModuleSettings(moduleParameters);
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
            _iterator11.return();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }
    }
  }, {
    key: "_getUpdateParams",
    value: function _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    }
  }, {
    key: "_getNeedsRedraw",
    value: function _getNeedsRedraw(opts) {
      if (!this.internalState) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
      var attributeManager = this.getAttributeManager();
      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);
      redraw = redraw || attributeManagerNeedsRedraw;
      return redraw;
    }
  }, {
    key: "_getAttributeManager",
    value: function _getAttributeManager() {
      return new _attributeManager.default(this.context.gl, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  }, {
    key: "_initState",
    value: function _initState() {
      (0, _assert.default)(!this.internalState && !this.state);

      var attributeManager = this._getAttributeManager();

      if (attributeManager) {
        attributeManager.addInstanced({
          instancePickingColors: {
            type: 5121,
            size: 3,
            update: this.calculateInstancePickingColors
          }
        });
      }

      this.internalState = new _layerState.default({
        attributeManager: attributeManager,
        layer: this
      });
      this.state = {};
      this.state.attributeManager = attributeManager;
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
      this.internalState.setAsyncProps(this.props);
    }
  }, {
    key: "_transferState",
    value: function _transferState(oldLayer) {
      var state = oldLayer.state,
          internalState = oldLayer.internalState;
      (0, _assert.default)(state && internalState);

      if (this === oldLayer) {
        return;
      }

      this.internalState = internalState;
      this.internalState.component = this;
      this.state = state;
      state.layer = this;
      this.internalState.setAsyncProps(this.props);
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = this.getModels()[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var model = _step12.value;
          model.userData.layer = this;
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      this.diffProps(this.props, this.internalState.getOldProps());
    }
  }, {
    key: "_onAsyncPropUpdated",
    value: function _onAsyncPropUpdated() {
      this.diffProps(this.props, this.internalState.getOldProps());
      this.setLayerNeedsUpdate();
    }
  }, {
    key: "_activeUpdateTrigger",
    value: function _activeUpdateTrigger(propName) {
      this.invalidateAttribute(propName);
    }
  }, {
    key: "_updateBaseUniforms",
    value: function _updateBaseUniforms() {
      var _this3 = this;

      var uniforms = {
        opacity: typeof this.props.opacity === 'function' ? function (animationProps) {
          return Math.pow(_this3.props.opacity(animationProps), 1 / 2.2);
        } : Math.pow(this.props.opacity, 1 / 2.2)
      };
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = this.getModels()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var model = _step13.value;
          model.setUniforms(uniforms);
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
            _iterator13.return();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(uniformMap) {
      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = this.getModels()[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var model = _step14.value;
          model.setUniforms(uniformMap);
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
            _iterator14.return();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }

      this.setNeedsRedraw();

      _log.default.deprecated('layer.setUniforms', 'model.setUniforms')();
    }
  }, {
    key: "use64bitProjection",
    value: function use64bitProjection() {
      _log.default.removed('use64bitProjection', 'Fp64Extension')();

      return false;
    }
  }]);
  return Layer;
}(_component.default);

exports.default = Layer;
Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;

},{"../lifecycle/component":82,"../lifecycle/props":86,"../shaderlib/project/project-functions":99,"../utils/assert":109,"../utils/count":110,"../utils/log":117,"../utils/shader":122,"./attribute-manager":59,"./constants":65,"./layer-state":75,"./seer-integration":79,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37,"@loaders.gl/core":148,"@luma.gl/core":253,"viewport-mercator-project":461}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processPickInfo = processPickInfo;
exports.getLayerPickingInfo = getLayerPickingInfo;

function processPickInfo(_ref) {
  var pickInfo = _ref.pickInfo,
      lastPickedInfo = _ref.lastPickedInfo,
      mode = _ref.mode,
      layers = _ref.layers,
      viewports = _ref.viewports,
      x = _ref.x,
      y = _ref.y,
      deviceX = _ref.deviceX,
      deviceY = _ref.deviceY,
      pixelRatio = _ref.pixelRatio;
  var pickedColor = pickInfo.pickedColor,
      pickedLayer = pickInfo.pickedLayer,
      pickedObjectIndex = pickInfo.pickedObjectIndex;
  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });

        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }

  var viewport = getViewportFromCoordinates({
    viewports: viewports
  });
  var coordinate = viewport && viewport.unproject([x, y]);
  var baseInfo = {
    color: null,
    layer: null,
    index: -1,
    picked: false,
    x: x,
    y: y,
    pixel: [x, y],
    coordinate: coordinate,
    lngLat: coordinate,
    devicePixel: [deviceX, deviceY],
    pixelRatio: pixelRatio
  };
  var infos = new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({
      layer: layer,
      info: info,
      mode: mode
    });

    if (layer === pickedLayer && mode === 'hover') {
      lastPickedInfo.info = info;
    }

    if (info) {
      infos.set(info.layer.id, info);
    }

    if (mode === 'hover') {
      var pickingSelectedColor = layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;
      layer.setModuleParameters({
        pickingSelectedColor: pickingSelectedColor
      });
      layer.setNeedsRedraw();
    }
  });
  return infos;
}

function getLayerPickingInfo(_ref2) {
  var layer = _ref2.layer,
      info = _ref2.info,
      mode = _ref2.mode;

  while (layer && info) {
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    info = layer.pickLayer({
      info: info,
      mode: mode,
      sourceLayer: sourceLayer
    });
    layer = layer.parent;
  }

  return info;
}

function getViewportFromCoordinates(_ref3) {
  var viewports = _ref3.viewports;
  var viewport = viewports[0];
  return viewport;
}

},{}],78:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClosestObject = getClosestObject;
exports.getUniqueObjects = getUniqueObjects;

var _log = _interopRequireDefault(require("../../utils/log"));

var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedLayer: null,
  pickedObjectIndex: -1
};

function getClosestObject(_ref) {
  var pickedColors = _ref.pickedColors,
      layers = _ref.layers,
      deviceX = _ref.deviceX,
      deviceY = _ref.deviceY,
      deviceRadius = _ref.deviceRadius,
      deviceRect = _ref.deviceRect;

  if (pickedColors) {
    var x = deviceRect.x,
        y = deviceRect.y,
        width = deviceRect.width,
        height = deviceRect.height;
    var minSquareDistanceToCenter = deviceRadius * deviceRadius;
    var closestPixelIndex = -1;
    var i = 0;

    for (var row = 0; row < height; row++) {
      var dy = row + y - deviceY;
      var dy2 = dy * dy;

      if (dy2 > minSquareDistanceToCenter) {
        i += 4 * width;
      } else {
        for (var col = 0; col < width; col++) {
          var pickedLayerIndex = pickedColors[i + 3] - 1;

          if (pickedLayerIndex >= 0) {
            var dx = col + x - deviceX;
            var d2 = dx * dx + dy2;

            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i;
            }
          }

          i += 4;
        }
      }
    }

    if (closestPixelIndex >= 0) {
      var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;

      var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      var pickedLayer = layers[_pickedLayerIndex];

      if (pickedLayer) {
        var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
        return {
          pickedColor: pickedColor,
          pickedLayer: pickedLayer,
          pickedObjectIndex: pickedObjectIndex
        };
      }

      _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
    }
  }

  return NO_PICKED_OBJECT;
}

function getUniqueObjects(_ref2) {
  var pickedColors = _ref2.pickedColors,
      layers = _ref2.layers;
  var uniqueColors = new Map();

  if (pickedColors) {
    for (var i = 0; i < pickedColors.length; i += 4) {
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var pickedColor = pickedColors.slice(i, i + 4);
        var colorKey = pickedColor.join(',');

        if (!uniqueColors.has(colorKey)) {
          var pickedLayer = layers[pickedLayerIndex];

          if (pickedLayer) {
            uniqueColors.set(colorKey, {
              pickedColor: pickedColor,
              pickedLayer: pickedLayer,
              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
            });
          } else {
            _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
          }
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}

},{"../../utils/log":117,"@babel/runtime/helpers/interopRequireDefault":25}],79:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeLayerInSeer = exports.updateLayerInSeer = exports.initLayerInSeer = exports.seerInitListener = exports.layerEditListener = exports.applyPropOverrides = exports.setPropOverrides = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _seer = _interopRequireDefault(require("seer"));

var recursiveSet = function recursiveSet(obj, path, value) {
  if (!obj) {
    return;
  }

  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

var overrides = new Map();

var setPropOverrides = function setPropOverrides(id, valuePath, value) {
  if (!_seer.default.isReady()) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  var props = overrides.get(id);
  props.set(valuePath, value);
};

exports.setPropOverrides = setPropOverrides;

var applyPropOverrides = function applyPropOverrides(props) {
  if (!_seer.default.isReady() || !props.id) {
    return;
  }

  var overs = overrides.get(props.id);

  if (!overs) {
    return;
  }

  overs.forEach(function (value, valuePath) {
    recursiveSet(props, valuePath, value);

    if (valuePath[0] === 'data') {
      props.data = (0, _toConsumableArray2.default)(props.data);
    }
  });
};

exports.applyPropOverrides = applyPropOverrides;

var layerEditListener = function layerEditListener(cb) {
  if (!_seer.default.isReady()) {
    return;
  }

  _seer.default.listenFor('deck.gl', cb);
};

exports.layerEditListener = layerEditListener;

var seerInitListener = function seerInitListener(cb) {
  if (!_seer.default.isReady()) {
    return;
  }

  _seer.default.listenFor('init', cb);
};

exports.seerInitListener = seerInitListener;

var initLayerInSeer = function initLayerInSeer(layer) {
  if (!_seer.default.isReady() || !layer) {
    return;
  }

  var badges = [layer.constructor.layerName];

  _seer.default.listItem('deck.gl', layer.id, {
    badges: badges,
    links: layer.state && layer.state.model ? ["luma.gl:".concat(layer.state.model.id)] : undefined,
    parent: layer.parent ? layer.parent.id : undefined
  });
};

exports.initLayerInSeer = initLayerInSeer;

var updateLayerInSeer = function updateLayerInSeer(layer) {
  if (!_seer.default.isReady() || _seer.default.throttle("deck.gl:".concat(layer.id), 1e3)) {
    return;
  }

  var data = logPayload(layer);

  _seer.default.multiUpdate('deck.gl', layer.id, data);
};

exports.updateLayerInSeer = updateLayerInSeer;

var removeLayerInSeer = function removeLayerInSeer(id) {
  if (!_seer.default.isReady() || !id) {
    return;
  }

  _seer.default.deleteItem('deck.gl', id);
};

exports.removeLayerInSeer = removeLayerInSeer;

function logPayload(layer) {
  var data = [{
    path: 'objects.props',
    data: layer.props
  }];
  var badges = [layer.constructor.layerName];

  if (layer.state) {
    if (layer.getAttributeManager()) {
      var attrs = layer.getAttributeManager().getAttributes();
      data.push({
        path: 'objects.attributes',
        data: attrs
      });
    }

    if (layer.state.model) {
      layer.state.model.setProps({
        timerQueryEnabled: true
      });
      var lastFrameTime = layer.state.model.stats.lastFrameTime;

      if (lastFrameTime) {
        badges.push("".concat((lastFrameTime * 1000).toFixed(0), "\u03BCs"));
      }
    }
  }

  data.push({
    path: 'badges',
    data: badges
  });
  return data;
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/toConsumableArray":39,"seer":457}],80:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _deepEqual = require("../utils/deep-equal");

var _view = _interopRequireDefault(require("../views/view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _log = _interopRequireDefault(require("../utils/log"));

var _flatten = require("../utils/flatten");

var ViewManager = function () {
  function ViewManager() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, ViewManager);
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = 'Initial render';
    this._needsUpdate = true;
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractiveStateChange: props.onInteractiveStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }

  (0, _createClass2.default)(ViewManager, [{
    key: "finalize",
    value: function finalize() {
      for (var key in this.controllers) {
        if (this.controllers[key]) {
          this.controllers[key].finalize();
        }
      }

      this.controllers = {};
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      return redraw;
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
  }, {
    key: "updateViewStates",
    value: function updateViewStates() {
      var animationProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ('time' in animationProps) {
        for (var viewId in this.controllers) {
          var controller = this.controllers[viewId];

          if (controller) {
            controller.updateTransition(animationProps.time);
          }
        }
      }
    }
  }, {
    key: "getViewports",
    value: function getViewports(rect) {
      if (rect) {
        return this._viewports.filter(function (viewport) {
          return viewport.containsPixel(rect);
        });
      }

      return this._viewports;
    }
  }, {
    key: "getViews",
    value: function getViews() {
      var viewMap = {};
      this.views.forEach(function (view) {
        viewMap[view.id] = view;
      });
      return viewMap;
    }
  }, {
    key: "getView",
    value: function getView(viewOrViewId) {
      return typeof viewOrViewId === 'string' ? this.views.find(function (view) {
        return view.id === viewOrViewId;
      }) : viewOrViewId;
    }
  }, {
    key: "getViewState",
    value: function getViewState(viewId) {
      var view = this.getView(viewId);
      var viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
  }, {
    key: "getViewport",
    value: function getViewport(viewId) {
      return this._viewportMap[viewId];
    }
  }, {
    key: "unproject",
    value: function unproject(xyz, opts) {
      var viewports = this.getViewports();
      var pixel = {
        x: xyz[0],
        y: xyz[1]
      };

      for (var i = viewports.length - 1; i >= 0; --i) {
        var viewport = viewports[i];

        if (viewport.containsPixel(pixel)) {
          var p = xyz.slice();
          p[0] -= viewport.x;
          p[1] -= viewport.y;
          return viewport.unproject(p, opts);
        }
      }

      return null;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('views' in props) {
        this._setViews(props.views);
      }

      if ('viewState' in props) {
        this._setViewState(props.viewState);
      }

      if ('width' in props || 'height' in props) {
        this._setSize(props.width, props.height);
      }

      if (!this._isUpdating) {
        this._update();
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      this._isUpdating = true;

      if (this._needsUpdate) {
        this._needsUpdate = false;

        this._rebuildViewports();
      }

      if (this._needsUpdate) {
        this._needsUpdate = false;

        this._rebuildViewports();
      }

      this._isUpdating = false;
    }
  }, {
    key: "_setSize",
    value: function _setSize(width, height) {
      (0, _assert.default)(Number.isFinite(width) && Number.isFinite(height));

      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        this.setNeedsUpdate('Size changed');
      }
    }
  }, {
    key: "_setViews",
    value: function _setViews(views) {
      views = (0, _flatten.flatten)(views, {
        filter: Boolean
      }).map(function (view) {
        return view instanceof _viewport.default ? new _view.default({
          viewportInstance: view
        }) : view;
      });

      var viewsChanged = this._diffViews(views, this.views);

      if (viewsChanged) {
        this.setNeedsUpdate('views changed');
      }

      this.views = views;
    }
  }, {
    key: "_setViewState",
    value: function _setViewState(viewState) {
      if (viewState) {
        var viewStateChanged = !(0, _deepEqual.deepEqual)(viewState, this.viewState);

        if (viewStateChanged) {
          this.setNeedsUpdate('viewState changed');
        }

        this.viewState = viewState;
      } else {
        _log.default.warn('setting null viewState')();
      }
    }
  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(viewId, event) {
      event.viewId = viewId;

      this._eventCallbacks.onViewStateChange(event);
    }
  }, {
    key: "_createController",
    value: function _createController(props) {
      var Controller = props.type;
      var controller = new Controller(Object.assign({
        eventManager: this._eventManager,
        onViewStateChange: this._onViewStateChange.bind(this, props.id),
        onStateChange: this._eventCallbacks.onInteractiveStateChange
      }, props));
      return controller;
    }
  }, {
    key: "_updateController",
    value: function _updateController(view, viewState, viewport, controller) {
      if (view.controller) {
        var controllerProps = Object.assign({}, view.controller, viewState, {
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        });

        if (controller) {
          controller.setProps(controllerProps);
        } else {
          controller = this._createController(controllerProps);
        }

        return controller;
      }

      return null;
    }
  }, {
    key: "_rebuildViewports",
    value: function _rebuildViewports() {
      var width = this.width,
          height = this.height,
          views = this.views;
      var oldControllers = this.controllers;
      this._viewports = [];
      this.controllers = {};

      for (var i = views.length; i--;) {
        var view = views[i];
        var viewState = this.getViewState(view);
        var viewport = view.makeViewport({
          width: width,
          height: height,
          viewState: viewState
        });
        this.controllers[view.id] = this._updateController(view, viewState, viewport, oldControllers[view.id]);

        this._viewports.unshift(viewport);
      }

      for (var id in oldControllers) {
        if (oldControllers[id] && !this.controllers[id]) {
          oldControllers[id].finalize();
        }
      }

      this._buildViewportMap();
    }
  }, {
    key: "_buildViewportMap",
    value: function _buildViewportMap() {
      var _this = this;

      this._viewportMap = {};

      this._viewports.forEach(function (viewport) {
        if (viewport.id) {
          _this._viewportMap[viewport.id] = _this._viewportMap[viewport.id] || viewport;
        }
      });
    }
  }, {
    key: "_diffViews",
    value: function _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }

      return newViews.some(function (_, i) {
        return !newViews[i].equals(oldViews[i]);
      });
    }
  }]);
  return ViewManager;
}();

exports.default = ViewManager;

},{"../utils/assert":109,"../utils/deep-equal":111,"../utils/flatten":112,"../utils/log":117,"../viewports/viewport":125,"../views/view":133,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],81:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _log = _interopRequireDefault(require("../utils/log"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _iterableUtils = require("../utils/iterable-utils");

var EMPTY_PROPS = Object.freeze({});

var ComponentState = function () {
  function ComponentState() {
    var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, ComponentState);
    this.component = component;
    this.asyncProps = {};

    this.onAsyncPropUpdated = function () {};

    this.oldProps = EMPTY_PROPS;
    this.oldAsyncProps = null;
  }

  (0, _createClass2.default)(ComponentState, [{
    key: "getOldProps",
    value: function getOldProps() {
      return this.oldAsyncProps || this.oldProps;
    }
  }, {
    key: "resetOldProps",
    value: function resetOldProps() {
      this.oldAsyncProps = null;
      this.oldProps = this.component.props;
    }
  }, {
    key: "freezeAsyncOldProps",
    value: function freezeAsyncOldProps() {
      if (!this.oldAsyncProps) {
        this.oldProps = this.oldProps || this.component.props;
        this.oldAsyncProps = Object.create(this.oldProps);

        for (var propName in this.asyncProps) {
          Object.defineProperty(this.oldAsyncProps, propName, {
            enumerable: true,
            value: this.oldProps[propName]
          });
        }
      }
    }
  }, {
    key: "hasAsyncProp",
    value: function hasAsyncProp(propName) {
      return propName in this.asyncProps;
    }
  }, {
    key: "getAsyncProp",
    value: function getAsyncProp(propName) {
      var asyncProp = this.asyncProps[propName];
      return asyncProp && asyncProp.resolvedValue;
    }
  }, {
    key: "isAsyncPropLoading",
    value: function isAsyncPropLoading(propName) {
      var asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
  }, {
    key: "setAsyncProps",
    value: function setAsyncProps(props) {
      var resolvedValues = props._asyncPropResolvedValues || {};
      var originalValues = props._asyncPropOriginalValues || props;
      var defaultValues = props._asyncPropDefaultValues || {};

      for (var propName in resolvedValues) {
        var value = resolvedValues[propName];

        this._createAsyncPropData(propName, value, defaultValues[propName]);

        this._updateAsyncProp(propName, value);
      }

      for (var _propName in originalValues) {
        var _value2 = originalValues[_propName];

        this._createAsyncPropData(_propName, _value2, defaultValues[_propName]);

        this._updateAsyncProp(_propName, _value2);
      }
    }
  }, {
    key: "_updateAsyncProp",
    value: function _updateAsyncProp(propName, value) {
      if (!this._didAsyncInputValueChange(propName, value)) {
        return;
      }

      if (typeof value === 'string') {
        var fetch = this.layer.props.fetch;
        var url = value;
        value = fetch(url, {
          propName: propName,
          layer: this.layer
        });
      }

      if (value instanceof Promise) {
        this._watchPromise(propName, value);

        return;
      }

      if ((0, _iterableUtils.isAsyncIterable)(value)) {
        this._resolveAsyncIterable(propName, value);

        return;
      }

      this._setPropValue(propName, value);
    }
  }, {
    key: "_didAsyncInputValueChange",
    value: function _didAsyncInputValueChange(propName, value) {
      var asyncProp = this.asyncProps[propName];

      if (value === asyncProp.lastValue) {
        return false;
      }

      asyncProp.lastValue = value;
      return true;
    }
  }, {
    key: "_setPropValue",
    value: function _setPropValue(propName, value) {
      var asyncProp = this.asyncProps[propName];
      asyncProp.value = value;
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }, {
    key: "_setAsyncPropValue",
    value: function _setAsyncPropValue(propName, value, loadCount) {
      var asyncProp = this.asyncProps[propName];

      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount) {
        (0, _assert.default)(value !== undefined);
        this.freezeAsyncOldProps();
        asyncProp.resolvedValue = value;
        asyncProp.resolvedLoadCount = loadCount;
        this.onAsyncPropUpdated(propName, value);
      }
    }
  }, {
    key: "_watchPromise",
    value: function _watchPromise(propName, promise) {
      var _this = this;

      var asyncProp = this.asyncProps[propName];
      asyncProp.pendingLoadCount++;
      var loadCount = asyncProp.pendingLoadCount;
      promise.then(function (data) {
        data = _this._postProcessValue(propName, data);

        _this._setAsyncPropValue(propName, data, loadCount);

        var onDataLoad = _this.layer.props.onDataLoad;

        if (propName === 'data' && onDataLoad) {
          onDataLoad(data, {
            propName: propName,
            layer: _this.layer
          });
        }
      }).catch(function (error) {
        return _log.default.error(error)();
      });
    }
  }, {
    key: "_resolveAsyncIterable",
    value: function () {
      var _resolveAsyncIterable2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(propName, iterable) {
        var asyncProp, loadCount, data, count, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, onDataLoad;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (propName !== 'data') {
                  this._setPropValue(propName, iterable);
                }

                asyncProp = this.asyncProps[propName];
                asyncProp.pendingLoadCount++;
                loadCount = asyncProp.pendingLoadCount;
                data = [];
                count = 0;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _context.prev = 8;
                _iterator = (0, _asyncIterator2.default)(iterable);

              case 10:
                _context.next = 12;
                return _iterator.next();

              case 12:
                _step = _context.sent;
                _iteratorNormalCompletion = _step.done;
                _context.next = 16;
                return _step.value;

              case 16:
                _value = _context.sent;

                if (_iteratorNormalCompletion) {
                  _context.next = 26;
                  break;
                }

                chunk = _value;
                data = this._postProcessValue(propName, chunk, data);
                Object.defineProperty(data, '__diff', {
                  enumerable: false,
                  value: [{
                    startRow: count,
                    endRow: data.length
                  }]
                });
                count = data.length;

                this._setAsyncPropValue(propName, data, loadCount);

              case 23:
                _iteratorNormalCompletion = true;
                _context.next = 10;
                break;

              case 26:
                _context.next = 32;
                break;

              case 28:
                _context.prev = 28;
                _context.t0 = _context["catch"](8);
                _didIteratorError = true;
                _iteratorError = _context.t0;

              case 32:
                _context.prev = 32;
                _context.prev = 33;

                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                  _context.next = 37;
                  break;
                }

                _context.next = 37;
                return _iterator.return();

              case 37:
                _context.prev = 37;

                if (!_didIteratorError) {
                  _context.next = 40;
                  break;
                }

                throw _iteratorError;

              case 40:
                return _context.finish(37);

              case 41:
                return _context.finish(32);

              case 42:
                onDataLoad = this.layer.props.onDataLoad;

                if (onDataLoad) {
                  onDataLoad(data, {
                    propName: propName,
                    layer: this.layer
                  });
                }

              case 44:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[8, 28, 32, 42], [33,, 37, 41]]);
      }));

      function _resolveAsyncIterable(_x, _x2) {
        return _resolveAsyncIterable2.apply(this, arguments);
      }

      return _resolveAsyncIterable;
    }()
  }, {
    key: "_postProcessValue",
    value: function _postProcessValue(propName, value, previousValue) {
      var _ref = this.component ? this.component.props : {},
          dataTransform = _ref.dataTransform;

      if (propName !== 'data') {
        return value;
      }

      if (dataTransform) {
        return dataTransform(value, previousValue);
      }

      return previousValue ? previousValue.concat(value) : value;
    }
  }, {
    key: "_createAsyncPropData",
    value: function _createAsyncPropData(propName, value, defaultValue) {
      var asyncProp = this.asyncProps[propName];

      if (!asyncProp) {
        this.asyncProps[propName] = {
          lastValue: null,
          resolvedValue: defaultValue,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  }]);
  return ComponentState;
}();

exports.default = ComponentState;

},{"../utils/assert":109,"../utils/iterable-utils":115,"../utils/log":117,"@babel/runtime/helpers/asyncIterator":15,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],82:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _constants = require("../lifecycle/constants");

var _createProps = require("../lifecycle/create-props");

var _componentState = _interopRequireDefault(require("./component-state"));

var defaultProps = {};
var counter = 0;

var Component = function () {
  function Component() {
    (0, _classCallCheck2.default)(this, Component);
    this.props = _createProps.createProps.apply(this, arguments);
    this.id = this.props.id;
    this.count = counter++;
    this.lifecycle = _constants.LIFECYCLE.NO_STATE;
    this.parent = null;
    this.context = null;
    this.state = null;
    this.internalState = null;
    Object.seal(this);
  }

  (0, _createClass2.default)(Component, [{
    key: "clone",
    value: function clone(newProps) {
      var props = this.props;
      var asyncProps = {};

      for (var key in props._asyncPropDefaultValues) {
        if (key in props._asyncPropResolvedValues) {
          asyncProps[key] = props._asyncPropResolvedValues[key];
        } else if (key in props._asyncPropOriginalValues) {
          asyncProps[key] = props._asyncPropOriginalValues[key];
        }
      }

      return new this.constructor(Object.assign({}, props, asyncProps, newProps));
    }
  }, {
    key: "_initState",
    value: function _initState() {
      this.internalState = new _componentState.default({});
    }
  }, {
    key: "stats",
    get: function get() {
      return this.internalState.stats;
    }
  }]);
  return Component;
}();

exports.default = Component;
Component.componentName = 'Component';
Component.defaultProps = defaultProps;

},{"../lifecycle/constants":83,"../lifecycle/create-props":84,"./component-state":81,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LIFECYCLE = void 0;
var LIFECYCLE = {
  NO_STATE: 'Awaiting state',
  MATCHED: 'Matched. State transferred from previous layer',
  INITIALIZED: 'Initialized',
  AWAITING_GC: 'Discarded. Awaiting garbage collection',
  AWAITING_FINALIZATION: 'No longer matched. Awaiting garbage collection',
  FINALIZED: 'Finalized! Awaiting garbage collection'
};
exports.LIFECYCLE = LIFECYCLE;

},{}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProps = createProps;

var _seerIntegration = require("../lib/seer-integration");

var _log = _interopRequireDefault(require("../utils/log"));

var _iterableUtils = require("../utils/iterable-utils");

var _propTypes = require("./prop-types");

function createProps() {
  var component = this;
  var propTypeDefs = getPropsPrototypeAndTypes(component.constructor);
  var propsPrototype = propTypeDefs.defaultProps;
  var propsInstance = Object.create(propsPrototype, {
    _component: {
      enumerable: false,
      value: component
    },
    _asyncPropOriginalValues: {
      enumerable: false,
      value: {}
    },
    _asyncPropResolvedValues: {
      enumerable: false,
      value: {}
    }
  });

  for (var i = 0; i < arguments.length; ++i) {
    Object.assign(propsInstance, arguments[i]);
  }

  var layerName = component.constructor.layerName;
  var deprecatedProps = propTypeDefs.deprecatedProps;
  checkDeprecatedProps(layerName, propsInstance, deprecatedProps);
  checkDeprecatedProps(layerName, propsInstance.updateTriggers, deprecatedProps);
  checkDeprecatedProps(layerName, propsInstance.transitions, deprecatedProps);
  (0, _seerIntegration.applyPropOverrides)(propsInstance);
  Object.freeze(propsInstance);
  return propsInstance;
}

function checkDeprecatedProps(layerName, propsInstance, deprecatedProps) {
  if (!propsInstance) {
    return;
  }

  for (var name in deprecatedProps) {
    if (hasOwnProperty(propsInstance, name)) {
      var nameStr = "".concat(layerName || 'Layer', ": ").concat(name);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = deprecatedProps[name][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var newPropName = _step.value;

          if (!hasOwnProperty(propsInstance, newPropName)) {
            propsInstance[newPropName] = propsInstance[name];
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      _log.default.deprecated(nameStr, deprecatedProps[name].join('/'))();
    }
  }
}

function getPropsPrototypeAndTypes(componentClass) {
  var props = getOwnProperty(componentClass, '_mergedDefaultProps');

  if (props) {
    return {
      defaultProps: props,
      propTypes: getOwnProperty(componentClass, '_propTypes'),
      deprecatedProps: getOwnProperty(componentClass, '_deprecatedProps')
    };
  }

  return createPropsPrototypeAndTypes(componentClass);
}

function createPropsPrototypeAndTypes(componentClass) {
  var parent = componentClass.prototype;

  if (!parent) {
    return {
      defaultProps: {}
    };
  }

  var parentClass = Object.getPrototypeOf(componentClass);
  var parentPropDefs = parent && getPropsPrototypeAndTypes(parentClass) || null;
  var componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};
  var componentPropDefs = (0, _propTypes.parsePropTypes)(componentDefaultProps);
  var propTypes = Object.assign({}, parentPropDefs && parentPropDefs.propTypes, componentPropDefs.propTypes);
  var defaultProps = createPropsPrototype(componentPropDefs.defaultProps, parentPropDefs && parentPropDefs.defaultProps, propTypes, componentClass);
  var deprecatedProps = Object.assign({}, parentPropDefs && parentPropDefs.deprecatedProps, componentPropDefs.deprecatedProps);
  componentClass._mergedDefaultProps = defaultProps;
  componentClass._propTypes = propTypes;
  componentClass._deprecatedProps = deprecatedProps;
  return {
    propTypes: propTypes,
    defaultProps: defaultProps,
    deprecatedProps: deprecatedProps
  };
}

function createPropsPrototype(props, parentProps, propTypes, componentClass) {
  var defaultProps = Object.create(null);
  Object.assign(defaultProps, parentProps, props);
  var id = getComponentName(componentClass);
  delete props.id;
  Object.defineProperties(defaultProps, {
    id: {
      configurable: false,
      writable: true,
      value: id
    }
  });
  addAsyncPropsToPropPrototype(defaultProps, propTypes);
  return defaultProps;
}

function addAsyncPropsToPropPrototype(defaultProps, propTypes) {
  var defaultValues = {};
  var descriptors = {
    _asyncPropDefaultValues: {
      enumerable: false,
      value: defaultValues
    },
    _asyncPropOriginalValues: {
      enumerable: false,
      value: {}
    }
  };

  for (var propName in propTypes) {
    var propType = propTypes[propName];
    var name = propType.name,
        value = propType.value;

    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name, value);
    }
  }

  Object.defineProperties(defaultProps, descriptors);
}

function getDescriptorForAsyncProp(name) {
  return {
    configurable: false,
    enumerable: true,
    set: function set(newValue) {
      if (typeof newValue === 'string' || newValue instanceof Promise || (0, _iterableUtils.isAsyncIterable)(newValue)) {
        this._asyncPropOriginalValues[name] = newValue;
      } else {
        this._asyncPropResolvedValues[name] = newValue;
      }
    },
    get: function get() {
      if (this._asyncPropResolvedValues) {
        if (name in this._asyncPropResolvedValues) {
          var value = this._asyncPropResolvedValues[name];

          if (name === 'data') {
            return value || this._asyncPropDefaultValues[name];
          }

          return value;
        }

        if (name in this._asyncPropOriginalValues) {
          var state = this._component && this._component.internalState;

          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name);
          }
        }
      }

      return this._asyncPropDefaultValues[name];
    }
  };
}

function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}

function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}

function getComponentName(componentClass) {
  var componentName = getOwnProperty(componentClass, 'layerName') || getOwnProperty(componentClass, 'componentName');

  if (!componentName) {
    _log.default.once(0, "".concat(componentClass.name, ".componentName not specified"))();
  }

  return componentName || componentClass.name;
}

},{"../lib/seer-integration":79,"../utils/iterable-utils":115,"../utils/log":117,"./prop-types":85,"@babel/runtime/helpers/interopRequireDefault":25}],85:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var TYPE_DEFINITIONS = {
  boolean: {
    validate: function validate(value, propType) {
      return true;
    },
    equal: function equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate: function validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  },
  color: {
    validate: function validate(value, propType) {
      return isArray(value) && (value.length === 3 || value.length === 4);
    },
    equal: function equal(value1, value2, propType) {
      return arrayEqual(value1, value2);
    }
  },
  accessor: {
    validate: function validate(value, propType) {
      var valueType = getTypeOf(value);
      return valueType === 'function' || valueType === getTypeOf(propType.value);
    },
    equal: function equal(value1, value2, propType) {
      if (typeof value2 === 'function') {
        return true;
      }

      return arrayEqual(value1, value2);
    }
  },
  array: {
    validate: function validate(value, propType) {
      return propType.optional && !value || isArray(value);
    },
    equal: function equal(value1, value2, propType) {
      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;
    }
  },
  function: {
    validate: function validate(value, propType) {
      return propType.optional && !value || typeof value === 'function';
    },
    equal: function equal(value1, value2, propType) {
      return !propType.compare || value1 === value2;
    }
  }
};

function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }

  if (!isArray(array1) || !isArray(array2)) {
    return false;
  }

  var len = array1.length;

  if (len !== array2.length) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}

function parsePropTypes(propDefs) {
  var propTypes = {};
  var defaultProps = {};
  var deprecatedProps = {};

  var _arr = Object.entries(propDefs);

  for (var _i = 0; _i < _arr.length; _i++) {
    var _arr$_i = (0, _slicedToArray2.default)(_arr[_i], 2),
        propName = _arr$_i[0],
        propDef = _arr$_i[1];

    if (propDef && propDef.deprecatedFor) {
      deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor) ? propDef.deprecatedFor : [propDef.deprecatedFor];
    } else {
      var propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps[propName] = propType.value;
    }
  }

  return {
    propTypes: propTypes,
    defaultProps: defaultProps,
    deprecatedProps: deprecatedProps
  };
}

function parsePropType(name, propDef) {
  switch (getTypeOf(propDef)) {
    case 'object':
      return normalizePropDefinition(name, propDef);

    case 'array':
      return normalizePropDefinition(name, {
        type: 'array',
        value: propDef,
        compare: false
      });

    case 'boolean':
      return normalizePropDefinition(name, {
        type: 'boolean',
        value: propDef
      });

    case 'number':
      return normalizePropDefinition(name, {
        type: 'number',
        value: propDef
      });

    case 'function':
      return normalizePropDefinition(name, {
        type: 'function',
        value: propDef,
        compare: true
      });

    default:
      return {
        name: name,
        type: 'unknown',
        value: propDef
      };
  }
}

function normalizePropDefinition(name, propDef) {
  if (!('type' in propDef)) {
    if (!('value' in propDef)) {
      return {
        name: name,
        type: 'object',
        value: propDef
      };
    }

    return Object.assign({
      name: name,
      type: getTypeOf(propDef.value)
    }, propDef);
  }

  return Object.assign({
    name: name
  }, TYPE_DEFINITIONS[propDef.type], propDef);
}

function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}

function getTypeOf(value) {
  if (isArray(value)) {
    return 'array';
  }

  if (value === null) {
    return 'null';
  }

  return (0, _typeof2.default)(value);
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37,"@babel/runtime/helpers/typeof":40}],86:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateProps = validateProps;
exports.diffProps = diffProps;
exports.compareProps = compareProps;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function validateProps(props) {
  var propTypes = getPropTypes(props);

  for (var propName in propTypes) {
    var propType = propTypes[propName];
    var validate = propType.validate;

    if (validate && !validate(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}

function diffProps(props, oldProps) {
  var propsChangedReason = compareProps({
    newProps: props,
    oldProps: oldProps,
    propTypes: getPropTypes(props),
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null
    }
  });
  var dataChangedReason = diffDataProps(props, oldProps);
  var updateTriggersChangedReason = false;

  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }

  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps)
  };
}

function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      newProps = _ref.newProps,
      oldProps = _ref.oldProps,
      _ref$ignoreProps = _ref.ignoreProps,
      ignoreProps = _ref$ignoreProps === void 0 ? {} : _ref$ignoreProps,
      _ref$propTypes = _ref.propTypes,
      propTypes = _ref$propTypes === void 0 ? {} : _ref$propTypes,
      _ref$triggerName = _ref.triggerName,
      triggerName = _ref$triggerName === void 0 ? 'props' : _ref$triggerName;

  (0, _assert.default)(oldProps !== undefined && newProps !== undefined, 'compareProps args');

  if (oldProps === newProps) {
    return null;
  }

  if ((0, _typeof2.default)(newProps) !== 'object' || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  if ((0, _typeof2.default)(oldProps) !== 'object' || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  var _arr = Object.keys(newProps);

  for (var _i = 0; _i < _arr.length; _i++) {
    var key = _arr[_i];

    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }

      var changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);

      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }

  var _arr2 = Object.keys(oldProps);

  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
    var _key = _arr2[_i2];

    if (!(_key in ignoreProps)) {
      if (!(_key in newProps)) {
        return "".concat(triggerName, ".").concat(_key, " dropped");
      }

      if (!Object.hasOwnProperty.call(newProps, _key)) {
        var _changed = comparePropValues(newProps[_key], oldProps[_key], propTypes[_key]);

        if (_changed) {
          return "".concat(triggerName, ".").concat(_key, " ").concat(_changed);
        }
      }
    }
  }

  return null;
}

function comparePropValues(newProp, oldProp, propType) {
  var equal = propType && propType.equal;

  if (equal && !equal(newProp, oldProp, propType)) {
    return 'changed deeply';
  }

  if (!equal) {
    equal = newProp && oldProp && newProp.equals;

    if (equal && !equal.call(newProp, oldProp)) {
      return 'changed deeply';
    }
  }

  if (!equal && oldProp !== newProp) {
    return 'changed shallowly';
  }

  return null;
}

function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  var dataChanged = null;
  var dataComparator = props.dataComparator,
      _dataDiff = props._dataDiff;

  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = 'Data comparator detected a change';
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = 'A new data container was supplied';
  }

  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }

  return dataChanged;
}

function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  if ('all' in props.updateTriggers) {
    var diffReason = diffUpdateTrigger(props, oldProps, 'all');

    if (diffReason) {
      return {
        all: true
      };
    }
  }

  var triggerChanged = {};
  var reason = false;

  for (var triggerName in props.updateTriggers) {
    if (triggerName !== 'all') {
      var _diffReason = diffUpdateTrigger(props, oldProps, triggerName);

      if (_diffReason) {
        triggerChanged[triggerName] = true;
        reason = triggerChanged;
      }
    }
  }

  return reason;
}

function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  var oldExtensions = oldProps.extensions;
  var extensions = props.extensions;

  if (extensions === oldExtensions) {
    return false;
  }

  if (extensions.length !== oldExtensions.length) {
    return true;
  }

  for (var i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }

  return false;
}

function diffUpdateTrigger(props, oldProps, triggerName) {
  var newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
  var oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
  var diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName: triggerName
  });
  return diffReason;
}

function getPropTypes(props) {
  var layer = props._component;
  var LayerType = layer && layer.constructor;
  return LayerType ? LayerType._propTypes : {};
}

},{"../utils/assert":109,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],87:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _layersPass = _interopRequireDefault(require("./layers-pass"));

var DrawLayersPass = function (_LayersPass) {
  (0, _inherits2.default)(DrawLayersPass, _LayersPass);

  function DrawLayersPass() {
    (0, _classCallCheck2.default)(this, DrawLayersPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(DrawLayersPass).apply(this, arguments));
  }

  (0, _createClass2.default)(DrawLayersPass, [{
    key: "getModuleParameters",
    value: function getModuleParameters(layer, effects, effectProps) {
      var moduleParameters = (0, _get2.default)((0, _getPrototypeOf2.default)(DrawLayersPass.prototype), "getModuleParameters", this).call(this, layer);
      Object.assign(moduleParameters, this.getObjectHighlightParameters(layer), effectProps);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          Object.assign(moduleParameters, effect.getParameters(layer));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return moduleParameters;
    }
  }, {
    key: "getObjectHighlightParameters",
    value: function getObjectHighlightParameters(layer) {
      var _layer$props = layer.props,
          highlightedObjectIndex = _layer$props.highlightedObjectIndex,
          highlightColor = _layer$props.highlightColor;
      var parameters = {
        pickingHighlightColor: [highlightColor[0], highlightColor[1], highlightColor[2], highlightColor[3] || 255]
      };

      if (Number.isInteger(highlightedObjectIndex)) {
        parameters.pickingSelectedColor = highlightedObjectIndex >= 0 ? layer.encodePickingColor(highlightedObjectIndex) : null;
      }

      return parameters;
    }
  }]);
  return DrawLayersPass;
}(_layersPass.default);

exports.default = DrawLayersPass;

},{"./layers-pass":88,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],88:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var _core = require("@luma.gl/core");

var LayersPass = function (_Pass) {
  (0, _inherits2.default)(LayersPass, _Pass);

  function LayersPass() {
    (0, _classCallCheck2.default)(this, LayersPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LayersPass).apply(this, arguments));
  }

  (0, _createClass2.default)(LayersPass, [{
    key: "render",
    value: function render(params) {
      var _this = this;

      var gl = this.gl;
      return (0, _core.withParameters)(gl, {
        framebuffer: params.outputBuffer
      }, function () {
        return _this.drawLayers(params);
      });
    }
  }, {
    key: "drawLayers",
    value: function drawLayers(_ref) {
      var _this2 = this;

      var layers = _ref.layers,
          viewports = _ref.viewports,
          views = _ref.views,
          onViewportActive = _ref.onViewportActive,
          _ref$deviceRect = _ref.deviceRect,
          deviceRect = _ref$deviceRect === void 0 ? null : _ref$deviceRect,
          _ref$parameters = _ref.parameters,
          parameters = _ref$parameters === void 0 ? {} : _ref$parameters,
          _ref$pass = _ref.pass,
          pass = _ref$pass === void 0 ? 'draw' : _ref$pass,
          _ref$redrawReason = _ref.redrawReason,
          redrawReason = _ref$redrawReason === void 0 ? '' : _ref$redrawReason,
          _ref$clearCanvas = _ref.clearCanvas,
          clearCanvas = _ref$clearCanvas === void 0 ? true : _ref$clearCanvas,
          effects = _ref.effects,
          effectProps = _ref.effectProps;
      var gl = this.gl;

      if (clearCanvas) {
        this.clearCanvas(gl);
      }

      var renderStats = [];
      viewports.forEach(function (viewportOrDescriptor, i) {
        var viewport = _this2.getViewportFromDescriptor(viewportOrDescriptor);

        var view = views && views[viewport.id];
        onViewportActive(viewport);

        var stats = _this2.drawLayersInViewport(gl, {
          layers: layers,
          viewport: viewport,
          view: view,
          deviceRect: deviceRect,
          parameters: parameters,
          pass: pass,
          redrawReason: redrawReason,
          effects: effects,
          effectProps: effectProps
        });

        renderStats.push(stats);
      });
      return renderStats;
    }
  }, {
    key: "drawLayersInViewport",
    value: function drawLayersInViewport(gl, _ref2) {
      var _this3 = this;

      var layers = _ref2.layers,
          viewport = _ref2.viewport,
          view = _ref2.view,
          _ref2$deviceRect = _ref2.deviceRect,
          deviceRect = _ref2$deviceRect === void 0 ? null : _ref2$deviceRect,
          _ref2$parameters = _ref2.parameters,
          parameters = _ref2$parameters === void 0 ? {} : _ref2$parameters,
          _ref2$pass = _ref2.pass,
          pass = _ref2$pass === void 0 ? 'draw' : _ref2$pass,
          _ref2$redrawReason = _ref2.redrawReason,
          redrawReason = _ref2$redrawReason === void 0 ? '' : _ref2$redrawReason,
          effects = _ref2.effects,
          effectProps = _ref2.effectProps;
      var glViewport = this.getGLViewport(gl, {
        viewport: viewport
      });

      if (view && view.props.clear) {
        var clearOpts = view.props.clear === true ? {
          color: true,
          depth: true
        } : view.props.clear;
        (0, _core.withParameters)(gl, {
          scissorTest: true,
          scissor: glViewport
        }, function () {
          return (0, _core.clear)(gl, clearOpts);
        });
      }

      var renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      (0, _core.setParameters)(gl, parameters || {});
      layers.forEach(function (layer, layerIndex) {
        var shouldDrawLayer = _this3.shouldDrawLayer(layer, viewport);

        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }

        if (layer.isComposite) {
          renderStatus.compositeCount++;
        }

        if (shouldDrawLayer) {
          renderStatus.visibleCount++;

          _this3.drawLayerInViewport({
            gl: gl,
            layer: layer,
            layerIndex: layerIndex,
            glViewport: glViewport,
            parameters: parameters,
            effects: effects,
            effectProps: effectProps
          });
        }
      });
      return renderStatus;
    }
  }, {
    key: "drawLayerInViewport",
    value: function drawLayerInViewport(_ref3) {
      var gl = _ref3.gl,
          layer = _ref3.layer,
          layerIndex = _ref3.layerIndex,
          glViewport = _ref3.glViewport,
          parameters = _ref3.parameters,
          effects = _ref3.effects,
          effectProps = _ref3.effectProps;
      var moduleParameters = this.getModuleParameters(layer, effects, effectProps);
      var uniforms = Object.assign({}, layer.context.uniforms, {
        layerIndex: layerIndex
      });
      var layerParameters = this.getLayerParameters(layer, layerIndex, glViewport, parameters);
      layer.drawLayer({
        moduleParameters: moduleParameters,
        uniforms: uniforms,
        parameters: layerParameters
      });
    }
  }, {
    key: "getViewportFromDescriptor",
    value: function getViewportFromDescriptor(viewportOrDescriptor) {
      return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;
    }
  }, {
    key: "shouldDrawLayer",
    value: function shouldDrawLayer(layer, viewport) {
      var layerFilter = this.props.layerFilter;
      var shouldDrawLayer = !layer.isComposite && layer.props.visible;

      if (shouldDrawLayer && layerFilter) {
        shouldDrawLayer = layerFilter({
          layer: layer,
          viewport: viewport,
          isPicking: false
        });
      }

      return shouldDrawLayer;
    }
  }, {
    key: "getModuleParameters",
    value: function getModuleParameters(layer) {
      var moduleParameters = Object.assign(Object.create(layer.props), {
        viewport: layer.context.viewport,
        mousePosition: layer.context.mousePosition,
        pickingActive: 0,
        devicePixelRatio: this.props.pixelRatio
      });
      return moduleParameters;
    }
  }, {
    key: "getLayerParameters",
    value: function getLayerParameters(layer, layerIndex, glViewport, parameters) {
      var layerParameters = Object.assign({}, layer.props.parameters || {}, parameters);
      Object.assign(layerParameters, {
        viewport: glViewport
      });
      return layerParameters;
    }
  }, {
    key: "getGLViewport",
    value: function getGLViewport(gl, _ref4) {
      var viewport = _ref4.viewport;
      var height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;
      var dimensions = viewport;
      var pixelRatio = this.props.pixelRatio;
      return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
    }
  }, {
    key: "clearCanvas",
    value: function clearCanvas(gl) {
      var width = gl.drawingBufferWidth;
      var height = gl.drawingBufferHeight;
      (0, _core.withParameters)(gl, {
        viewport: [0, 0, width, height]
      }, function () {
        gl.clear(16384 | 256);
      });
    }
  }]);
  return LayersPass;
}(_pass.default);

exports.default = LayersPass;

},{"./pass":89,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/core":253}],89:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Pass = function () {
  function Pass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Pass);
    var _props$id = props.id,
        id = _props$id === void 0 ? 'pass' : _props$id;
    this.id = id;
    this.gl = gl;
    this.props = {};
    Object.assign(this.props, props);
  }

  (0, _createClass2.default)(Pass, [{
    key: "setProps",
    value: function setProps(props) {
      Object.assign(this.props, props);
    }
  }, {
    key: "render",
    value: function render() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
  }]);
  return Pass;
}();

exports.default = Pass;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],90:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _layersPass = _interopRequireDefault(require("./layers-pass"));

var _core = require("@luma.gl/core");

var PickLayersPass = function (_LayersPass) {
  (0, _inherits2.default)(PickLayersPass, _LayersPass);

  function PickLayersPass() {
    (0, _classCallCheck2.default)(this, PickLayersPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PickLayersPass).apply(this, arguments));
  }

  (0, _createClass2.default)(PickLayersPass, [{
    key: "render",
    value: function render(props) {
      if (props.pickingFBO) {
        this.drawPickingBuffer(props);
      } else {
        (0, _get2.default)((0, _getPrototypeOf2.default)(PickLayersPass.prototype), "render", this).call(this, props);
      }
    }
  }, {
    key: "drawPickingBuffer",
    value: function drawPickingBuffer(_ref) {
      var _this = this;

      var layers = _ref.layers,
          viewports = _ref.viewports,
          onViewportActive = _ref.onViewportActive,
          pickingFBO = _ref.pickingFBO,
          effectProps = _ref.effectProps,
          _ref$deviceRect = _ref.deviceRect,
          x = _ref$deviceRect.x,
          y = _ref$deviceRect.y,
          width = _ref$deviceRect.width,
          height = _ref$deviceRect.height,
          _ref$redrawReason = _ref.redrawReason,
          redrawReason = _ref$redrawReason === void 0 ? '' : _ref$redrawReason;
      var gl = this.gl;
      return (0, _core.withParameters)(gl, {
        framebuffer: pickingFBO,
        scissorTest: true,
        scissor: [x, y, width, height],
        clearColor: [0, 0, 0, 0]
      }, function () {
        _this.drawLayers({
          layers: layers,
          viewports: viewports,
          onViewportActive: onViewportActive,
          pass: 'picking',
          redrawReason: redrawReason,
          effectProps: effectProps,
          parameters: {
            blend: true,
            blendFunc: [1, 0, 32771, 0],
            blendEquation: 32774,
            blendColor: [0, 0, 0, 0],
            depthMask: true,
            depthTest: true,
            depthRange: [0, 1],
            colorMask: [true, true, true, true]
          }
        });
      });
    }
  }, {
    key: "shouldDrawLayer",
    value: function shouldDrawLayer(layer, viewport) {
      var layerFilter = this.props.layerFilter;
      var shouldDrawLayer = !layer.isComposite && layer.props.visible && layer.props.pickable;

      if (shouldDrawLayer && layerFilter) {
        shouldDrawLayer = layerFilter({
          layer: layer,
          viewport: viewport,
          isPicking: true
        });
      }

      return shouldDrawLayer;
    }
  }, {
    key: "getModuleParameters",
    value: function getModuleParameters(layer, effects, effectProps) {
      var moduleParameters = Object.assign(Object.create(layer.props), {
        viewport: layer.context.viewport,
        pickingActive: 1,
        devicePixelRatio: this.props.pixelRatio
      });
      Object.assign(moduleParameters, effectProps);
      return moduleParameters;
    }
  }, {
    key: "getLayerParameters",
    value: function getLayerParameters(layer, layerIndex, glViewport, parameters) {
      var layerParameters = Object.assign({}, layer.props.parameters || {}, parameters);
      Object.assign(layerParameters, {
        viewport: glViewport,
        blendColor: [0, 0, 0, (layerIndex + 1) / 255]
      });
      return layerParameters;
    }
  }]);
  return PickLayersPass;
}(_layersPass.default);

exports.default = PickLayersPass;

},{"./layers-pass":88,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/core":253}],91:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var _pass = _interopRequireDefault(require("./pass"));

var ScreenPass = function (_Pass) {
  (0, _inherits2.default)(ScreenPass, _Pass);

  function ScreenPass(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ScreenPass);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ScreenPass).call(this, gl, props));
    var module = props.module,
        fs = props.fs,
        id = props.id,
        moduleProps = props.moduleProps;
    _this.model = _this._getModel(gl, module, fs, id, moduleProps);
    return _this;
  }

  (0, _createClass2.default)(ScreenPass, [{
    key: "render",
    value: function render(params) {
      var _this2 = this;

      var gl = this.gl;
      (0, _core.withParameters)(gl, {
        framebuffer: params.outputBuffer,
        clearColor: [0, 0, 0, 0]
      }, function () {
        return _this2._renderPass(gl, params);
      });
    }
  }, {
    key: "delete",
    value: function _delete() {
      this.model.delete();
      this.model = null;
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl, module, fs, id, userProps) {
      var model = new _core.ClipSpace(gl, {
        id: id,
        fs: fs,
        modules: [module]
      });
      var uniforms = Object.assign(module.getUniforms(), module.getUniforms(userProps));
      model.setUniforms(uniforms);
      return model;
    }
  }, {
    key: "_renderPass",
    value: function _renderPass(gl, _ref) {
      var inputBuffer = _ref.inputBuffer,
          outputBuffer = _ref.outputBuffer;
      (0, _core.clear)(gl, {
        color: true
      });
      this.model.draw({
        uniforms: {
          texture: inputBuffer,
          texSize: [inputBuffer.width, inputBuffer.height]
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return ScreenPass;
}(_pass.default);

exports.default = ScreenPass;

},{"./pass":89,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/core":253}],92:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _layersPass = _interopRequireDefault(require("./layers-pass"));

var _core = require("@luma.gl/core");

var ShadowPass = function (_LayersPass) {
  (0, _inherits2.default)(ShadowPass, _LayersPass);

  function ShadowPass(gl, props) {
    var _parameters, _attachments;

    var _this;

    (0, _classCallCheck2.default)(this, ShadowPass);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ShadowPass).call(this, gl, props));
    _this.shadowMap = new _core.Texture2D(gl, {
      width: 1,
      height: 1,
      parameters: (_parameters = {}, (0, _defineProperty2.default)(_parameters, 10241, 9729), (0, _defineProperty2.default)(_parameters, 10240, 9729), (0, _defineProperty2.default)(_parameters, 10242, 33071), (0, _defineProperty2.default)(_parameters, 10243, 33071), _parameters)
    });
    _this.depthBuffer = new _core.Renderbuffer(gl, {
      format: 33189,
      width: 1,
      height: 1
    });
    _this.fbo = new _core.Framebuffer(gl, {
      id: 'shadowmap',
      width: 1,
      height: 1,
      attachments: (_attachments = {}, (0, _defineProperty2.default)(_attachments, 36064, _this.shadowMap), (0, _defineProperty2.default)(_attachments, 36096, _this.depthBuffer), _attachments)
    });
    return _this;
  }

  (0, _createClass2.default)(ShadowPass, [{
    key: "render",
    value: function render(params) {
      var _this2 = this;

      var target = this.fbo;
      (0, _core.withParameters)(this.gl, {
        depthRange: [0, 1],
        depthTest: true,
        blend: false,
        clearColor: [1, 1, 1, 1]
      }, function () {
        var viewport = params.viewports[0];
        var width = viewport.width * _this2.props.pixelRatio;
        var height = viewport.height * _this2.props.pixelRatio;

        if (width !== target.width || height !== target.height) {
          target.resize({
            width: width,
            height: height
          });
        }

        (0, _get2.default)((0, _getPrototypeOf2.default)(ShadowPass.prototype), "render", _this2).call(_this2, Object.assign(params, {
          outputBuffer: target
        }));
      });
    }
  }, {
    key: "getModuleParameters",
    value: function getModuleParameters(layer, effects, effectProps) {
      var moduleParameters = Object.assign(Object.create(layer.props), {
        viewport: layer.context.viewport,
        pickingActive: 0,
        drawToShadowMap: true,
        devicePixelRatio: this.props.pixelRatio
      });
      Object.assign(moduleParameters, effectProps);
      return moduleParameters;
    }
  }, {
    key: "delete",
    value: function _delete() {
      if (this.fbo) {
        this.fbo.delete();
        this.fbo = null;
      }

      if (this.shadowMap) {
        this.shadowMap.delete();
        this.shadowMap = null;
      }

      if (this.depthBuffer) {
        this.depthBuffer.delete();
        this.depthBuffer = null;
      }
    }
  }]);
  return ShadowPass;
}(_layersPass.default);

exports.default = ShadowPass;

},{"./layers-pass":88,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/core":253}],93:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeShaderModules = initializeShaderModules;
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function get() {
    return _core.picking;
  }
});
Object.defineProperty(exports, "gouraudlighting", {
  enumerable: true,
  get: function get() {
    return _core.gouraudlighting;
  }
});
Object.defineProperty(exports, "phonglighting", {
  enumerable: true,
  get: function get() {
    return _core.phonglighting;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function get() {
    return _project.default;
  }
});
Object.defineProperty(exports, "project64", {
  enumerable: true,
  get: function get() {
    return _project3.default;
  }
});
Object.defineProperty(exports, "shadow", {
  enumerable: true,
  get: function get() {
    return _shadow.default;
  }
});

var _core = require("@luma.gl/core");

var _geometry = _interopRequireDefault(require("./misc/geometry"));

var _project = _interopRequireDefault(require("./project/project"));

var _project2 = _interopRequireDefault(require("./project32/project32"));

var _project3 = _interopRequireDefault(require("./project64/project64"));

var _shadow = _interopRequireDefault(require("./shadow/shadow"));

function initializeShaderModules() {
  (0, _core.registerShaderModules)([_core.fp32, _project.default, _project2.default, _core.gouraudlighting, _core.phonglighting, _core.picking]);
  (0, _core.setDefaultShaderModules)([_geometry.default, _project.default]);
  (0, _core.createShaderHook)('vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)');
  (0, _core.createShaderHook)('vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)');
  (0, _core.createShaderHook)('vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)');
  (0, _core.createShaderHook)('fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)');
  (0, _core.createModuleInjection)('picking', {
    hook: 'fs:DECKGL_FILTER_COLOR',
    order: 99,
    injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n"
  });
}

},{"./misc/geometry":94,"./project/project":101,"./project32/project32":95,"./project64/project64":97,"./shadow/shadow":103,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var vs = "\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n} geometry;\n";
var fs = "\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n";
var _default = {
  name: 'geometry',
  vs: vs,
  fs: fs
};
exports.default = _default;

},{}],95:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _project = _interopRequireDefault(require("../project/project"));

var vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64xyLow);\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64xyLow, offset, commonPosition);\n}\n";
var _default = {
  name: 'project32',
  dependencies: [_project.default],
  vs: vs
};
exports.default = _default;

},{"../project/project":101,"@babel/runtime/helpers/interopRequireDefault":25}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project64_uScale;\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sub_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  vec2 x_fp64 = mul_fp64(pos_fp64[0], project64_uScale);\n  vec2 y_fp64 = mul_fp64(pos_fp64[1], project64_uScale);\n  out_val[0] = mul_fp64(x_fp64, WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(y_fp64, WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\nvec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  return project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n";
exports.default = _default;

},{}],97:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _project = _interopRequireDefault(require("../project/project"));

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

var _project2 = _interopRequireDefault(require("./project64.glsl"));

var fp64ify = _core.fp64.fp64ify,
    fp64ifyMatrix4 = _core.fp64.fp64ifyMatrix4;
var _default = {
  name: 'project64',
  dependencies: [_project.default, _core.fp64],
  vs: _project2.default,
  getUniforms: getUniforms,
  deprecations: [{
    type: 'function',
    old: 'project_to_clipspace_fp64',
    new: 'project_common_position_to_clipspace_fp64'
  }]
};
exports.default = _default;
var DEFAULT_MODULE_OPTIONS = {};
var getMemoizedUniforms = (0, _memoize.default)(calculateUniforms);

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var project_uViewProjectionMatrix = context.project_uViewProjectionMatrix,
      project_uScale = context.project_uScale;

  if (project_uViewProjectionMatrix && project_uScale) {
    return getMemoizedUniforms({
      project_uViewProjectionMatrix: project_uViewProjectionMatrix,
      project_uScale: project_uScale
    });
  }

  return {};
}

function calculateUniforms(_ref) {
  var project_uViewProjectionMatrix = _ref.project_uViewProjectionMatrix,
      project_uScale = _ref.project_uScale;
  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(project_uViewProjectionMatrix);
  var scaleFP64 = fp64ify(project_uScale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}

},{"../../utils/memoize":119,"../project/project":101,"./project64.glsl":96,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECT_COORDINATE_SYSTEM = void 0;
var PROJECT_COORDINATE_SYSTEM = {
  LNG_LAT: 1.0,
  LNGLAT_AUTO_OFFSET: 4.0,
  METER_OFFSETS: 2.0,
  LNGLAT_OFFSETS: 3.0,
  IDENTITY: 0.0
};
exports.PROJECT_COORDINATE_SYSTEM = PROJECT_COORDINATE_SYSTEM;

},{}],99:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorldPosition = getWorldPosition;
exports.projectPosition = projectPosition;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _constants = require("../../lib/constants");

var _viewportUniforms = require("./viewport-uniforms");

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _viewportMercatorProject = require("viewport-mercator-project");

function lngLatZToWorldPosition(lngLatZ, viewport) {
  var offsetMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var _lngLatZ = (0, _slicedToArray2.default)(lngLatZ, 3),
      longitude = _lngLatZ[0],
      latitude = _lngLatZ[1],
      _lngLatZ$ = _lngLatZ[2],
      z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;

  var _viewport$projectFlat = viewport.projectFlat(lngLatZ),
      _viewport$projectFlat2 = (0, _slicedToArray2.default)(_viewport$projectFlat, 2),
      X = _viewport$projectFlat2[0],
      Y = _viewport$projectFlat2[1];

  var distanceScales = offsetMode ? (0, _viewportMercatorProject.getDistanceScales)({
    longitude: longitude,
    latitude: latitude,
    scale: viewport.scale
  }) : viewport.getDistanceScales();
  var Z = z * distanceScales.pixelsPerMeter[2];
  return [X, Y, Z];
}

function normalizeParameters(opts) {
  var normalizedParams = Object.assign({}, opts);
  var viewport = opts.viewport,
      coordinateSystem = opts.coordinateSystem,
      coordinateOrigin = opts.coordinateOrigin,
      fromCoordinateSystem = opts.fromCoordinateSystem,
      fromCoordinateOrigin = opts.fromCoordinateOrigin;

  if (fromCoordinateSystem === undefined) {
    normalizedParams.fromCoordinateSystem = coordinateSystem;
  }

  if (fromCoordinateOrigin === undefined) {
    normalizedParams.fromCoordinateOrigin = coordinateOrigin;
  }

  if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT && viewport.zoom >= _viewportUniforms.LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD) {
    normalizedParams.coordinateSystem = _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS;
    normalizedParams.coordinateOrigin = [Math.fround(viewport.longitude), Math.fround(viewport.latitude)];
  }

  return normalizedParams;
}

function getWorldPosition(position, _ref) {
  var viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix,
      coordinateSystem = _ref.coordinateSystem,
      coordinateOrigin = _ref.coordinateOrigin,
      offsetMode = _ref.offsetMode;

  var _position = (0, _slicedToArray2.default)(position, 3),
      x = _position[0],
      y = _position[1],
      z = _position[2];

  if (modelMatrix) {
    var _vec4$transformMat = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);

    var _vec4$transformMat2 = (0, _slicedToArray2.default)(_vec4$transformMat, 3);

    x = _vec4$transformMat2[0];
    y = _vec4$transformMat2[1];
    z = _vec4$transformMat2[2];
  }

  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition((0, _viewportMercatorProject.addMetersToLngLat)(coordinateOrigin, [x, y, z]), viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.IDENTITY:
    default:
      return viewport.projectPosition([x, y, z]);
  }
}

function projectPosition(position, params) {
  var _normalizeParameters = normalizeParameters(params),
      viewport = _normalizeParameters.viewport,
      coordinateSystem = _normalizeParameters.coordinateSystem,
      coordinateOrigin = _normalizeParameters.coordinateOrigin,
      modelMatrix = _normalizeParameters.modelMatrix,
      fromCoordinateSystem = _normalizeParameters.fromCoordinateSystem,
      fromCoordinateOrigin = _normalizeParameters.fromCoordinateOrigin;

  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      {
        var worldPosition = getWorldPosition(position, {
          viewport: viewport,
          modelMatrix: modelMatrix,
          coordinateSystem: fromCoordinateSystem,
          coordinateOrigin: fromCoordinateOrigin,
          offsetMode: true
        });
        var originWorld = lngLatZToWorldPosition(coordinateOrigin, viewport, true);
        vec3.sub(worldPosition, worldPosition, originWorld);
        return worldPosition;
      }

    case _constants.COORDINATE_SYSTEM.LNGLAT:
    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
    case _constants.COORDINATE_SYSTEM.IDENTITY:
    default:
      return getWorldPosition(position, {
        viewport: viewport,
        modelMatrix: modelMatrix,
        coordinateSystem: fromCoordinateSystem,
        coordinateOrigin: fromCoordinateOrigin,
        offsetMode: false
      });
  }
}

},{"../../lib/constants":65,"./viewport-uniforms":102,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/slicedToArray":37,"gl-matrix/vec3":410,"gl-matrix/vec4":411,"viewport-mercator-project":461}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("./constants");

var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(_constants.PROJECT_COORDINATE_SYSTEM).map(function (key) {
  return "const float COORDINATE_SYSTEM_".concat(key, " = ").concat(_constants.PROJECT_COORDINATE_SYSTEM[key], ".;");
}).join('');

var _default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n\nuniform float project_uCoordinateSystem;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform float project_uAntimeridian;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec2 ZERO_64_XY_LOW = vec2(0.0, 0.0);\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z;\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy;\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter;\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\n    dy = clamp(dy, -1., 1.);\n  }\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x - project_uAntimeridian, 360.0) + project_uAntimeridian;\n  }\n  return vec2(\n    radians(x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\nvec4 project_position(vec4 position, vec2 position64xyLow) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT) {\n    return project_uModelMatrix * vec4(\n      project_mercator_(position.xy) * WORLD_SCALE * project_uScale,\n      project_size(position.z),\n      position.w\n    );\n  }\n\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\n    float X = position.x - project_uCoordinateOrigin.x;\n    float Y = position.y - project_uCoordinateOrigin.y;\n    return project_offset_(vec4(X + position64xyLow.x, Y + position64xyLow.y, position.z, position.w));\n  }\n\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return project_offset_(position);\n  }\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_IDENTITY) {\n    position_world.xyz -= project_uCoordinateOrigin;\n    position_world += project_uModelMatrix * vec4(position64xyLow, 0.0, 0.0);\n  }\n\n  return project_offset_(position_world);\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_XY_LOW);\n}\n\nvec3 project_position(vec3 position, vec2 position64xyLow) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64xyLow);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_XY_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_XY_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_METER_OFFSETS ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    position.w *= project_uCommonUnitsPerMeter.z;\n  }\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters);\n}\nfloat project_pixel_size(float pixels) {\n  return pixels;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels;\n}\nfloat project_scale(float meters) {\n  return project_size(meters);\n}\nvec2 project_scale(vec2 meters) {\n  return project_size(meters);\n}\nvec3 project_scale(vec3 meters) {\n  return project_size(meters);\n}\nvec4 project_scale(vec4 meters) {\n  return project_size(meters);\n}\nvec4 project_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position);\n}\nvec4 project_pixel_to_clipspace(vec2 pixels) {\n  return vec4(project_pixel_size_to_clipspace(pixels), 0.0, 0.0);\n}\n");

exports.default = _default;

},{"./constants":98}],101:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _project = _interopRequireDefault(require("./project.glsl"));

var _viewportUniforms = require("./viewport-uniforms");

var INITIAL_MODULE_OPTIONS = {};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if (opts.viewport) {
    return (0, _viewportUniforms.getUniformsFromViewport)(opts);
  }

  return {};
}

var _default = {
  name: 'project',
  dependencies: [_core.fp32],
  vs: _project.default,
  getUniforms: getUniforms,
  deprecations: [{
    type: 'function',
    old: 'project_scale',
    new: 'project_size'
  }, {
    type: 'function',
    old: 'project_to_clipspace',
    new: 'project_common_position_to_clipspace'
  }, {
    type: 'function',
    old: 'project_pixel_to_clipspace',
    new: 'project_pixel_size_to_clipspace'
  }]
};
exports.default = _default;

},{"./project.glsl":100,"./viewport-uniforms":102,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],102:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUniformsFromViewport = getUniformsFromViewport;
exports.LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = void 0;

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var _constants = require("../../lib/constants");

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

var _assert = _interopRequireDefault(require("../../utils/assert"));

var _constants2 = require("./constants");

var ZERO_VECTOR = [0, 0, 0, 0];
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
var LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = 12;
exports.LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD;
var getMemoizedViewportUniforms = (0, _memoize.default)(calculateViewportUniforms);

function getShaderCoordinateSystem(coordinateSystem) {
  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
    default:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET;

    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT;

    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
    case _constants.COORDINATE_SYSTEM.METERS:
      return _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS;

    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS;

    case _constants.COORDINATE_SYSTEM.IDENTITY:
      return _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY;
  }
}

function calculateMatrixAndOffset(_ref) {
  var viewport = _ref.viewport,
      coordinateSystem = _ref.coordinateSystem,
      coordinateOrigin = _ref.coordinateOrigin,
      coordinateZoom = _ref.coordinateZoom;
  var viewMatrixUncentered = viewport.viewMatrixUncentered;
  var viewMatrix = viewport.viewMatrix;
  var projectionMatrix = viewport.projectionMatrix;
  var viewProjectionMatrix = viewport.viewProjectionMatrix;
  var projectionCenter;
  var cameraPosCommon = viewport.cameraPosition;
  var shaderCoordinateSystem = getShaderCoordinateSystem(coordinateSystem);
  var shaderCoordinateOrigin = coordinateOrigin;

  if (shaderCoordinateSystem === _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET) {
    if (coordinateZoom < LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD) {
      shaderCoordinateSystem = _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT;
    } else {
      var lng = Math.fround(viewport.longitude);
      var lat = Math.fround(viewport.latitude);
      shaderCoordinateOrigin = [lng, lat];
    }
  }

  if (shaderCoordinateSystem === _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY) {
    shaderCoordinateOrigin = [Math.fround(viewport.position[0]), Math.fround(viewport.position[1])];
  }

  shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;

  switch (shaderCoordinateSystem) {
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT:
      projectionCenter = ZERO_VECTOR;
      break;

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:
    case _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:
    case _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY:
      var positionCommonSpace = viewport.projectPosition(shaderCoordinateOrigin, Math.pow(2, coordinateZoom));
      cameraPosCommon = [cameraPosCommon[0] - positionCommonSpace[0], cameraPosCommon[1] - positionCommonSpace[1], cameraPosCommon[2] - positionCommonSpace[2]];
      positionCommonSpace[3] = 1;
      projectionCenter = vec4.transformMat4([], positionCommonSpace, viewProjectionMatrix);
      viewMatrix = viewMatrixUncentered || viewMatrix;
      viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPosCommon: cameraPosCommon,
    shaderCoordinateSystem: shaderCoordinateSystem,
    shaderCoordinateOrigin: shaderCoordinateOrigin
  };
}

function getUniformsFromViewport() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref2.viewport,
      _ref2$devicePixelRati = _ref2.devicePixelRatio,
      devicePixelRatio = _ref2$devicePixelRati === void 0 ? 1 : _ref2$devicePixelRati,
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === void 0 ? null : _ref2$modelMatrix,
      _ref2$coordinateSyste = _ref2.coordinateSystem,
      coordinateSystem = _ref2$coordinateSyste === void 0 ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,
      _ref2$coordinateOrigi = _ref2.coordinateOrigin,
      coordinateOrigin = _ref2$coordinateOrigi === void 0 ? DEFAULT_COORDINATE_ORIGIN : _ref2$coordinateOrigi,
      _ref2$wrapLongitude = _ref2.wrapLongitude,
      wrapLongitude = _ref2$wrapLongitude === void 0 ? false : _ref2$wrapLongitude,
      projectionMode = _ref2.projectionMode,
      positionOrigin = _ref2.positionOrigin;

  (0, _assert.default)(viewport);
  return Object.assign({
    project_uModelMatrix: modelMatrix || IDENTITY_MATRIX
  }, getMemoizedViewportUniforms({
    viewport: viewport,
    devicePixelRatio: devicePixelRatio,
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    wrapLongitude: wrapLongitude
  }));
}

function calculateViewportUniforms(_ref3) {
  var viewport = _ref3.viewport,
      devicePixelRatio = _ref3.devicePixelRatio,
      coordinateSystem = _ref3.coordinateSystem,
      coordinateOrigin = _ref3.coordinateOrigin,
      wrapLongitude = _ref3.wrapLongitude;
  var coordinateZoom = viewport.zoom;

  var _calculateMatrixAndOf = calculateMatrixAndOffset({
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    coordinateZoom: coordinateZoom,
    viewport: viewport
  }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPosCommon = _calculateMatrixAndOf.cameraPosCommon,
      shaderCoordinateSystem = _calculateMatrixAndOf.shaderCoordinateSystem,
      shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin;

  (0, _assert.default)(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');
  var distanceScales = viewport.getDistanceScales();
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  var uniforms = {
    project_uCoordinateSystem: shaderCoordinateSystem,
    project_uCenter: projectionCenter,
    project_uWrapLongitude: wrapLongitude,
    project_uAntimeridian: (viewport.longitude || 0) - 180,
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uCommonUnitsPerMeter: distanceScales.pixelsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.pixelsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uCameraPosition: cameraPosCommon
  };
  var distanceScalesAtOrigin = viewport.getDistanceScales(shaderCoordinateOrigin);

  switch (shaderCoordinateSystem) {
    case _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:
      uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.pixelsPerMeter;
      uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;
      break;

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:
      uniforms.project_uCoordinateOrigin = shaderCoordinateOrigin;

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT:
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.pixelsPerDegree;
      uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.pixelsPerDegree2;
      break;

    case _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY:
      uniforms.project_uCoordinateOrigin = shaderCoordinateOrigin;
      break;

    default:
      break;
  }

  return uniforms;
}

},{"../../lib/constants":65,"../../utils/assert":109,"../../utils/memoize":119,"./constants":98,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"gl-matrix/mat4":407,"gl-matrix/vec4":411}],103:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _core = require("@luma.gl/core");

var _constants = require("../project/constants");

var _math = require("math.gl");

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

var _viewportMercatorProject = require("viewport-mercator-project");

var vs = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
var fs = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
var moduleName = 'shadow';
var getMemoizedViewportCenterPosition = (0, _memoize.default)(getViewportCenterPosition);
var getMemoizedViewProjectionMatrices = (0, _memoize.default)(getViewProjectionMatrices);
(0, _core.createModuleInjection)(moduleName, {
  hook: 'vs:DECKGL_FILTER_GL_POSITION',
  injection: "\nposition = shadow_setVertexPosition(geometry.position);\n  "
});
(0, _core.createModuleInjection)(moduleName, {
  hook: 'fs:DECKGL_FILTER_COLOR',
  injection: "\ncolor = shadow_filterShadowColor(color);\n  "
});
var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  var _xyz = (0, _slicedToArray2.default)(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      z = _xyz[2];

  var coord = (0, _viewportMercatorProject.pixelsToWorld)([x, y, z], pixelUnprojectionMatrix);

  if (Number.isFinite(z)) {
    return coord;
  }

  return [coord[0], coord[1], 0];
}

function getViewportCenterPosition(_ref) {
  var viewport = _ref.viewport,
      center = _ref.center;
  return new _math.Matrix4(viewport.viewProjectionMatrix).invert().transformVector4(center);
}

function getViewProjectionMatrices(_ref2) {
  var viewport = _ref2.viewport,
      shadowMatrices = _ref2.shadowMatrices;
  var projectionMatrices = [];
  var pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  var farZ = viewport.isGeospatial ? undefined : 1;
  var corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(function (pixel) {
    return screenToCommonSpace(pixel, pixelUnprojectionMatrix);
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var shadowMatrix = _step.value;
      var viewMatrix = shadowMatrix.clone().translate(new _math.Vector3(viewport.center).negate());
      var positions = corners.map(function (corner) {
        return viewMatrix.transformVector3(corner);
      });
      var projectionMatrix = new _math.Matrix4().ortho({
        left: Math.min.apply(Math, (0, _toConsumableArray2.default)(positions.map(function (position) {
          return position[0];
        }))),
        right: Math.max.apply(Math, (0, _toConsumableArray2.default)(positions.map(function (position) {
          return position[0];
        }))),
        bottom: Math.min.apply(Math, (0, _toConsumableArray2.default)(positions.map(function (position) {
          return position[1];
        }))),
        top: Math.max.apply(Math, (0, _toConsumableArray2.default)(positions.map(function (position) {
          return position[1];
        }))),
        near: Math.min.apply(Math, (0, _toConsumableArray2.default)(positions.map(function (position) {
          return -position[2];
        }))),
        far: Math.max.apply(Math, (0, _toConsumableArray2.default)(positions.map(function (position) {
          return -position[2];
        })))
      });
      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    };

    for (var _iterator = shadowMatrices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return projectionMatrices;
}

function createShadowUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var uniforms = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  var center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  var projectCenters = [];
  var viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();

  for (var i = 0; i < opts.shadowMatrices.length; i++) {
    var viewProjectionMatrix = viewProjectionMatrices[i];
    var viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new _math.Vector3(opts.viewport.center).negate());

    if (context.project_uCoordinateSystem === _constants.PROJECT_COORDINATE_SYSTEM.LNG_LAT) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = [0, 0, 0, 0];
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);
      projectCenters[i] = viewProjectionMatrixCentered.transformVector4(center);
    }
  }

  for (var _i = 0; _i < viewProjectionMatrices.length; _i++) {
    uniforms["shadow_uViewProjectionMatrices[".concat(_i, "]")] = viewProjectionMatrices[_i];
    uniforms["shadow_uProjectCenters[".concat(_i, "]")] = projectCenters[_i];

    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms["shadow_uShadowMap".concat(_i)] = opts.shadowMaps[_i];
    } else {
      uniforms["shadow_uShadowMap".concat(_i)] = opts.dummyShadowMap;
    }
  }

  return uniforms;
}

var _default = {
  name: 'shadow',
  dependencies: ['project'],
  vs: vs,
  fs: fs,
  getUniforms: function getUniforms() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0) {
      var shadowUniforms = {};
      var _opts$shadowEnabled = opts.shadowEnabled,
          shadowEnabled = _opts$shadowEnabled === void 0 ? true : _opts$shadowEnabled;

      if (shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0) {
        Object.assign(shadowUniforms, createShadowUniforms(opts, context));
      } else {
        Object.assign(shadowUniforms, {
          shadow_uDrawShadowMap: false,
          shadow_uUseShadowMap: false
        });
      }

      return shadowUniforms;
    }

    return {};
  }
};
exports.default = _default;

},{"../../utils/memoize":119,"../project/constants":98,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37,"@babel/runtime/helpers/toConsumableArray":39,"@luma.gl/core":253,"math.gl":415,"viewport-mercator-project":461}],104:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));

var _math = require("math.gl");

var VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];

var LinearInterpolator = function (_TransitionInterpolat) {
  (0, _inherits2.default)(LinearInterpolator, _TransitionInterpolat);

  function LinearInterpolator() {
    var transitionProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : VIEWPORT_TRANSITION_PROPS;
    (0, _classCallCheck2.default)(this, LinearInterpolator);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LinearInterpolator).call(this, transitionProps));
  }

  (0, _createClass2.default)(LinearInterpolator, [{
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      var viewport = {};

      for (var key in endProps) {
        viewport[key] = (0, _math.lerp)(startProps[key], endProps[key], t);
      }

      return viewport;
    }
  }]);
  return LinearInterpolator;
}(_transitionInterpolator.default);

exports.default = LinearInterpolator;

},{"./transition-interpolator":105,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],105:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _assert = _interopRequireDefault(require("../utils/assert"));

var TransitionInterpolator = function () {
  function TransitionInterpolator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, TransitionInterpolator);

    if (Array.isArray(opts)) {
      opts = {
        compare: opts,
        extract: opts,
        required: opts
      };
    }

    var _opts = opts,
        compare = _opts.compare,
        extract = _opts.extract,
        required = _opts.required;
    this._propsToCompare = compare;
    this._propsToExtract = extract;
    this._requiredProps = required;
  }

  (0, _createClass2.default)(TransitionInterpolator, [{
    key: "arePropsEqual",
    value: function arePropsEqual(currentProps, nextProps) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (this._propsToCompare || Object.keys(nextProps))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!(0, _math.equals)(currentProps[key], nextProps[key])) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return true;
    }
  }, {
    key: "initializeProps",
    value: function initializeProps(startProps, endProps) {
      var result;

      if (this._propsToExtract) {
        var startViewStateProps = {};
        var endViewStateProps = {};
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._propsToExtract[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var key = _step2.value;
            startViewStateProps[key] = startProps[key];
            endViewStateProps[key] = endProps[key];
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        result = {
          start: startViewStateProps,
          end: endViewStateProps
        };
      } else {
        result = {
          start: startProps,
          end: endProps
        };
      }

      this._checkRequiredProps(result.start);

      this._checkRequiredProps(result.end);

      return result;
    }
  }, {
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      (0, _assert.default)(false, 'interpolateProps is not implemented');
    }
  }, {
    key: "_checkRequiredProps",
    value: function _checkRequiredProps(props) {
      if (!this._requiredProps) {
        return;
      }

      this._requiredProps.forEach(function (propName) {
        var value = props[propName];
        (0, _assert.default)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
      });
    }
  }]);
  return TransitionInterpolator;
}();

exports.default = TransitionInterpolator;

},{"../utils/assert":109,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"math.gl":415}],106:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSITION_STATE = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var TRANSITION_STATE = {
  NONE: 'none',
  PENDING: 'pending',
  IN_PROGRESS: 'in_progress',
  ENDED: 'ended'
};
exports.TRANSITION_STATE = TRANSITION_STATE;

function noop() {}

var Transition = function () {
  function Transition(props) {
    (0, _classCallCheck2.default)(this, Transition);
    this._startTime = null;
    this._state = TRANSITION_STATE.NONE;
    this.duration = 1;

    this.easing = function (t) {
      return t;
    };

    this.onStart = noop;
    this.onUpdate = noop;
    this.onInterrupt = noop;
    this.onEnd = noop;
    Object.assign(this, props);
  }

  (0, _createClass2.default)(Transition, [{
    key: "start",
    value: function start(props) {
      if (this.inProgress) {
        this.onInterrupt(this);
      }

      Object.assign(this, props);

      this._setState(TRANSITION_STATE.PENDING);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this.inProgress) {
        this.onInterrupt(this);

        this._setState(TRANSITION_STATE.NONE);
      }
    }
  }, {
    key: "update",
    value: function update(currentTime) {
      if (this.state === TRANSITION_STATE.PENDING) {
        this._startTime = currentTime;

        this._setState(TRANSITION_STATE.IN_PROGRESS);
      }

      if (this.state === TRANSITION_STATE.IN_PROGRESS) {
        var shouldEnd = false;
        var time = (currentTime - this._startTime) / this.duration;

        if (time >= 1) {
          time = 1;
          shouldEnd = true;
        }

        this.time = this.easing(time);
        this.onUpdate(this);

        if (shouldEnd) {
          this._setState(TRANSITION_STATE.ENDED);
        }

        return true;
      }

      return false;
    }
  }, {
    key: "_setState",
    value: function _setState(newState) {
      if (this._state === newState) {
        return;
      }

      this._state = newState;

      switch (newState) {
        case TRANSITION_STATE.PENDING:
          this.onStart(this);
          break;

        case TRANSITION_STATE.ENDED:
          this.onEnd(this);
          break;

        default:
      }
    }
  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
  }, {
    key: "inProgress",
    get: function get() {
      return this._state === TRANSITION_STATE.PENDING || this._state === TRANSITION_STATE.IN_PROGRESS;
    }
  }]);
  return Transition;
}();

exports.default = Transition;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],107:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));

var _math = require("math.gl");

var _viewportMercatorProject = require("viewport-mercator-project");

var LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];

var FlyToInterpolator = function (_TransitionInterpolat) {
  (0, _inherits2.default)(FlyToInterpolator, _TransitionInterpolat);

  function FlyToInterpolator() {
    (0, _classCallCheck2.default)(this, FlyToInterpolator);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FlyToInterpolator).call(this, {
      compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      extract: ['width', 'height', 'longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      required: ['width', 'height', 'latitude', 'longitude', 'zoom']
    }));
  }

  (0, _createClass2.default)(FlyToInterpolator, [{
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      var viewport = (0, _viewportMercatorProject.flyToViewport)(startProps, endProps, t);

      for (var _i = 0; _i < LINEARLY_INTERPOLATED_PROPS.length; _i++) {
        var key = LINEARLY_INTERPOLATED_PROPS[_i];
        viewport[key] = (0, _math.lerp)(startProps[key] || 0, endProps[key] || 0, t);
      }

      return viewport;
    }
  }]);
  return FlyToInterpolator;
}(_transitionInterpolator.default);

exports.default = FlyToInterpolator;

},{"./transition-interpolator":105,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415,"viewport-mercator-project":461}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padArray = padArray;

function padArrayChunk(_ref) {
  var source = _ref.source,
      target = _ref.target,
      _ref$start = _ref.start,
      start = _ref$start === void 0 ? 0 : _ref$start,
      end = _ref.end,
      getData = _ref.getData;
  end = end || target.length;
  var sourceLength = source.length;
  var targetLength = end - start;

  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }

  target.set(source, start);

  if (!getData) {
    return;
  }

  var i = sourceLength;

  while (i < targetLength) {
    var datum = getData(i, source);

    for (var j = 0; j < datum.length; j++) {
      target[start + i] = datum[j];
      i++;
    }
  }
}

function padArray(_ref2) {
  var source = _ref2.source,
      target = _ref2.target,
      size = _ref2.size,
      _ref2$offset = _ref2.offset,
      offset = _ref2$offset === void 0 ? 0 : _ref2$offset,
      getData = _ref2.getData,
      sourceLayout = _ref2.sourceLayout,
      targetLayout = _ref2.targetLayout;

  if (!Array.isArray(targetLayout)) {
    padArrayChunk({
      source: source,
      target: target,
      getData: getData
    });
    return target;
  }

  var sourceIndex = offset;
  var targetIndex = offset;

  var getChunkData = getData && function (i, chunk) {
    return getData(i + targetIndex, chunk);
  };

  var n = Math.min(sourceLayout.length, targetLayout.length);

  for (var i = 0; i < n; i++) {
    var sourceChunkLength = sourceLayout[i] * size;
    var targetChunkLength = targetLayout[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, sourceIndex + sourceChunkLength),
      target: target,
      start: targetIndex,
      end: targetIndex + targetChunkLength,
      getData: getChunkData
    });
    sourceIndex += sourceChunkLength;
    targetIndex += targetChunkLength;
  }

  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target: target,
      start: targetIndex,
      getData: getChunkData
    });
  }

  return target;
}

},{}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'deck.gl: assertion failed.');
  }
}

},{}],110:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.count = count;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var ERR_NOT_OBJECT = 'count(): argument not an object';
var ERR_NOT_CONTAINER = 'count(): argument not a container';

function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }

  if (typeof container.count === 'function') {
    return container.count();
  }

  if (Number.isFinite(container.size)) {
    return container.size;
  }

  if (Number.isFinite(container.length)) {
    return container.length;
  }

  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }

  throw new Error(ERR_NOT_CONTAINER);
}

function isPlainObject(value) {
  return value !== null && (0, _typeof2.default)(value) === 'object' && value.constructor === Object;
}

function isObject(value) {
  return value !== null && (0, _typeof2.default)(value) === 'object';
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepEqual = deepEqual;

function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  return Object.keys(a).every(function (key) {
    if (Array.isArray(a[key]) && Array.isArray(b[key])) {
      return deepEqual(a[key], b[key]);
    }

    return a[key] === b[key];
  });
}

},{}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatten = flatten;
exports.flattenVertices = flattenVertices;
exports.fillArray = fillArray;

function flatten(array) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$filter = _ref.filter,
      filter = _ref$filter === void 0 ? function () {
    return true;
  } : _ref$filter,
      _ref$map = _ref.map,
      map = _ref$map === void 0 ? function (x) {
    return x;
  } : _ref$map,
      _ref$result = _ref.result,
      result = _ref$result === void 0 ? [] : _ref$result;

  if (!Array.isArray(array)) {
    return filter(array) ? [map(array)] : [];
  }

  return flattenArray(array, filter, map, result);
}

function flattenArray(array, filter, map, result) {
  var index = -1;

  while (++index < array.length) {
    var value = array[index];

    if (Array.isArray(value)) {
      flattenArray(value, filter, map, result);
    } else if (filter(value)) {
      result.push(map(value));
    }
  }

  return result;
}

function flattenVertices(nestedArray) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$result = _ref2.result,
      result = _ref2$result === void 0 ? [] : _ref2$result,
      _ref2$dimensions = _ref2.dimensions,
      dimensions = _ref2$dimensions === void 0 ? 3 : _ref2$dimensions;

  var index = -1;
  var vertexLength = 0;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      flattenVertices(value, {
        result: result,
        dimensions: dimensions
      });
    } else {
      if (vertexLength < dimensions) {
        result.push(value);
        vertexLength++;
      }
    }
  }

  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }

  return result;
}

function fillArray(_ref3) {
  var target = _ref3.target,
      source = _ref3.source,
      _ref3$start = _ref3.start,
      start = _ref3$start === void 0 ? 0 : _ref3$start,
      _ref3$count = _ref3.count,
      count = _ref3$count === void 0 ? 1 : _ref3$count;
  var length = source.length;
  var total = count * length;
  var copied = 0;

  for (var i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}

},{}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPixelRatio;

function getPixelRatio(useDevicePixels) {
  return useDevicePixels && typeof window !== 'undefined' ? window.devicePixelRatio : 1;
}

},{}],114:[function(require,module,exports){
(function (process,global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.document = exports.global = exports.window = exports.isBrowser = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var window_ = typeof window !== 'undefined' ? window : global;
exports.window = window_;
var global_ = typeof global !== 'undefined' ? global : window;
exports.global = global_;
var document_ = typeof document !== 'undefined' ? document : {};
exports.document = document_;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIterable = createIterable;
exports.isAsyncIterable = isAsyncIterable;
var EMPTY_ARRAY = [];
var placeholderArray = [];

function createIterable(data) {
  var startRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var endRow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  var iterable = EMPTY_ARRAY;
  var objectInfo = {
    index: -1,
    data: data,
    target: []
  };

  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === 'function') {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }

  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }

  return {
    iterable: iterable,
    objectInfo: objectInfo
  };
}

function isAsyncIterable(data) {
  return data && data[Symbol.asyncIterator];
}

},{}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function isJSON(text) {
  var firstChar = text[0];
  var lastChar = text[text.length - 1];
  return firstChar === '{' && lastChar === '}' || firstChar === '[' && lastChar === ']';
}

var _default = {
  name: 'JSON',
  extensions: ['json', 'geojson'],
  testText: isJSON,
  parseTextSync: JSON.parse
};
exports.default = _default;

},{}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _probe = require("probe.gl");

var _default = new _probe.Log({
  id: 'deck'
}).enable();

exports.default = _default;

},{"probe.gl":444}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMat4 = createMat4;
exports.extractCameraVectors = extractCameraVectors;
exports.getFrustumPlanes = getFrustumPlanes;
exports.fp64LowPart = fp64LowPart;

var _math = require("math.gl");

function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

function extractCameraVectors(_ref) {
  var viewMatrix = _ref.viewMatrix,
      viewMatrixInverse = _ref.viewMatrixInverse;
  return {
    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],
    direction: [-viewMatrix[2], -viewMatrix[6], -viewMatrix[10]],
    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]],
    right: [viewMatrix[0], viewMatrix[4], viewMatrix[8]]
  };
}

var cameraPosition = new _math.Vector3();
var cameraDirection = new _math.Vector3();
var cameraUp = new _math.Vector3();
var cameraRight = new _math.Vector3();
var nearCenter = new _math.Vector3();
var farCenter = new _math.Vector3();
var a = new _math.Vector3();

function getFrustumPlanes(_ref2) {
  var aspect = _ref2.aspect,
      near = _ref2.near,
      far = _ref2.far,
      fovyRadians = _ref2.fovyRadians,
      position = _ref2.position,
      direction = _ref2.direction,
      up = _ref2.up,
      right = _ref2.right;
  cameraDirection.copy(direction);
  var nearFarScale = 1 / cameraDirection.len();
  cameraDirection.normalize();
  cameraPosition.copy(position);
  cameraUp.copy(up).normalize();
  cameraRight.copy(right).normalize();
  var nearHeight = 2 * Math.tan(fovyRadians / 2) * near;
  var nearWidth = nearHeight * aspect;
  nearCenter.copy(cameraDirection).scale(near * nearFarScale).add(cameraPosition);
  farCenter.copy(cameraDirection).scale(far * nearFarScale).add(cameraPosition);
  var normal = cameraDirection.clone().negate();
  var distance = normal.dot(nearCenter);
  var planes = {
    near: {
      distance: distance,
      normal: normal
    },
    far: {
      distance: cameraDirection.dot(farCenter),
      normal: cameraDirection.clone()
    }
  };
  a.copy(cameraRight).scale(nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new _math.Vector3(cameraUp).cross(a);
  distance = cameraPosition.dot(normal);
  planes.right = {
    normal: normal,
    distance: distance
  };
  a.copy(cameraRight).scale(-nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new _math.Vector3(a).cross(cameraUp);
  distance = cameraPosition.dot(normal);
  planes.left = {
    normal: normal,
    distance: distance
  };
  a.copy(cameraUp).scale(nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new _math.Vector3(a).cross(cameraRight);
  distance = cameraPosition.dot(normal);
  planes.top = {
    normal: normal,
    distance: distance
  };
  a.copy(cameraUp).scale(-nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new _math.Vector3(cameraRight).cross(a);
  distance = cameraPosition.dot(normal);
  planes.bottom = {
    normal: normal,
    distance: distance
  };
  return planes;
}

function fp64LowPart(x) {
  return x - Math.fround(x);
}

},{"math.gl":415}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = memoize;

function isEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (Array.isArray(a)) {
    var len = a.length;

    if (!b || b.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}

function memoize(compute) {
  var cachedArgs = {};
  var cachedResult;
  return function (args) {
    for (var key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }

    return cachedResult;
  };
}

},{}],120:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePosition = parsePosition;
exports.getPosition = getPosition;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;

function parsePosition(value) {
  switch ((0, _typeof2.default)(value)) {
    case 'number':
      return {
        position: value,
        relative: false
      };

    case 'string':
      var match = value.match(PERCENT_OR_PIXELS_REGEX);

      if (match && match.length >= 3) {
        var relative = match[2] === '%';
        var position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative: relative
        };
      }

    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}

function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.FULL = exports.EMPTY = void 0;
var EMPTY = [];
exports.EMPTY = EMPTY;
var FULL = [[0, Infinity]];
exports.FULL = FULL;

function add(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }

  if (range[0] < 0) {
    range[0] = 0;
  }

  if (range[0] >= range[1]) {
    return rangeList;
  }

  var newRangeList = [];
  var len = rangeList.length;
  var insertPosition = 0;

  for (var i = 0; i < len; i++) {
    var range0 = rangeList[i];

    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }

  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}

},{}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeShaders = mergeShaders;

function mergeShaders(target, source) {
  if (!source) {
    return target;
  }

  var result = Object.assign({}, target, source);

  if ('defines' in source) {
    result.defines = Object.assign({}, target.defines, source.defines);
  }

  if ('modules' in source) {
    result.modules = (target.modules || []).concat(source.modules);

    if (source.modules.some(function (module) {
      return module === 'project64' || module.name === 'project64';
    })) {
      var index = result.modules.findIndex(function (module) {
        return module === 'project32' || module.name === 'project32';
      });

      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }

  if ('inject' in source) {
    result.inject = Object.assign({}, target.inject, source.inject);
  }

  return result;
}

},{}],123:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _iterableUtils = require("./iterable-utils");

var _typedArrayManager = _interopRequireDefault(require("./typed-array-manager"));

var Tesselator = function () {
  function Tesselator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Tesselator);
    var _opts$attributes = opts.attributes,
        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;
    this.typedArrayManager = _typedArrayManager.default;
    this.indexLayout = null;
    this.bufferLayout = null;
    this.vertexCount = 0;
    this.instanceCount = 0;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.updateGeometry(opts);
    Object.seal(this);
  }

  (0, _createClass2.default)(Tesselator, [{
    key: "updateGeometry",
    value: function updateGeometry(_ref) {
      var data = _ref.data,
          getGeometry = _ref.getGeometry,
          positionFormat = _ref.positionFormat,
          fp64 = _ref.fp64,
          dataChanged = _ref.dataChanged;
      this.data = data;
      this.getGeometry = getGeometry;
      this.fp64 = fp64;
      this.positionSize = positionFormat === 'XY' ? 2 : 3;

      if (Array.isArray(dataChanged)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = dataChanged[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dataRange = _step.value;

            this._rebuildGeometry(dataRange);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        this._rebuildGeometry();
      }
    }
  }, {
    key: "updatePartialGeometry",
    value: function updatePartialGeometry(_ref2) {
      var startRow = _ref2.startRow,
          endRow = _ref2.endRow;

      this._rebuildGeometry({
        startRow: startRow,
        endRow: endRow
      });
    }
  }, {
    key: "updateGeometryAttributes",
    value: function updateGeometryAttributes(geometry, startIndex, size) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getGeometrySize",
    value: function getGeometrySize(geometry) {
      throw new Error('Not implemented');
    }
  }, {
    key: "_forEachGeometry",
    value: function _forEachGeometry(visitor, startRow, endRow) {
      var data = this.data,
          getGeometry = this.getGeometry;

      var _createIterable = (0, _iterableUtils.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;
          objectInfo.index++;
          var geometry = getGeometry(object, objectInfo);
          visitor(geometry, objectInfo.index);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "_rebuildGeometry",
    value: function _rebuildGeometry(dataRange) {
      var _this = this;

      if (!this.data || !this.getGeometry) {
        return;
      }

      var indexLayout = this.indexLayout,
          bufferLayout = this.bufferLayout;

      if (!dataRange) {
        indexLayout = [];
        bufferLayout = [];
      }

      var _ref3 = dataRange || {},
          _ref3$startRow = _ref3.startRow,
          startRow = _ref3$startRow === void 0 ? 0 : _ref3$startRow,
          _ref3$endRow = _ref3.endRow,
          endRow = _ref3$endRow === void 0 ? Infinity : _ref3$endRow;

      this._forEachGeometry(function (geometry, dataIndex) {
        bufferLayout[dataIndex] = _this.getGeometrySize(geometry);
      }, startRow, endRow);

      var instanceCount = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = bufferLayout[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var count = _step3.value;
          instanceCount += count;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var attributes = this.attributes,
          _attributeDefs = this._attributeDefs,
          typedArrayManager = this.typedArrayManager,
          fp64 = this.fp64;

      for (var name in _attributeDefs) {
        var def = _attributeDefs[name];
        def.copy = Boolean(dataRange);

        if (!def.fp64Only || fp64) {
          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
        }
      }

      this.indexLayout = indexLayout;
      this.bufferLayout = bufferLayout;
      this.instanceCount = instanceCount;
      var context = {
        vertexStart: 0,
        indexStart: 0
      };

      for (var i = 0; i < startRow; i++) {
        context.vertexStart += bufferLayout[i];
        context.indexStart += indexLayout[i] || 0;
      }

      this._forEachGeometry(function (geometry, dataIndex) {
        var geometrySize = bufferLayout[dataIndex];
        context.geometryIndex = dataIndex;
        context.geometrySize = geometrySize;

        _this.updateGeometryAttributes(geometry, context);

        context.vertexStart += geometrySize;
        context.indexStart += indexLayout[dataIndex] || 0;
      }, startRow, endRow);

      var vertexCount = context.indexStart;

      for (var _i = endRow; _i < indexLayout.length; _i++) {
        vertexCount += indexLayout[_i];
      }

      this.vertexCount = vertexCount;
    }
  }]);
  return Tesselator;
}();

exports.default = Tesselator;

},{"./iterable-utils":115,"./typed-array-manager":124,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TypedArrayManager = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var TypedArrayManager = function () {
  function TypedArrayManager() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$overAlloc = _ref.overAlloc,
        overAlloc = _ref$overAlloc === void 0 ? 2 : _ref$overAlloc,
        _ref$poolSize = _ref.poolSize,
        poolSize = _ref$poolSize === void 0 ? 100 : _ref$poolSize;

    (0, _classCallCheck2.default)(this, TypedArrayManager);
    this.overAlloc = overAlloc;
    this.poolSize = poolSize;
    this._pool = [];
  }

  (0, _createClass2.default)(TypedArrayManager, [{
    key: "allocate",
    value: function allocate(typedArray, count, _ref2) {
      var _ref2$size = _ref2.size,
          size = _ref2$size === void 0 ? 1 : _ref2$size,
          type = _ref2.type,
          _ref2$padding = _ref2.padding,
          padding = _ref2$padding === void 0 ? 0 : _ref2$padding,
          _ref2$copy = _ref2.copy,
          copy = _ref2$copy === void 0 ? false : _ref2$copy;
      var Type = type || typedArray && typedArray.constructor || Float32Array;
      var newSize = count * size + padding;

      if (ArrayBuffer.isView(typedArray)) {
        if (newSize <= typedArray.length) {
          return typedArray;
        }

        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
          return new Type(typedArray.buffer, 0, newSize);
        }
      }

      var newArray = this._allocate(Type, newSize);

      if (typedArray && copy) {
        newArray.set(typedArray);
      } else {
        newArray.fill(0, 0, 4);
      }

      this._release(typedArray);

      return newArray;
    }
  }, {
    key: "release",
    value: function release(typedArray) {
      this._release(typedArray);
    }
  }, {
    key: "_allocate",
    value: function _allocate(Type, size) {
      size = Math.max(Math.ceil(size * this.overAlloc), 1);
      var pool = this._pool;
      var byteLength = Type.BYTES_PER_ELEMENT * size;
      var i = pool.findIndex(function (b) {
        return b.byteLength >= byteLength;
      });

      if (i >= 0) {
        return new Type(pool.splice(i, 1)[0], 0, size);
      }

      return new Type(size);
    }
  }, {
    key: "_release",
    value: function _release(typedArray) {
      if (!ArrayBuffer.isView(typedArray)) {
        return;
      }

      var pool = this._pool;
      var buffer = typedArray.buffer;
      var byteLength = buffer.byteLength;
      var i = pool.findIndex(function (b) {
        return b.byteLength >= byteLength;
      });

      if (i < 0) {
        pool.push(buffer);
      } else if (i > 0 || pool.length < this.poolSize) {
        pool.splice(i, 0, buffer);
      }

      if (pool.length > this.poolSize) {
        pool.shift();
      }
    }
  }]);
  return TypedArrayManager;
}();

exports.TypedArrayManager = TypedArrayManager;

var _default = new TypedArrayManager();

exports.default = _default;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],125:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _log = _interopRequireDefault(require("../utils/log"));

var _mathUtils = require("../utils/math-utils");

var _math = require("math.gl");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var _viewportMercatorProject = require("viewport-mercator-project");

var _assert = _interopRequireDefault(require("../utils/assert"));

var DEGREES_TO_RADIANS = Math.PI / 180;
var IDENTITY = (0, _mathUtils.createMat4)();
var ZERO_VECTOR = [0, 0, 0];
var DEFAULT_ZOOM = 0;
var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  function Viewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Viewport);
    var _opts$id = opts.id,
        id = _opts$id === void 0 ? null : _opts$id,
        _opts$x = opts.x,
        x = _opts$x === void 0 ? 0 : _opts$x,
        _opts$y = opts.y,
        y = _opts$y === void 0 ? 0 : _opts$y,
        _opts$width = opts.width,
        width = _opts$width === void 0 ? 1 : _opts$width,
        _opts$height = opts.height,
        height = _opts$height === void 0 ? 1 : _opts$height;
    this.id = id || this.constructor.displayName || 'viewport';
    this.x = x;
    this.y = y;
    this.width = width || 1;
    this.height = height || 1;
    this._frustumPlanes = {};

    this._initViewMatrix(opts);

    this._initProjectionMatrix(opts);

    this._initPixelMatrices();

    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  }

  (0, _createClass2.default)(Viewport, [{
    key: "equals",
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix);
    }
  }, {
    key: "project",
    value: function project(xyz) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$topLeft = _ref.topLeft,
          topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft;

      var worldPosition = this.projectPosition(xyz);
      var coord = (0, _viewportMercatorProject.worldToPixels)(worldPosition, this.pixelProjectionMatrix);

      var _coord = (0, _slicedToArray2.default)(coord, 2),
          x = _coord[0],
          y = _coord[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }
  }, {
    key: "unproject",
    value: function unproject(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft,
          targetZ = _ref2.targetZ;

      var _xyz = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          z = _xyz[2];

      var y2 = topLeft ? y : this.height - y;
      var targetZWorld = targetZ && targetZ * this.distanceScales.pixelsPerMeter[2];
      var coord = (0, _viewportMercatorProject.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);

      var _this$unprojectPositi = this.unprojectPosition(coord),
          _this$unprojectPositi2 = (0, _slicedToArray2.default)(_this$unprojectPositi, 3),
          X = _this$unprojectPositi2[0],
          Y = _this$unprojectPositi2[1],
          Z = _this$unprojectPositi2[2];

      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }

      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
  }, {
    key: "projectPosition",
    value: function projectPosition(xyz) {
      var _this$projectFlat = this.projectFlat(xyz),
          _this$projectFlat2 = (0, _slicedToArray2.default)(_this$projectFlat, 2),
          X = _this$projectFlat2[0],
          Y = _this$projectFlat2[1];

      var Z = (xyz[2] || 0) * this.distanceScales.pixelsPerMeter[2];
      return [X, Y, Z];
    }
  }, {
    key: "unprojectPosition",
    value: function unprojectPosition(xyz) {
      var _this$unprojectFlat = this.unprojectFlat(xyz),
          _this$unprojectFlat2 = (0, _slicedToArray2.default)(_this$unprojectFlat, 2),
          X = _this$unprojectFlat2[0],
          Y = _this$unprojectFlat2[1];

      var Z = (xyz[2] || 0) * this.distanceScales.metersPerPixel[2];
      return [X, Y, Z];
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      if (this.isGeospatial) {
        return (0, _viewportMercatorProject.lngLatToWorld)(xyz, scale);
      }

      var pixelsPerMeter = this.distanceScales.pixelsPerMeter;
      return [xyz[0] * pixelsPerMeter[0], xyz[1] * pixelsPerMeter[1]];
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      if (this.isGeospatial) {
        return (0, _viewportMercatorProject.worldToLngLat)(xyz, scale);
      }

      var metersPerPixel = this.distanceScales.metersPerPixel;
      return [xyz[0] * metersPerPixel[0], xyz[1] * metersPerPixel[1]];
    }
  }, {
    key: "getDistanceScales",
    value: function getDistanceScales() {
      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (coordinateOrigin) {
        return (0, _viewportMercatorProject.getDistanceScales)({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          scale: this.scale,
          highPrecision: true
        });
      }

      return this.distanceScales;
    }
  }, {
    key: "getMatrices",
    value: function getMatrices() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$modelMatrix = _ref3.modelMatrix,
          modelMatrix = _ref3$modelMatrix === void 0 ? null : _ref3$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = mat4.multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = mat4.multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = mat4.invert([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,
        width: this.width,
        height: this.height,
        scale: this.scale
      });
      return matrices;
    }
  }, {
    key: "containsPixel",
    value: function containsPixel(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          _ref4$width = _ref4.width,
          width = _ref4$width === void 0 ? 1 : _ref4$width,
          _ref4$height = _ref4.height,
          height = _ref4$height === void 0 ? 1 : _ref4$height;
      return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
    }
  }, {
    key: "getFrustumPlanes",
    value: function getFrustumPlanes() {
      if (this._frustumPlanes.near) {
        return this._frustumPlanes;
      }

      var _this$projectionProps = this.projectionProps,
          near = _this$projectionProps.near,
          far = _this$projectionProps.far,
          fovyRadians = _this$projectionProps.fovyRadians,
          aspect = _this$projectionProps.aspect;
      Object.assign(this._frustumPlanes, (0, _mathUtils.getFrustumPlanes)({
        aspect: aspect,
        near: near,
        far: far,
        fovyRadians: fovyRadians,
        position: this.cameraPosition,
        direction: this.cameraDirection,
        up: this.cameraUp,
        right: this.cameraRight
      }));
      return this._frustumPlanes;
    }
  }, {
    key: "getCameraPosition",
    value: function getCameraPosition() {
      return this.cameraPosition;
    }
  }, {
    key: "getCameraDirection",
    value: function getCameraDirection() {
      return this.cameraDirection;
    }
  }, {
    key: "getCameraUp",
    value: function getCameraUp() {
      return this.cameraUp;
    }
  }, {
    key: "_addMetersToLngLat",
    value: function _addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = (0, _slicedToArray2.default)(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;

      var _this$_metersToLngLat = this._metersToLngLatDelta(xyz),
          _this$_metersToLngLat2 = (0, _slicedToArray2.default)(_this$_metersToLngLat, 3),
          deltaLng = _this$_metersToLngLat2[0],
          deltaLat = _this$_metersToLngLat2[1],
          _this$_metersToLngLat3 = _this$_metersToLngLat2[2],
          deltaZ = _this$_metersToLngLat3 === void 0 ? 0 : _this$_metersToLngLat3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }
  }, {
    key: "_metersToLngLatDelta",
    value: function _metersToLngLatDelta(xyz) {
      var _xyz2 = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          z = _xyz2$ === void 0 ? 0 : _xyz2$;

      (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _this$distanceScales = this.distanceScales,
          pixelsPerMeter = _this$distanceScales.pixelsPerMeter,
          degreesPerPixel = _this$distanceScales.degreesPerPixel;
      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }
  }, {
    key: "_createProjectionMatrix",
    value: function _createProjectionMatrix(_ref5) {
      var orthographic = _ref5.orthographic,
          fovyRadians = _ref5.fovyRadians,
          aspect = _ref5.aspect,
          focalDistance = _ref5.focalDistance,
          near = _ref5.near,
          far = _ref5.far;
      (0, _assert.default)(Number.isFinite(fovyRadians));
      return orthographic ? new _math.Matrix4().orthographic({
        fovy: fovyRadians,
        aspect: aspect,
        focalDistance: focalDistance,
        near: near,
        far: far
      }) : new _math.Matrix4().perspective({
        fovy: fovyRadians,
        aspect: aspect,
        near: near,
        far: far
      });
    }
  }, {
    key: "_initViewMatrix",
    value: function _initViewMatrix(opts) {
      var _opts$viewMatrix = opts.viewMatrix,
          viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY : _opts$viewMatrix,
          _opts$longitude = opts.longitude,
          longitude = _opts$longitude === void 0 ? null : _opts$longitude,
          _opts$latitude = opts.latitude,
          latitude = _opts$latitude === void 0 ? null : _opts$latitude,
          _opts$zoom = opts.zoom,
          zoom = _opts$zoom === void 0 ? null : _opts$zoom,
          _opts$position = opts.position,
          position = _opts$position === void 0 ? null : _opts$position,
          _opts$modelMatrix = opts.modelMatrix,
          modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix,
          _opts$focalDistance = opts.focalDistance,
          focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance,
          _opts$distanceScales = opts.distanceScales,
          distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales;
      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this.zoom = zoom;

      if (!Number.isFinite(this.zoom)) {
        this.zoom = this.isGeospatial ? (0, _viewportMercatorProject.getMeterZoom)({
          latitude: latitude
        }) + Math.log2(focalDistance) : DEFAULT_ZOOM;
      }

      var scale = Math.pow(2, this.zoom);
      this.scale = scale;
      this.distanceScales = this.isGeospatial ? (0, _viewportMercatorProject.getDistanceScales)({
        latitude: latitude,
        longitude: longitude,
        scale: this.scale
      }) : distanceScales || {
        pixelsPerMeter: [scale, scale, scale],
        metersPerPixel: [1 / scale, 1 / scale, 1 / scale]
      };
      this.focalDistance = focalDistance;
      this.distanceScales.metersPerPixel = new _math.Vector3(this.distanceScales.metersPerPixel);
      this.distanceScales.pixelsPerMeter = new _math.Vector3(this.distanceScales.pixelsPerMeter);
      this.position = ZERO_VECTOR;
      this.meterOffset = ZERO_VECTOR;

      if (position) {
        this.position = position;
        this.modelMatrix = modelMatrix;
        this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
      }

      if (this.isGeospatial) {
        this.longitude = longitude;
        this.latitude = latitude;
        this.center = this._getCenterInWorld({
          longitude: longitude,
          latitude: latitude
        });
        this.viewMatrixUncentered = mat4.scale([], viewMatrix, [1, -1, 1]);
      } else {
        this.center = position ? this.projectPosition(position) : [0, 0, 0];
        this.viewMatrixUncentered = viewMatrix;
      }

      this.viewMatrix = new _math.Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new _math.Vector3(this.center || ZERO_VECTOR).negate());
    }
  }, {
    key: "_getCenterInWorld",
    value: function _getCenterInWorld(_ref6) {
      var longitude = _ref6.longitude,
          latitude = _ref6.latitude;
      var meterOffset = this.meterOffset,
          scale = this.scale,
          distanceScales = this.distanceScales;
      var center2d = this.projectFlat([longitude, latitude], scale);
      var center = new _math.Vector3(center2d[0], center2d[1], 0);

      if (meterOffset) {
        var pixelPosition = new _math.Vector3(meterOffset).scale(distanceScales.pixelsPerMeter);
        center.add(pixelPosition);
      }

      return center;
    }
  }, {
    key: "_initProjectionMatrix",
    value: function _initProjectionMatrix(opts) {
      var _opts$projectionMatri = opts.projectionMatrix,
          projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri,
          _opts$orthographic = opts.orthographic,
          orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic,
          fovyRadians = opts.fovyRadians,
          fovyDegrees = opts.fovyDegrees,
          fovy = opts.fovy,
          _opts$near = opts.near,
          near = _opts$near === void 0 ? 0.1 : _opts$near,
          _opts$far = opts.far,
          far = _opts$far === void 0 ? 1000 : _opts$far,
          _opts$focalDistance2 = opts.focalDistance,
          focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2,
          orthographicFocalDistance = opts.orthographicFocalDistance;
      var radians = fovyRadians || (fovyDegrees || fovy || 75) * DEGREES_TO_RADIANS;
      this.projectionProps = {
        orthographic: orthographic,
        fovyRadians: radians,
        aspect: this.width / this.height,
        focalDistance: orthographicFocalDistance || focalDistance,
        near: near,
        far: far
      };
      this.projectionMatrix = projectionMatrix || this._createProjectionMatrix(this.projectionProps);
    }
  }, {
    key: "_initPixelMatrices",
    value: function _initPixelMatrices() {
      var vpm = (0, _mathUtils.createMat4)();
      mat4.multiply(vpm, vpm, this.projectionMatrix);
      mat4.multiply(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;
      this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;

      var _extractCameraVectors = (0, _mathUtils.extractCameraVectors)({
        viewMatrix: this.viewMatrix,
        viewMatrixInverse: this.viewMatrixInverse
      }),
          eye = _extractCameraVectors.eye,
          direction = _extractCameraVectors.direction,
          up = _extractCameraVectors.up,
          right = _extractCameraVectors.right;

      this.cameraPosition = eye;
      this.cameraDirection = direction;
      this.cameraUp = up;
      this.cameraRight = right;
      var viewportMatrix = (0, _mathUtils.createMat4)();
      var pixelProjectionMatrix = (0, _mathUtils.createMat4)();
      mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
      mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
      mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = pixelProjectionMatrix;
      this.viewportMatrix = viewportMatrix;
      this.pixelUnprojectionMatrix = mat4.invert((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);

      if (!this.pixelUnprojectionMatrix) {
        _log.default.warn('Pixel project matrix not invertible')();
      }
    }
  }]);
  return Viewport;
}();

exports.default = Viewport;
Viewport.displayName = 'Viewport';

},{"../utils/assert":109,"../utils/log":117,"../utils/math-utils":118,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/slicedToArray":37,"gl-matrix/mat4":407,"math.gl":415,"viewport-mercator-project":461}],126:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _viewport = _interopRequireDefault(require("./viewport"));

var _viewportMercatorProject = require("viewport-mercator-project");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  (0, _inherits2.default)(WebMercatorViewport, _Viewport);

  function WebMercatorViewport() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, WebMercatorViewport);
    var _opts$latitude = opts.latitude,
        latitude = _opts$latitude === void 0 ? 0 : _opts$latitude,
        _opts$longitude = opts.longitude,
        longitude = _opts$longitude === void 0 ? 0 : _opts$longitude,
        _opts$zoom = opts.zoom,
        zoom = _opts$zoom === void 0 ? 11 : _opts$zoom,
        _opts$pitch = opts.pitch,
        pitch = _opts$pitch === void 0 ? 0 : _opts$pitch,
        _opts$bearing = opts.bearing,
        bearing = _opts$bearing === void 0 ? 0 : _opts$bearing,
        _opts$nearZMultiplier = opts.nearZMultiplier,
        nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier,
        _opts$farZMultiplier = opts.farZMultiplier,
        farZMultiplier = _opts$farZMultiplier === void 0 ? 10 : _opts$farZMultiplier,
        _opts$orthographic = opts.orthographic,
        orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic;
    var width = opts.width,
        height = opts.height,
        _opts$altitude = opts.altitude,
        altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;
    width = width || 1;
    height = height || 1;
    altitude = Math.max(0.75, altitude);

    var _getProjectionParamet = (0, _viewportMercatorProject.getProjectionParameters)({
      width: width,
      height: height,
      pitch: pitch,
      altitude: altitude,
      nearZMultiplier: nearZMultiplier,
      farZMultiplier: farZMultiplier
    }),
        fov = _getProjectionParamet.fov,
        aspect = _getProjectionParamet.aspect,
        focalDistance = _getProjectionParamet.focalDistance,
        near = _getProjectionParamet.near,
        far = _getProjectionParamet.far;

    var viewMatrixUncentered = (0, _viewportMercatorProject.getViewMatrix)({
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });
    var viewportOpts = Object.assign({}, opts, {
      width: width,
      height: height,
      viewMatrix: viewMatrixUncentered,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      orthographic: orthographic,
      fovyRadians: fov,
      aspect: aspect,
      orthographicFocalDistance: focalDistance,
      near: near,
      far: far
    });
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(WebMercatorViewport).call(this, viewportOpts));
    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;
    _this.orthographic = orthographic;
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    Object.freeze((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    return _this;
  }

  (0, _createClass2.default)(WebMercatorViewport, [{
    key: "metersToLngLatDelta",
    value: function metersToLngLatDelta(xyz) {
      var _xyz = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === void 0 ? 0 : _xyz$;

      (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _this$distanceScales = this.distanceScales,
          pixelsPerMeter = _this$distanceScales.pixelsPerMeter,
          degreesPerPixel = _this$distanceScales.degreesPerPixel;
      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }
  }, {
    key: "lngLatDeltaToMeters",
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = (0, _slicedToArray2.default)(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === void 0 ? 0 : _deltaLngLatZ$;

      (0, _assert.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _this$distanceScales2 = this.distanceScales,
          pixelsPerDegree = _this$distanceScales2.pixelsPerDegree,
          metersPerPixel = _this$distanceScales2.metersPerPixel;
      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }
  }, {
    key: "addMetersToLngLat",
    value: function addMetersToLngLat(lngLatZ, xyz) {
      return (0, _viewportMercatorProject.addMetersToLngLat)(lngLatZ, xyz);
    }
  }, {
    key: "getMapCenterByLngLatPosition",
    value: function getMapCenterByLngLatPosition(_ref) {
      var lngLat = _ref.lngLat,
          pos = _ref.pos;
      var fromLocation = (0, _viewportMercatorProject.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
      var toLocation = this.projectFlat(lngLat);
      var translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
      var newCenter = vec2.add([], this.center, translate);
      return this.unprojectFlat(newCenter);
    }
  }, {
    key: "getLocationAtPoint",
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;
      return this.getMapCenterByLngLatPosition({
        lngLat: lngLat,
        pos: pos
      });
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = (0, _viewportMercatorProject.fitBounds)(Object.assign({
        width: width,
        height: height,
        bounds: bounds
      }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({
        width: width,
        height: height,
        longitude: longitude,
        latitude: latitude,
        zoom: zoom
      });
    }
  }]);
  return WebMercatorViewport;
}(_viewport.default);

exports.default = WebMercatorViewport;
WebMercatorViewport.displayName = 'WebMercatorViewport';

},{"../utils/assert":109,"./viewport":125,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37,"gl-matrix/vec2":409,"viewport-mercator-project":461}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

var _firstPersonController = _interopRequireDefault(require("../controllers/first-person-controller"));

function getDirectionFromBearingAndPitch(_ref) {
  var bearing = _ref.bearing,
      pitch = _ref.pitch;
  var spherical = new _math._SphericalCoordinates({
    bearing: bearing,
    pitch: pitch
  });
  var direction = spherical.toVector3().normalize();
  return direction;
}

var FirstPersonView = function (_View) {
  (0, _inherits2.default)(FirstPersonView, _View);

  function FirstPersonView() {
    (0, _classCallCheck2.default)(this, FirstPersonView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FirstPersonView).apply(this, arguments));
  }

  (0, _createClass2.default)(FirstPersonView, [{
    key: "_getViewport",
    value: function _getViewport(props) {
      var _props$viewState = props.viewState,
          _props$viewState$mode = _props$viewState.modelMatrix,
          modelMatrix = _props$viewState$mode === void 0 ? null : _props$viewState$mode,
          bearing = _props$viewState.bearing,
          _props$viewState$up = _props$viewState.up,
          up = _props$viewState$up === void 0 ? [0, 0, 1] : _props$viewState$up;
      var dir = getDirectionFromBearingAndPitch({
        bearing: bearing,
        pitch: 89
      });
      var center = modelMatrix ? modelMatrix.transformDirection(dir) : dir;
      var viewMatrix = new _math.Matrix4().lookAt({
        eye: [0, 0, 0],
        center: center,
        up: up
      });
      return new _viewport.default(Object.assign({}, props, {
        zoom: null,
        viewMatrix: viewMatrix
      }));
    }
  }, {
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _firstPersonController.default
      });
    }
  }]);
  return FirstPersonView;
}(_view.default);

exports.default = FirstPersonView;
FirstPersonView.displayName = 'FirstPersonView';

},{"../controllers/first-person-controller":45,"../viewports/viewport":125,"./view":133,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],128:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _webMercatorViewport = _interopRequireDefault(require("../viewports/web-mercator-viewport"));

var _mapController = _interopRequireDefault(require("../controllers/map-controller"));

var MapView = function (_View) {
  (0, _inherits2.default)(MapView, _View);

  function MapView(props) {
    (0, _classCallCheck2.default)(this, MapView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MapView).call(this, Object.assign({}, props, {
      type: _webMercatorViewport.default
    })));
  }

  (0, _createClass2.default)(MapView, [{
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _mapController.default
      });
    }
  }]);
  return MapView;
}(_view.default);

exports.default = MapView;
MapView.displayName = 'MapView';

},{"../controllers/map-controller":46,"../viewports/web-mercator-viewport":126,"./view":133,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],129:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

var _orbitController = _interopRequireDefault(require("../controllers/orbit-controller"));

var DEGREES_TO_RADIANS = Math.PI / 180;

function getViewMatrix(_ref) {
  var height = _ref.height,
      fovy = _ref.fovy,
      orbitAxis = _ref.orbitAxis,
      rotationX = _ref.rotationX,
      rotationOrbit = _ref.rotationOrbit,
      zoom = _ref.zoom;
  var distance = 0.5 / Math.tan(fovy * DEGREES_TO_RADIANS / 2);
  var up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];
  var eye = orbitAxis === 'Z' ? [0, -distance, 0] : [0, 0, distance];
  var viewMatrix = new _math.Matrix4().lookAt({
    eye: eye,
    up: up
  });
  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);

  if (orbitAxis === 'Z') {
    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);
  } else {
    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);
  }

  var projectionScale = 1 / (height || 1);
  viewMatrix.scale([projectionScale, projectionScale, projectionScale]);
  return viewMatrix;
}

var OrbitViewport = function (_Viewport) {
  (0, _inherits2.default)(OrbitViewport, _Viewport);

  function OrbitViewport(props) {
    (0, _classCallCheck2.default)(this, OrbitViewport);
    var id = props.id,
        x = props.x,
        y = props.y,
        width = props.width,
        height = props.height,
        _props$fovy = props.fovy,
        fovy = _props$fovy === void 0 ? 50 : _props$fovy,
        near = props.near,
        far = props.far,
        _props$orbitAxis = props.orbitAxis,
        orbitAxis = _props$orbitAxis === void 0 ? 'Z' : _props$orbitAxis,
        _props$target = props.target,
        target = _props$target === void 0 ? [0, 0, 0] : _props$target,
        _props$rotationX = props.rotationX,
        rotationX = _props$rotationX === void 0 ? 0 : _props$rotationX,
        _props$rotationOrbit = props.rotationOrbit,
        rotationOrbit = _props$rotationOrbit === void 0 ? 0 : _props$rotationOrbit,
        _props$zoom = props.zoom,
        zoom = _props$zoom === void 0 ? 0 : _props$zoom;
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitViewport).call(this, {
      id: id,
      viewMatrix: getViewMatrix({
        height: height,
        fovy: fovy,
        orbitAxis: orbitAxis,
        rotationX: rotationX,
        rotationOrbit: rotationOrbit,
        zoom: zoom
      }),
      fovy: fovy,
      near: near,
      far: far,
      x: x,
      y: y,
      position: target,
      width: width,
      height: height,
      zoom: zoom
    }));
  }

  return OrbitViewport;
}(_viewport.default);

var OrbitView = function (_View) {
  (0, _inherits2.default)(OrbitView, _View);

  function OrbitView(props) {
    (0, _classCallCheck2.default)(this, OrbitView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitView).call(this, Object.assign({}, props, {
      type: OrbitViewport
    })));
  }

  (0, _createClass2.default)(OrbitView, [{
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _orbitController.default,
        ViewportType: OrbitViewport
      });
    }
  }]);
  return OrbitView;
}(_view.default);

exports.default = OrbitView;
OrbitView.displayName = 'OrbitView';

},{"../controllers/orbit-controller":47,"../viewports/viewport":125,"./view":133,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],130:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

var _orthographicController = _interopRequireDefault(require("../controllers/orthographic-controller"));

var viewMatrix = new _math.Matrix4().lookAt({
  eye: [0, 0, 1]
});

function getProjectionMatrix(_ref) {
  var width = _ref.width,
      height = _ref.height,
      near = _ref.near,
      far = _ref.far;
  width = width || 1;
  height = height || 1;
  return new _math.Matrix4().ortho({
    left: -width / 2,
    right: width / 2,
    bottom: height / 2,
    top: -height / 2,
    near: near,
    far: far
  });
}

var OrthographicViewport = function (_Viewport) {
  (0, _inherits2.default)(OrthographicViewport, _Viewport);

  function OrthographicViewport(_ref2) {
    var _this;

    var id = _ref2.id,
        x = _ref2.x,
        y = _ref2.y,
        width = _ref2.width,
        height = _ref2.height,
        _ref2$near = _ref2.near,
        near = _ref2$near === void 0 ? 0.1 : _ref2$near,
        _ref2$far = _ref2.far,
        far = _ref2$far === void 0 ? 1000 : _ref2$far,
        _ref2$zoom = _ref2.zoom,
        zoom = _ref2$zoom === void 0 ? 0 : _ref2$zoom,
        _ref2$target = _ref2.target,
        target = _ref2$target === void 0 ? [0, 0, 0] : _ref2$target;
    (0, _classCallCheck2.default)(this, OrthographicViewport);
    return (0, _possibleConstructorReturn2.default)(_this, new _viewport.default({
      id: id,
      x: x,
      y: y,
      width: width,
      height: height,
      position: target,
      viewMatrix: viewMatrix,
      projectionMatrix: getProjectionMatrix({
        width: width,
        height: height,
        near: near,
        far: far
      }),
      zoom: zoom
    }));
  }

  return OrthographicViewport;
}(_viewport.default);

var OrthographicView = function (_View) {
  (0, _inherits2.default)(OrthographicView, _View);

  function OrthographicView(props) {
    (0, _classCallCheck2.default)(this, OrthographicView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrthographicView).call(this, Object.assign({}, props, {
      type: OrthographicViewport
    })));
  }

  (0, _createClass2.default)(OrthographicView, [{
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _orthographicController.default,
        ViewportType: OrthographicViewport
      });
    }
  }]);
  return OrthographicView;
}(_view.default);

exports.default = OrthographicView;
OrthographicView.displayName = 'OrthographicView';

},{"../controllers/orthographic-controller":48,"../viewports/viewport":125,"./view":133,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],131:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var DEGREES_TO_RADIANS = Math.PI / 180;

var PerspectiveView = function (_View) {
  (0, _inherits2.default)(PerspectiveView, _View);

  function PerspectiveView() {
    (0, _classCallCheck2.default)(this, PerspectiveView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PerspectiveView).apply(this, arguments));
  }

  (0, _createClass2.default)(PerspectiveView, [{
    key: "_getViewport",
    value: function _getViewport(props) {
      var x = props.x,
          y = props.y,
          width = props.width,
          height = props.height,
          viewState = props.viewState;
      var eye = viewState.eye,
          _viewState$lookAt = viewState.lookAt,
          lookAt = _viewState$lookAt === void 0 ? [0, 0, 0] : _viewState$lookAt,
          _viewState$up = viewState.up,
          up = _viewState$up === void 0 ? [0, 1, 0] : _viewState$up;
      var fovy = props.fovy || viewState.fovy || 75;
      var near = props.near || viewState.near || 1;
      var far = props.far || viewState.far || 100;
      var aspect = Number.isFinite(viewState.aspect) ? viewState.aspect : width / height;
      var fovyRadians = fovy * DEGREES_TO_RADIANS;
      return new _viewport.default({
        id: this.id,
        x: x,
        y: y,
        width: width,
        height: height,
        viewMatrix: mat4.lookAt([], eye, lookAt, up),
        projectionMatrix: mat4.perspective([], fovyRadians, aspect, near, far)
      });
    }
  }]);
  return PerspectiveView;
}(_view.default);

exports.default = PerspectiveView;
PerspectiveView.displayName = 'PerspectiveView';

},{"../viewports/viewport":125,"./view":133,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"gl-matrix/mat4":407}],132:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

function getDirectionFromBearingAndPitch(_ref) {
  var bearing = _ref.bearing,
      pitch = _ref.pitch;
  var spherical = new _math._SphericalCoordinates({
    bearing: bearing,
    pitch: pitch
  });
  return spherical.toVector3().normalize();
}

var ThirdPersonView = function (_View) {
  (0, _inherits2.default)(ThirdPersonView, _View);

  function ThirdPersonView() {
    (0, _classCallCheck2.default)(this, ThirdPersonView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ThirdPersonView).apply(this, arguments));
  }

  (0, _createClass2.default)(ThirdPersonView, [{
    key: "_getViewport",
    value: function _getViewport(props) {
      var _props$viewState = props.viewState,
          bearing = _props$viewState.bearing,
          pitch = _props$viewState.pitch,
          position = _props$viewState.position,
          up = _props$viewState.up,
          zoom = _props$viewState.zoom;
      var direction = getDirectionFromBearingAndPitch({
        bearing: bearing,
        pitch: pitch
      });
      var distance = zoom * 50;
      var eye = direction.scale(-distance).multiply(new _math.Vector3(1, 1, -1));
      var viewMatrix = new _math.Matrix4().multiplyRight(new _math.Matrix4().lookAt({
        eye: eye,
        center: position,
        up: up
      }));
      return new _viewport.default(Object.assign({}, props, {
        id: this.id,
        zoom: null,
        viewMatrix: viewMatrix
      }));
    }
  }]);
  return ThirdPersonView;
}(_view.default);

exports.default = ThirdPersonView;
ThirdPersonView.displayName = 'ThirdPersonView';

},{"../viewports/viewport":125,"./view":133,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],133:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _positions = require("../utils/positions");

var _deepEqual = require("../utils/deep-equal");

var _assert = _interopRequireDefault(require("../utils/assert"));

var View = function () {
  function View() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, View);
    var _props$id = props.id,
        id = _props$id === void 0 ? null : _props$id,
        _props$x = props.x,
        x = _props$x === void 0 ? 0 : _props$x,
        _props$y = props.y,
        y = _props$y === void 0 ? 0 : _props$y,
        _props$width = props.width,
        width = _props$width === void 0 ? '100%' : _props$width,
        _props$height = props.height,
        height = _props$height === void 0 ? '100%' : _props$height,
        _props$projectionMatr = props.projectionMatrix,
        projectionMatrix = _props$projectionMatr === void 0 ? null : _props$projectionMatr,
        _props$fovy = props.fovy,
        fovy = _props$fovy === void 0 ? 50 : _props$fovy,
        _props$near = props.near,
        near = _props$near === void 0 ? 0.1 : _props$near,
        _props$far = props.far,
        far = _props$far === void 0 ? 1000 : _props$far,
        _props$modelMatrix = props.modelMatrix,
        modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix,
        _props$viewportInstan = props.viewportInstance,
        viewportInstance = _props$viewportInstan === void 0 ? null : _props$viewportInstan,
        _props$type = props.type,
        type = _props$type === void 0 ? _viewport.default : _props$type;
    (0, _assert.default)(!viewportInstance || viewportInstance instanceof _viewport.default);
    this.viewportInstance = viewportInstance;
    this.id = id || this.constructor.displayName || 'view';
    this.type = type;
    this.props = Object.assign({}, props, {
      id: this.id,
      projectionMatrix: projectionMatrix,
      fovy: fovy,
      near: near,
      far: far,
      modelMatrix: modelMatrix
    });

    this._parseDimensions({
      x: x,
      y: y,
      width: width,
      height: height
    });

    this.equals = this.equals.bind(this);
    Object.seal(this);
  }

  (0, _createClass2.default)(View, [{
    key: "equals",
    value: function equals(view) {
      if (this === view) {
        return true;
      }

      if (this.viewportInstance) {
        return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);
      }

      var viewChanged = (0, _deepEqual.deepEqual)(this.props, view.props);
      return viewChanged;
    }
  }, {
    key: "makeViewport",
    value: function makeViewport(_ref) {
      var width = _ref.width,
          height = _ref.height,
          viewState = _ref.viewState;

      if (this.viewportInstance) {
        return this.viewportInstance;
      }

      viewState = this.filterViewState(viewState);
      var viewportDimensions = this.getDimensions({
        width: width,
        height: height
      });
      var props = Object.assign({
        viewState: viewState
      }, viewState, this.props, viewportDimensions);
      return this._getViewport(props);
    }
  }, {
    key: "getViewStateId",
    value: function getViewStateId() {
      switch ((0, _typeof2.default)(this.props.viewState)) {
        case 'string':
          return this.props.viewState;

        case 'object':
          return this.props.viewState && this.props.viewState.id;

        default:
          return this.id;
      }
    }
  }, {
    key: "filterViewState",
    value: function filterViewState(viewState) {
      if (this.props.viewState && (0, _typeof2.default)(this.props.viewState) === 'object') {
        if (!this.props.viewState.id) {
          return this.props.viewState;
        }

        var newViewState = Object.assign({}, viewState);

        for (var key in this.props.viewState) {
          if (key !== 'id') {
            newViewState[key] = this.props.viewState[key];
          }
        }

        return newViewState;
      }

      return viewState;
    }
  }, {
    key: "getDimensions",
    value: function getDimensions(_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return {
        x: (0, _positions.getPosition)(this._x, width),
        y: (0, _positions.getPosition)(this._y, height),
        width: (0, _positions.getPosition)(this._width, width),
        height: (0, _positions.getPosition)(this._height, height)
      };
    }
  }, {
    key: "_getControllerProps",
    value: function _getControllerProps(defaultOpts) {
      var opts = this.props.controller;

      if (!opts) {
        return null;
      }

      if (opts === true) {
        return defaultOpts;
      }

      if (typeof opts === 'function') {
        opts = {
          type: opts
        };
      }

      return Object.assign({}, defaultOpts, opts);
    }
  }, {
    key: "_getViewport",
    value: function _getViewport(props) {
      var ViewportType = this.type;
      return new ViewportType(props);
    }
  }, {
    key: "_parseDimensions",
    value: function _parseDimensions(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          width = _ref3.width,
          height = _ref3.height;
      this._x = (0, _positions.parsePosition)(x);
      this._y = (0, _positions.parsePosition)(y);
      this._width = (0, _positions.parsePosition)(width);
      this._height = (0, _positions.parsePosition)(height);
    }
  }]);
  return View;
}();

exports.default = View;

},{"../utils/assert":109,"../utils/deep-equal":111,"../utils/positions":120,"../viewports/viewport":125,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDeckInstance = getDeckInstance;
exports.addLayer = addLayer;
exports.removeLayer = removeLayer;
exports.updateLayer = updateLayer;
exports.drawLayer = drawLayer;

var _core = require("@deck.gl/core");

function getDeckInstance(_ref) {
  var map = _ref.map,
      gl = _ref.gl,
      deck = _ref.deck;

  if (map.__deck) {
    return map.__deck;
  }

  var customRender = deck && deck.props._customRender;
  var deckProps = {
    useDevicePixels: true,
    _customRender: function _customRender() {
      map.triggerRepaint();

      if (customRender) {
        customRender();
      }
    },
    parameters: {
      depthMask: true,
      depthTest: true,
      blendFunc: [770, 771, 1, 771],
      blendEquation: 32774
    },
    userData: {
      isExternal: false,
      mapboxLayers: new Set()
    }
  };

  if (deck) {
    deck.setProps(deckProps);
    deck.props.userData.isExternal = true;
  } else {
    Object.assign(deckProps, {
      gl: gl,
      width: false,
      height: false,
      viewState: getViewState(map)
    });
    deck = new _core.Deck(deckProps);
    map.on('move', function () {
      return onMapMove(deck, map);
    });
    map.on('remove', function () {
      deck.finalize();
      map.__deck = null;
    });
  }

  map.__deck = deck;
  map.on('render', function () {
    return afterRender(deck, map);
  });
  return deck;
}

function addLayer(deck, layer) {
  deck.props.userData.mapboxLayers.add(layer);
  updateLayers(deck);
}

function removeLayer(deck, layer) {
  deck.props.userData.mapboxLayers.delete(layer);
  updateLayers(deck);
}

function updateLayer(deck, layer) {
  updateLayers(deck);
}

function drawLayer(deck, map, layer) {
  var currentViewport = deck.props.userData.currentViewport;

  if (!currentViewport) {
    currentViewport = getViewport(deck, map, true);
    deck.props.userData.currentViewport = currentViewport;
  }

  deck._drawLayers('mapbox-repaint', {
    viewports: [currentViewport],
    layers: getLayers(deck, function (deckLayer) {
      return shouldDrawLayer(layer.id, deckLayer);
    }),
    clearCanvas: false
  });
}

function getViewState(map) {
  var _map$getCenter = map.getCenter(),
      lng = _map$getCenter.lng,
      lat = _map$getCenter.lat;

  return {
    longitude: lng,
    latitude: lat,
    zoom: map.getZoom(),
    bearing: map.getBearing(),
    pitch: map.getPitch()
  };
}

function getViewport(deck, map) {
  var useMapboxProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return new _core.WebMercatorViewport(Object.assign({
    x: 0,
    y: 0,
    width: deck.width,
    height: deck.height
  }, getViewState(map), useMapboxProjection ? {
    nearZMultiplier: deck.height ? 1 / deck.height : 1,
    farZMultiplier: 1
  } : {
    nearZMultiplier: 0.1,
    farZMultiplier: 10
  }));
}

function afterRender(deck, map) {
  var _deck$props$userData = deck.props.userData,
      mapboxLayers = _deck$props$userData.mapboxLayers,
      isExternal = _deck$props$userData.isExternal;

  if (isExternal) {
    var mapboxLayerIds = Array.from(mapboxLayers, function (layer) {
      return layer.id;
    });
    var layers = getLayers(deck, function (deckLayer) {
      for (var _i = 0; _i < mapboxLayerIds.length; _i++) {
        var id = mapboxLayerIds[_i];

        if (shouldDrawLayer(id, deckLayer)) {
          return false;
        }
      }

      return true;
    });

    if (layers.length > 0) {
      deck._drawLayers('mapbox-repaint', {
        viewports: [getViewport(deck, map, false)],
        layers: layers,
        clearCanvas: false
      });
    }
  }

  deck.props.userData.currentViewport = null;
}

function onMapMove(deck, map) {
  deck.setProps({
    viewState: getViewState(map)
  });
  deck.needsRedraw({
    clearRedrawFlags: true
  });
}

function getLayers(deck, layerFilter) {
  var layers = deck.layerManager.getLayers();
  return layers.filter(layerFilter);
}

function shouldDrawLayer(id, layer) {
  var layerInstance = layer;

  while (layerInstance) {
    if (layerInstance.id === id) {
      return true;
    }

    layerInstance = layerInstance.parent;
  }

  return false;
}

function updateLayers(deck) {
  if (deck.props.userData.isExternal) {
    return;
  }

  var layers = [];
  deck.props.userData.mapboxLayers.forEach(function (deckLayer) {
    var LayerType = deckLayer.props.type;
    var layer = new LayerType(deckLayer.props);
    layers.push(layer);
  });
  deck.setProps({
    layers: layers
  });
}

},{"@deck.gl/core":58}],135:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MapboxLayer", {
  enumerable: true,
  get: function get() {
    return _mapboxLayer.default;
  }
});

var _mapboxLayer = _interopRequireDefault(require("./mapbox-layer"));

},{"./mapbox-layer":136,"@babel/runtime/helpers/interopRequireDefault":25}],136:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _deckUtils = require("./deck-utils");

var MapboxLayer = function () {
  function MapboxLayer(props) {
    (0, _classCallCheck2.default)(this, MapboxLayer);

    if (!props.id) {
      throw new Error('Layer must have an unique id');
    }

    this.id = props.id;
    this.type = 'custom';
    this.renderingMode = props.renderingMode || '3d';
    this.map = null;
    this.deck = null;
    this.props = props;
  }

  (0, _createClass2.default)(MapboxLayer, [{
    key: "onAdd",
    value: function onAdd(map, gl) {
      this.map = map;
      this.deck = (0, _deckUtils.getDeckInstance)({
        map: map,
        gl: gl,
        deck: this.props.deck
      });
      (0, _deckUtils.addLayer)(this.deck, this);
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      (0, _deckUtils.removeLayer)(this.deck, this);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      Object.assign(this.props, props, {
        id: this.id
      });

      if (this.deck) {
        (0, _deckUtils.updateLayer)(this.deck, this);
      }
    }
  }, {
    key: "render",
    value: function render(gl, matrix) {
      (0, _deckUtils.drawLayer)(this.deck, this.map, this);
    }
  }]);
  return MapboxLayer;
}();

exports.default = MapboxLayer;

},{"./deck-utils":134,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],137:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "SimpleMeshLayer", {
  enumerable: true,
  get: function get() {
    return _simpleMeshLayer.default;
  }
});
Object.defineProperty(exports, "ScenegraphLayer", {
  enumerable: true,
  get: function get() {
    return _scenegraphLayer.default;
  }
});

var _simpleMeshLayer = _interopRequireDefault(require("./simple-mesh-layer/simple-mesh-layer"));

var _scenegraphLayer = _interopRequireDefault(require("./scenegraph-layer/scenegraph-layer"));

},{"./scenegraph-layer/scenegraph-layer":141,"./simple-mesh-layer/simple-mesh-layer":146,"@babel/runtime/helpers/interopRequireDefault":25}],138:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitForGLTFAssets = waitForGLTFAssets;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function waitForGLTFAssets(_x) {
  return _waitForGLTFAssets.apply(this, arguments);
}

function _waitForGLTFAssets() {
  _waitForGLTFAssets = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(gltfObjects) {
    var remaining;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            remaining = [];
            gltfObjects.scenes.forEach(function (scene) {
              scene.traverse(function (model) {
                Object.values(model.model.program.uniforms).forEach(function (uniform) {
                  if (uniform.loaded === false) {
                    remaining.push(uniform);
                  }
                });
              });
            });
            _context.next = 4;
            return waitWhileCondition(function () {
              return remaining.some(function (uniform) {
                return !uniform.loaded;
              });
            });

          case 4:
            return _context.abrupt("return", _context.sent);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _waitForGLTFAssets.apply(this, arguments);
}

function waitWhileCondition(_x2) {
  return _waitWhileCondition.apply(this, arguments);
}

function _waitWhileCondition() {
  _waitWhileCondition = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(condition) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!condition()) {
              _context2.next = 5;
              break;
            }

            _context2.next = 3;
            return new Promise(function (resolve) {
              return requestAnimationFrame(resolve);
            });

          case 3:
            _context2.next = 0;
            break;

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _waitWhileCondition.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if (__VERSION__ < 300)\n  #define _varying varying\n  #define _texture2D texture2D\n  #define fragmentColor gl_FragColor\n#else\n  #define _varying in\n  #define _texture2D texture\n  out vec4 fragmentColor;\n#endif\n_varying vec4 vColor;\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    _varying vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * _texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n";
exports.default = _default;

},{}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if (__VERSION__ < 300)\n  #define _attribute attribute\n  #define _varying varying\n#else\n  #define _attribute in\n#define _varying out\n#endif\n_attribute vec3 instancePositions;\n_attribute vec2 instancePositions64xy;\n_attribute vec4 instanceColors;\n_attribute vec3 instancePickingColors;\n_attribute mat3 instanceModelMatrix;\n_attribute vec3 instanceTranslation;\nuniform float sizeScale;\nuniform mat4 sceneModelMatrix;\n_attribute vec4 POSITION;\n\n#ifdef HAS_UV\n  _attribute vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    _attribute vec4 NORMAL;\n  #endif\n#endif\n_varying vec4 vColor;\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    _varying vec2 vTEXCOORD_0;\n  #endif\n#endif\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      pbr_vNormal = project_normal(instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz);\n      geometry.normal = pbr_vNormal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif    \n    geometry.uv = pbr_vUV;\n  #endif\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale + instanceTranslation;\n  pos = project_size(pos);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xy, pos, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;

},{}],141:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _addons = require("@luma.gl/addons");

var _gltfUtils = require("./gltf-utils");

var _matrix = require("../utils/matrix");

var _scenegraphLayerVertex = _interopRequireDefault(require("./scenegraph-layer-vertex.glsl"));

var _scenegraphLayerFragment = _interopRequireDefault(require("./scenegraph-layer-fragment.glsl"));

var DEFAULT_COLOR = [255, 255, 255, 255];
var defaultProps = {
  scenegraph: {
    type: 'object',
    value: null,
    async: true
  },
  getScene: function getScene(gltf) {
    if (gltf && gltf.scenes) {
      return (0, _typeof2.default)(gltf.scene) === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }

    return gltf;
  },
  getAnimator: function getAnimator(scenegraph) {
    return scenegraph && scenegraph.animator;
  },
  _animations: null,
  sizeScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  _lighting: 'flat',
  _imageBasedLightingEnvironment: null,
  getOrientation: {
    type: 'accessor',
    value: [0, 0, 0]
  },
  getScale: {
    type: 'accessor',
    value: [1, 1, 1]
  },
  getTranslation: {
    type: 'accessor',
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: 'accessor',
    value: []
  }
};

var ScenegraphLayer = function (_Layer) {
  (0, _inherits2.default)(ScenegraphLayer, _Layer);

  function ScenegraphLayer() {
    (0, _classCallCheck2.default)(this, ScenegraphLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ScenegraphLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(ScenegraphLayer, [{
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          accessor: 'getPosition',
          transition: true
        },
        instancePositions64xy: {
          size: 2,
          accessor: 'getPosition',
          update: this.calculateInstancePositions64xyLow
        },
        instanceColors: {
          type: 5121,
          size: this.props.colorFormat.length,
          accessor: 'getColor',
          normalized: true,
          defaultValue: DEFAULT_COLOR,
          transition: true
        },
        instanceModelMatrix: _matrix.MATRIX_ATTRIBUTES
      });
    }
  }, {
    key: "updateState",
    value: function updateState(params) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ScenegraphLayer.prototype), "updateState", this).call(this, params);
      var props = params.props,
          oldProps = params.oldProps;

      if (props.scenegraph !== oldProps.scenegraph) {
        this._updateScenegraph(props);
      } else if (props._animations !== oldProps._animations) {
        this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
      }
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ScenegraphLayer.prototype), "finalizeState", this).call(this);

      this._deleteScenegraph();
    }
  }, {
    key: "_updateScenegraph",
    value: function _updateScenegraph(props) {
      var _this = this;

      var gl = this.context.gl;
      var scenegraphData;

      if (props.scenegraph instanceof _core2.ScenegraphNode) {
        scenegraphData = {
          scenes: [props.scenegraph]
        };
      } else if (props.scenegraph && !props.scenegraph.gltf) {
        var gltf = props.scenegraph;
        var gltfObjects = (0, _addons.createGLTFObjects)(gl, gltf, this.getLoadOptions());
        scenegraphData = Object.assign({
          gltf: gltf
        }, gltfObjects);
        (0, _gltfUtils.waitForGLTFAssets)(gltfObjects).then(function () {
          return _this.setNeedsRedraw();
        });
      } else {
        _core2.log.deprecated('ScenegraphLayer.props.scenegraph', 'Use GLTFLoader instead of GLTFScenegraphLoader');

        scenegraphData = props.scenegraph;
      }

      var options = {
        layer: this,
        gl: gl
      };
      var scenegraph = props.getScene(scenegraphData, options);
      var animator = props.getAnimator(scenegraphData, options);

      if (scenegraph instanceof _core2.ScenegraphNode) {
        this._deleteScenegraph();

        this._applyAllAttributes(scenegraph);

        this._applyAnimationsProp(scenegraph, animator, props._animations);

        this.setState({
          scenegraph: scenegraph,
          animator: animator
        });
      } else if (scenegraph !== null) {
        _core2.log.warn('invalid scenegraph:', scenegraph)();
      }
    }
  }, {
    key: "_applyAllAttributes",
    value: function _applyAllAttributes(scenegraph) {
      var _this2 = this;

      if (this.state.attributesAvailable) {
        var allAttributes = this.getAttributeManager().getAttributes();
        scenegraph.traverse(function (model) {
          _this2._setModelAttributes(model.model, allAttributes);
        });
      }
    }
  }, {
    key: "_applyAnimationsProp",
    value: function _applyAnimationsProp(scenegraph, animator, animationsProp) {
      if (!scenegraph || !animator || !animationsProp) {
        return;
      }

      var animations = animator.getAnimations();
      Object.keys(animationsProp).sort().forEach(function (key) {
        var value = animationsProp[key];

        if (key === '*') {
          animations.forEach(function (animation) {
            Object.assign(animation, value);
          });
        } else if (Number.isFinite(Number(key))) {
          var number = Number(key);

          if (number >= 0 && number < animations.length) {
            Object.assign(animations[number], value);
          } else {
            _core2.log.warn("animation ".concat(key, " not found"))();
          }
        } else {
          var findResult = animations.find(function (_ref) {
            var name = _ref.name;
            return name === key;
          });

          if (findResult) {
            Object.assign(findResult, value);
          } else {
            _core2.log.warn("animation ".concat(key, " not found"))();
          }
        }
      });
    }
  }, {
    key: "_deleteScenegraph",
    value: function _deleteScenegraph() {
      var scenegraph = this.state.scenegraph;

      if (scenegraph instanceof _core2.ScenegraphNode) {
        scenegraph.delete();
      }
    }
  }, {
    key: "addVersionToShader",
    value: function addVersionToShader(source) {
      if ((0, _core2.isWebGL2)(this.context.gl)) {
        return "#version 300 es\n".concat(source);
      }

      return source;
    }
  }, {
    key: "getLoadOptions",
    value: function getLoadOptions() {
      var modules = ['project32', 'picking'];
      var _this$props = this.props,
          _lighting = _this$props._lighting,
          _imageBasedLightingEnvironment = _this$props._imageBasedLightingEnvironment;

      if (_lighting === 'pbr') {
        modules.push(_core2.pbr);
      }

      var env = null;

      if (_imageBasedLightingEnvironment) {
        if (typeof _imageBasedLightingEnvironment === 'function') {
          env = _imageBasedLightingEnvironment({
            gl: this.context.gl,
            layer: this
          });
        } else {
          env = _imageBasedLightingEnvironment;
        }
      }

      return {
        gl: this.context.gl,
        waitForFullLoad: true,
        imageBasedLightingEnvironment: env,
        modelOptions: {
          vs: this.addVersionToShader(_scenegraphLayerVertex.default),
          fs: this.addVersionToShader(_scenegraphLayerFragment.default),
          modules: modules,
          isInstanced: true
        },
        useTangents: false
      };
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(changedAttributes) {
      var _this3 = this;

      this.setState({
        attributesAvailable: true
      });
      if (!this.state.scenegraph) return;
      this.state.scenegraph.traverse(function (model) {
        _this3._setModelAttributes(model.model, changedAttributes);
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var _ref2$moduleParameter = _ref2.moduleParameters,
          moduleParameters = _ref2$moduleParameter === void 0 ? null : _ref2$moduleParameter,
          _ref2$parameters = _ref2.parameters,
          parameters = _ref2$parameters === void 0 ? {} : _ref2$parameters,
          context = _ref2.context;
      if (!this.state.scenegraph) return;

      if (this.props._animations && this.state.animator) {
        this.state.animator.animate(context.animationProps.time);
      }

      var sizeScale = this.props.sizeScale;
      var numInstances = this.getNumInstances();
      this.state.scenegraph.traverse(function (model, _ref3) {
        var worldMatrix = _ref3.worldMatrix;
        model.model.setInstanceCount(numInstances);
        model.updateModuleSettings(moduleParameters);
        model.draw({
          parameters: parameters,
          uniforms: {
            sizeScale: sizeScale,
            sceneModelMatrix: worldMatrix,
            u_Camera: model.model.program.uniforms.project_uCameraPosition
          }
        });
      });
    }
  }, {
    key: "calculateInstancePositions64xyLow",
    value: function calculateInstancePositions64xyLow(attribute, _ref4) {
      var startRow = _ref4.startRow,
          endRow = _ref4.endRow;
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      var _this$props2 = this.props,
          data = _this$props2.data,
          getPosition = _this$props2.getPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          objectInfo.index++;
          var position = getPosition(point, objectInfo);
          value[i++] = (0, _core.fp64LowPart)(position[0]);
          value[i++] = (0, _core.fp64LowPart)(position[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ScenegraphLayer;
}(_core.Layer);

exports.default = ScenegraphLayer;
ScenegraphLayer.layerName = 'ScenegraphLayer';
ScenegraphLayer.defaultProps = defaultProps;

},{"../utils/matrix":147,"./gltf-utils":138,"./scenegraph-layer-fragment.glsl":139,"./scenegraph-layer-vertex.glsl":140,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/typeof":40,"@deck.gl/core":58,"@luma.gl/addons":239,"@luma.gl/core":253}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a);\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
exports.default = _default;

},{}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME simple-mesh-layer-fs\n\n// Note(Tarek): headless-gl supports derivatives, but doesn't report it via getExtension. Awesome!\n#ifdef DERIVATIVES\n#define FLAT_SHADE_NORMAL normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)))\n#else\n#define FLAT_SHADE_NORMAL vec3(0.0, 0.0, 1.0)\n#endif\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\n\nvarying vec2 vTexCoord;\nvarying vec3 cameraPosition;\nvarying vec3 normals_commonspace;\nvarying vec4 position_commonspace;\nvarying vec4 vColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n    normal = FLAT_SHADE_NORMAL;\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture2D(sampler, vTexCoord) : vColor;\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  gl_FragColor = vec4(lightColor, color.a);\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;

},{}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nin vec3 positions;\nin vec3 normals;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec2 instancePositions64xy;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  normals_commonspace = project_normal(instanceModelMatrix * normals);\n  vColor = instanceColors;\n  geometry.normal = normals_commonspace;\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n  pos = project_size(pos);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xy, pos, position_commonspace);\n  geometry.position = position_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;

},{}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME simple-mesh-layer-vs\n\n// Scale the model\nuniform float sizeScale;\n\n// Primitive attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\n// Instance attributes\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xy;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute mat3 instanceModelMatrix;\nattribute vec3 instanceTranslation;\n\n// Outputs to fragment shader\nvarying vec2 vTexCoord;\nvarying vec3 cameraPosition;\nvarying vec3 normals_commonspace;\nvarying vec4 position_commonspace;\nvarying vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  normals_commonspace = project_normal(instanceModelMatrix * normals);\n  vColor = instanceColors;\n  geometry.normal = normals_commonspace;\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n  pos = project_size(pos);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xy, pos, position_commonspace);\n  geometry.position = position_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;

},{}],146:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _matrix = require("../utils/matrix");

var _simpleMeshLayerVertex = _interopRequireDefault(require("./simple-mesh-layer-vertex.glsl1"));

var _simpleMeshLayerFragment = _interopRequireDefault(require("./simple-mesh-layer-fragment.glsl1"));

var _simpleMeshLayerVertex2 = _interopRequireDefault(require("./simple-mesh-layer-vertex.glsl"));

var _simpleMeshLayerFragment2 = _interopRequireDefault(require("./simple-mesh-layer-fragment.glsl"));

function assert(condition, message) {
  if (!condition) {
    throw new Error("deck.gl: ".concat(message));
  }
}

function getTextureFromData(gl, data, opts) {
  if (data instanceof _core2.Texture2D) {
    return data;
  }

  return new _core2.Texture2D(gl, Object.assign({
    data: data
  }, opts));
}

function validateGeometryAttributes(attributes) {
  assert(attributes.positions || attributes.POSITION, 'SimpleMeshLayer requires "postions" or "POSITION" attribute in mesh property.');
}

function getGeometry(data) {
  if (data.attributes) {
    validateGeometryAttributes(data.attributes);

    if (data instanceof _core2.Geometry) {
      return data;
    } else {
      return new _core2.Geometry(data);
    }
  } else if (data.positions || data.POSITION) {
    validateGeometryAttributes(data);
    return new _core2.Geometry({
      attributes: data
    });
  }

  throw Error('Invalid mesh');
}

var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultMaterial = new _core2.PhongMaterial();
var defaultProps = {
  mesh: {
    value: null,
    type: 'object',
    async: true
  },
  texture: null,
  sizeScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  parameters: {
    depthTest: true,
    depthFunc: 515
  },
  wireframe: false,
  material: defaultMaterial,
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getOrientation: {
    type: 'accessor',
    value: [0, 0, 0]
  },
  getScale: {
    type: 'accessor',
    value: [1, 1, 1]
  },
  getTranslation: {
    type: 'accessor',
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: 'accessor',
    value: []
  }
};

var SimpleMeshLayer = function (_Layer) {
  (0, _inherits2.default)(SimpleMeshLayer, _Layer);

  function SimpleMeshLayer() {
    (0, _classCallCheck2.default)(this, SimpleMeshLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SimpleMeshLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(SimpleMeshLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var gl2 = (0, _core2.isWebGL2)(this.context.gl);
      var vs = gl2 ? _simpleMeshLayerVertex2.default : _simpleMeshLayerVertex.default;
      var fs = gl2 ? _simpleMeshLayerFragment2.default : _simpleMeshLayerFragment.default;
      return (0, _get2.default)((0, _getPrototypeOf2.default)(SimpleMeshLayer.prototype), "getShaders", this).call(this, {
        vs: vs,
        fs: fs,
        modules: ['project32', 'phong-lighting', 'picking']
      });
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          transition: true,
          size: 3,
          accessor: 'getPosition'
        },
        instancePositions64xy: {
          size: 2,
          accessor: 'getPosition',
          update: this.calculateInstancePositions64xyLow
        },
        instanceColors: {
          type: 5121,
          transition: true,
          size: this.props.colorFormat.length,
          normalized: true,
          accessor: 'getColor',
          defaultValue: [0, 0, 0, 255]
        },
        instanceModelMatrix: _matrix.MATRIX_ATTRIBUTES
      });
      this.setState({
        emptyTexture: new _core2.Texture2D(this.context.gl, {
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(SimpleMeshLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });

      if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
        if (this.state.model) {
          this.state.model.delete();
        }

        if (props.mesh) {
          this.setState({
            model: this.getModel(props.mesh)
          });
          var attributes = props.mesh.attributes || props.mesh;
          this.setState({
            hasNormals: Boolean(attributes.NORMAL || attributes.normals)
          });
        }

        this.getAttributeManager().invalidateAll();
      }

      if (props.texture !== oldProps.texture) {
        this.setTexture(props.texture);
      }

      if (this.state.model) {
        this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
      }
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(SimpleMeshLayer.prototype), "finalizeState", this).call(this);
      this.state.emptyTexture.delete();

      if (this.state.texture) {
        this.state.texture.delete();
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;

      if (!this.state.model) {
        return;
      }

      var sizeScale = this.props.sizeScale;
      this.state.model.draw({
        uniforms: Object.assign({}, uniforms, {
          sizeScale: sizeScale,
          flatShade: !this.state.hasNormals
        })
      });
    }
  }, {
    key: "getModel",
    value: function getModel(mesh) {
      var model = new _core2.Model(this.context.gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: getGeometry(mesh),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
      var _this$state = this.state,
          texture = _this$state.texture,
          emptyTexture = _this$state.emptyTexture;
      model.setUniforms({
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      });
      return model;
    }
  }, {
    key: "setTexture",
    value: function setTexture(image) {
      var gl = this.context.gl;
      var _this$state2 = this.state,
          emptyTexture = _this$state2.emptyTexture,
          model = _this$state2.model;

      if (this.state.texture) {
        this.state.texture.delete();
      }

      var texture = image ? getTextureFromData(gl, image) : null;
      this.setState({
        texture: texture
      });

      if (model) {
        model.setUniforms({
          sampler: texture || emptyTexture,
          hasTexture: Boolean(texture)
        });
      }
    }
  }, {
    key: "calculateInstancePositions64xyLow",
    value: function calculateInstancePositions64xyLow(attribute, _ref3) {
      var startRow = _ref3.startRow,
          endRow = _ref3.endRow;
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      var _this$props = this.props,
          data = _this$props.data,
          getPosition = _this$props.getPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var position = getPosition(object, objectInfo);
          value[i++] = (0, _core.fp64LowPart)(position[0]);
          value[i++] = (0, _core.fp64LowPart)(position[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return SimpleMeshLayer;
}(_core.Layer);

exports.default = SimpleMeshLayer;
SimpleMeshLayer.layerName = 'SimpleMeshLayer';
SimpleMeshLayer.defaultProps = defaultProps;

},{"../utils/matrix":147,"./simple-mesh-layer-fragment.glsl":142,"./simple-mesh-layer-fragment.glsl1":143,"./simple-mesh-layer-vertex.glsl":144,"./simple-mesh-layer-vertex.glsl1":145,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@deck.gl/core":58,"@luma.gl/core":253}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MATRIX_ATTRIBUTES = void 0;

var _core = require("@deck.gl/core");

var RADIAN_PER_DEGREE = Math.PI / 180;
var modelMatrix = new Float32Array(16);
var valueArray = new Float32Array(12);

function calculateTransformMatrix(targetMatrix, orientation, scale) {
  var pitch = orientation[0] * RADIAN_PER_DEGREE;
  var yaw = orientation[1] * RADIAN_PER_DEGREE;
  var roll = orientation[2] * RADIAN_PER_DEGREE;
  var sr = Math.sin(roll);
  var sp = Math.sin(pitch);
  var sw = Math.sin(yaw);
  var cr = Math.cos(roll);
  var cp = Math.cos(pitch);
  var cw = Math.cos(yaw);
  var scx = scale[0];
  var scy = scale[1];
  var scz = scale[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}

function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}

var MATRIX_ATTRIBUTES = {
  size: 12,
  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],
  shaderAttributes: {
    instanceModelMatrix__LOCATION_0: {
      size: 3,
      stride: 48,
      offset: 0
    },
    instanceModelMatrix__LOCATION_1: {
      size: 3,
      stride: 48,
      offset: 12
    },
    instanceModelMatrix__LOCATION_2: {
      size: 3,
      stride: 48,
      offset: 24
    },
    instanceTranslation: {
      size: 3,
      stride: 48,
      offset: 36
    }
  },
  update: function update(attribute, _ref) {
    var startRow = _ref.startRow,
        endRow = _ref.endRow;
    var _this$props = this.props,
        data = _this$props.data,
        getOrientation = _this$props.getOrientation,
        getScale = _this$props.getScale,
        getTranslation = _this$props.getTranslation,
        getTransformMatrix = _this$props.getTransformMatrix;
    var arrayMatrix = Array.isArray(getTransformMatrix);
    var constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
    var constantScale = Array.isArray(getScale);
    var constantOrientation = Array.isArray(getOrientation);
    var constantTranslation = Array.isArray(getTranslation);
    var hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));

    if (hasMatrix) {
      attribute.constant = constantMatrix;
    } else {
      attribute.constant = constantOrientation && constantScale && constantTranslation;
    }

    var instanceModelMatrixData = attribute.value;

    if (attribute.constant) {
      var matrix;

      if (hasMatrix) {
        modelMatrix.set(getTransformMatrix);
        matrix = getExtendedMat3FromMat4(modelMatrix);
      } else {
        matrix = valueArray;
        var orientation = getOrientation;
        var scale = getScale;
        calculateTransformMatrix(matrix, orientation, scale);
        matrix.set(getTranslation, 9);
      }

      attribute.value = new Float32Array(matrix);
    } else {
      var i = startRow * attribute.size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;

          var _matrix = void 0;

          if (hasMatrix) {
            modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
            _matrix = getExtendedMat3FromMat4(modelMatrix);
          } else {
            _matrix = valueArray;

            var _orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);

            var _scale = constantScale ? getScale : getScale(object, objectInfo);

            calculateTransformMatrix(_matrix, _orientation, _scale);

            _matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
          }

          instanceModelMatrixData[i++] = _matrix[0];
          instanceModelMatrixData[i++] = _matrix[1];
          instanceModelMatrixData[i++] = _matrix[2];
          instanceModelMatrixData[i++] = _matrix[3];
          instanceModelMatrixData[i++] = _matrix[4];
          instanceModelMatrixData[i++] = _matrix[5];
          instanceModelMatrixData[i++] = _matrix[6];
          instanceModelMatrixData[i++] = _matrix[7];
          instanceModelMatrixData[i++] = _matrix[8];
          instanceModelMatrixData[i++] = _matrix[9];
          instanceModelMatrixData[i++] = _matrix[10];
          instanceModelMatrixData[i++] = _matrix[11];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }
};
exports.MATRIX_ATTRIBUTES = MATRIX_ATTRIBUTES;

},{"@deck.gl/core":58}],148:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReadStream = createReadStream;
exports.parseFile = parseFile;
exports.parseFileSync = parseFileSync;
exports.loadFile = loadFile;
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function get() {
    return _parse.parseSync;
  }
});
Object.defineProperty(exports, "parseInBatches", {
  enumerable: true,
  get: function get() {
    return _parse.parseInBatches;
  }
});
Object.defineProperty(exports, "parseInBatchesSync", {
  enumerable: true,
  get: function get() {
    return _parse.parseInBatchesSync;
  }
});
Object.defineProperty(exports, "fetchFile", {
  enumerable: true,
  get: function get() {
    return _fetchFile.fetchFile;
  }
});
Object.defineProperty(exports, "load", {
  enumerable: true,
  get: function get() {
    return _load.load;
  }
});
Object.defineProperty(exports, "loadInBatches", {
  enumerable: true,
  get: function get() {
    return _load.loadInBatches;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases2.setPathPrefix;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases2.getPathPrefix;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function get() {
    return _fileAliases2.resolvePath;
  }
});
Object.defineProperty(exports, "readFileSync", {
  enumerable: true,
  get: function get() {
    return _readFile.readFileSync;
  }
});
Object.defineProperty(exports, "writeFile", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFile;
  }
});
Object.defineProperty(exports, "writeFileSync", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFileSync;
  }
});
Object.defineProperty(exports, "_getErrorMessageFromResponseSync", {
  enumerable: true,
  get: function get() {
    return _fetchErrorMessage.getErrorMessageFromResponseSync;
  }
});
Object.defineProperty(exports, "_getErrorMessageFromResponse", {
  enumerable: true,
  get: function get() {
    return _fetchErrorMessage.getErrorMessageFromResponse;
  }
});
Object.defineProperty(exports, "registerLoaders", {
  enumerable: true,
  get: function get() {
    return _registerLoaders.registerLoaders;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function get() {
    return _encode.encode;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function get() {
    return _encode.encodeSync;
  }
});
Object.defineProperty(exports, "encodeInBatches", {
  enumerable: true,
  get: function get() {
    return _encode.encodeInBatches;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function get() {
    return _save.save;
  }
});
Object.defineProperty(exports, "saveSync", {
  enumerable: true,
  get: function get() {
    return _save.saveSync;
  }
});
Object.defineProperty(exports, "isPromise", {
  enumerable: true,
  get: function get() {
    return _isType.isPromise;
  }
});
Object.defineProperty(exports, "isIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isIterable;
  }
});
Object.defineProperty(exports, "isAsyncIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isAsyncIterable;
  }
});
Object.defineProperty(exports, "isIterator", {
  enumerable: true,
  get: function get() {
    return _isType.isIterator;
  }
});
Object.defineProperty(exports, "isFetchResponse", {
  enumerable: true,
  get: function get() {
    return _isType.isFetchResponse;
  }
});
Object.defineProperty(exports, "isReadableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isReadableStream;
  }
});
Object.defineProperty(exports, "isWritableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isWritableStream;
  }
});
Object.defineProperty(exports, "toArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _binaryUtils.toArrayBuffer;
  }
});
Object.defineProperty(exports, "getStreamIterator", {
  enumerable: true,
  get: function get() {
    return _streamUtils.getStreamIterator;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function get() {
    return _asyncIteratorUtils.forEach;
  }
});
Object.defineProperty(exports, "concatenateAsyncIterator", {
  enumerable: true,
  get: function get() {
    return _asyncIteratorUtils.concatenateAsyncIterator;
  }
});
Object.defineProperty(exports, "lineAsyncIterator", {
  enumerable: true,
  get: function get() {
    return _asyncIteratorUtils.lineAsyncIterator;
  }
});
Object.defineProperty(exports, "textDecoderAsyncIterator", {
  enumerable: true,
  get: function get() {
    return _asyncIteratorUtils.textDecoderAsyncIterator;
  }
});
Object.defineProperty(exports, "numberedLineAsyncIterator", {
  enumerable: true,
  get: function get() {
    return _asyncIteratorUtils.numberedLineAsyncIterator;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert["default"];
  }
});
exports.TextDecoder = exports.TextEncoder = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _parse = require("./lib/parse");

var _fetchFile = require("./lib/fetch/fetch-file");

var _load = require("./lib/load");

var _fileAliases = require("./lib/fetch/file-aliases");

var _globals = require("./utils/globals");

var _fileAliases2 = require("./lib/fetch/file-aliases.js");

var _readFile = require("./lib/fetch/read-file");

var _writeFile = require("./lib/fetch/write-file");

var _fetchErrorMessage = require("./lib/fetch/fetch-error-message");

var _registerLoaders = require("./lib/register-loaders");

var _encode = require("./lib/encode");

var _save = require("./lib/save");

var _isType = require("./javascript-utils/is-type");

var _binaryUtils = require("./javascript-utils/binary-utils");

var _streamUtils = require("./javascript-utils/stream-utils");

var _asyncIteratorUtils = require("./javascript-utils/async-iterator-utils");

var _assert = _interopRequireDefault(require("./utils/assert"));

var TextEncoder = _globals.global.TextEncoder;
exports.TextEncoder = TextEncoder;
var TextDecoder = _globals.global.TextDecoder;
exports.TextDecoder = TextDecoder;

function createReadStream(_x, _x2) {
  return _createReadStream.apply(this, arguments);
}

function _createReadStream() {
  _createReadStream = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(url, options) {
    var response;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.warn('createReadStream() deprecated, use fetch().then(resp => resp.body)');
            url = (0, _fileAliases.resolvePath)(url);
            _context.next = 4;
            return (0, _fetchFile.fetchFile)(url, options);

          case 4:
            response = _context.sent;
            return _context.abrupt("return", response.body);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createReadStream.apply(this, arguments);
}

function parseFile() {
  console.warn('parse() deprecated, use parse()');
  return _parse.parse.apply(void 0, arguments);
}

function parseFileSync() {
  console.warn('parseSync() deprecated, use parseSync()');
  return _parse.parseSync.apply(void 0, arguments);
}

function loadFile() {
  console.warn('loadFile() deprecated, use load()');
  return _load.load.apply(void 0, arguments);
}

},{"./javascript-utils/async-iterator-utils":149,"./javascript-utils/binary-utils":150,"./javascript-utils/is-type":151,"./javascript-utils/stream-utils":153,"./lib/encode":154,"./lib/fetch/fetch-error-message":155,"./lib/fetch/fetch-file":157,"./lib/fetch/file-aliases":158,"./lib/fetch/file-aliases.js":158,"./lib/fetch/read-file":160,"./lib/fetch/write-file":161,"./lib/load":162,"./lib/parse":170,"./lib/register-loaders":171,"./lib/save":172,"./utils/assert":177,"./utils/globals":178,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],149:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = forEach;
exports.concatenateAsyncIterator = concatenateAsyncIterator;
exports.textDecoderAsyncIterator = textDecoderAsyncIterator;
exports.textEncoderAsyncIterator = textEncoderAsyncIterator;
exports.lineAsyncIterator = lineAsyncIterator;
exports.numberedLineAsyncIterator = numberedLineAsyncIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _memoryCopyUtils = require("../javascript-utils/memory-copy-utils");

function forEach(_x7, _x8) {
  return _forEach.apply(this, arguments);
}

function _forEach() {
  _forEach = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(iterator, visitor) {
    var _ref, done, value, cancel;

    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!true) {
              _context5.next = 14;
              break;
            }

            _context5.next = 3;
            return iterator.next();

          case 3:
            _ref = _context5.sent;
            done = _ref.done;
            value = _ref.value;

            if (!done) {
              _context5.next = 9;
              break;
            }

            iterator["return"]();
            return _context5.abrupt("return");

          case 9:
            cancel = visitor(value);

            if (!cancel) {
              _context5.next = 12;
              break;
            }

            return _context5.abrupt("return");

          case 12:
            _context5.next = 0;
            break;

          case 14:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _forEach.apply(this, arguments);
}

function concatenateAsyncIterator(_x9) {
  return _concatenateAsyncIterator.apply(this, arguments);
}

function _concatenateAsyncIterator() {
  _concatenateAsyncIterator = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(asyncIterator) {
    var arrayBuffer, string, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            arrayBuffer = new ArrayBuffer();
            string = '';
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context6.prev = 4;
            _iterator = (0, _asyncIterator2["default"])(asyncIterator);

          case 6:
            _context6.next = 8;
            return _iterator.next();

          case 8:
            _step = _context6.sent;
            _iteratorNormalCompletion = _step.done;
            _context6.next = 12;
            return _step.value;

          case 12:
            _value = _context6.sent;

            if (_iteratorNormalCompletion) {
              _context6.next = 19;
              break;
            }

            chunk = _value;

            if (typeof chunk === 'string') {
              string += chunk;
            } else {
              arrayBuffer = (0, _memoryCopyUtils.concatenateArrayBuffers)(arrayBuffer, chunk);
            }

          case 16:
            _iteratorNormalCompletion = true;
            _context6.next = 6;
            break;

          case 19:
            _context6.next = 25;
            break;

          case 21:
            _context6.prev = 21;
            _context6.t0 = _context6["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 25:
            _context6.prev = 25;
            _context6.prev = 26;

            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context6.next = 30;
              break;
            }

            _context6.next = 30;
            return _iterator["return"]();

          case 30:
            _context6.prev = 30;

            if (!_didIteratorError) {
              _context6.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return _context6.finish(30);

          case 34:
            return _context6.finish(25);

          case 35:
            return _context6.abrupt("return", string || arrayBuffer);

          case 36:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[4, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _concatenateAsyncIterator.apply(this, arguments);
}

function textDecoderAsyncIterator(_x, _x2) {
  return _textDecoderAsyncIterator.apply(this, arguments);
}

function _textDecoderAsyncIterator() {
  _textDecoderAsyncIterator = (0, _wrapAsyncGenerator2["default"])(_regenerator["default"].mark(function _callee(arrayBufferIterator, options) {
    var textDecoder, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, arrayBuffer;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            textDecoder = new TextDecoder(options);
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context.prev = 3;
            _iterator2 = (0, _asyncIterator2["default"])(arrayBufferIterator);

          case 5:
            _context.next = 7;
            return (0, _awaitAsyncGenerator2["default"])(_iterator2.next());

          case 7:
            _step2 = _context.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context.next = 11;
            return (0, _awaitAsyncGenerator2["default"])(_step2.value);

          case 11:
            _value2 = _context.sent;

            if (_iteratorNormalCompletion2) {
              _context.next = 19;
              break;
            }

            arrayBuffer = _value2;
            _context.next = 16;
            return typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
              stream: true
            });

          case 16:
            _iteratorNormalCompletion2 = true;
            _context.next = 5;
            break;

          case 19:
            _context.next = 25;
            break;

          case 21:
            _context.prev = 21;
            _context.t0 = _context["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context.t0;

          case 25:
            _context.prev = 25;
            _context.prev = 26;

            if (!(!_iteratorNormalCompletion2 && _iterator2["return"] != null)) {
              _context.next = 30;
              break;
            }

            _context.next = 30;
            return (0, _awaitAsyncGenerator2["default"])(_iterator2["return"]());

          case 30:
            _context.prev = 30;

            if (!_didIteratorError2) {
              _context.next = 33;
              break;
            }

            throw _iteratorError2;

          case 33:
            return _context.finish(30);

          case 34:
            return _context.finish(25);

          case 35:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _textDecoderAsyncIterator.apply(this, arguments);
}

function textEncoderAsyncIterator(_x3, _x4) {
  return _textEncoderAsyncIterator.apply(this, arguments);
}

function _textEncoderAsyncIterator() {
  _textEncoderAsyncIterator = (0, _wrapAsyncGenerator2["default"])(_regenerator["default"].mark(function _callee2(textIterator, options) {
    var textEncoder, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, text;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textEncoder = new TextEncoder();
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _context2.prev = 3;
            _iterator3 = (0, _asyncIterator2["default"])(textIterator);

          case 5:
            _context2.next = 7;
            return (0, _awaitAsyncGenerator2["default"])(_iterator3.next());

          case 7:
            _step3 = _context2.sent;
            _iteratorNormalCompletion3 = _step3.done;
            _context2.next = 11;
            return (0, _awaitAsyncGenerator2["default"])(_step3.value);

          case 11:
            _value3 = _context2.sent;

            if (_iteratorNormalCompletion3) {
              _context2.next = 19;
              break;
            }

            text = _value3;
            _context2.next = 16;
            return typeof text === 'string' ? textEncoder.encode(text) : text;

          case 16:
            _iteratorNormalCompletion3 = true;
            _context2.next = 5;
            break;

          case 19:
            _context2.next = 25;
            break;

          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError3 = true;
            _iteratorError3 = _context2.t0;

          case 25:
            _context2.prev = 25;
            _context2.prev = 26;

            if (!(!_iteratorNormalCompletion3 && _iterator3["return"] != null)) {
              _context2.next = 30;
              break;
            }

            _context2.next = 30;
            return (0, _awaitAsyncGenerator2["default"])(_iterator3["return"]());

          case 30:
            _context2.prev = 30;

            if (!_didIteratorError3) {
              _context2.next = 33;
              break;
            }

            throw _iteratorError3;

          case 33:
            return _context2.finish(30);

          case 34:
            return _context2.finish(25);

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _textEncoderAsyncIterator.apply(this, arguments);
}

function lineAsyncIterator(_x5) {
  return _lineAsyncIterator.apply(this, arguments);
}

function _lineAsyncIterator() {
  _lineAsyncIterator = (0, _wrapAsyncGenerator2["default"])(_regenerator["default"].mark(function _callee3(textIterator) {
    var previous, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, textChunk, eolIndex, line;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            previous = '';
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _context3.prev = 3;
            _iterator4 = (0, _asyncIterator2["default"])(textIterator);

          case 5:
            _context3.next = 7;
            return (0, _awaitAsyncGenerator2["default"])(_iterator4.next());

          case 7:
            _step4 = _context3.sent;
            _iteratorNormalCompletion4 = _step4.done;
            _context3.next = 11;
            return (0, _awaitAsyncGenerator2["default"])(_step4.value);

          case 11:
            _value4 = _context3.sent;

            if (_iteratorNormalCompletion4) {
              _context3.next = 26;
              break;
            }

            textChunk = _value4;
            previous += textChunk;
            eolIndex = void 0;

          case 16:
            if (!((eolIndex = previous.indexOf('\n')) >= 0)) {
              _context3.next = 23;
              break;
            }

            line = previous.slice(0, eolIndex + 1);
            previous = previous.slice(eolIndex + 1);
            _context3.next = 21;
            return line;

          case 21:
            _context3.next = 16;
            break;

          case 23:
            _iteratorNormalCompletion4 = true;
            _context3.next = 5;
            break;

          case 26:
            _context3.next = 32;
            break;

          case 28:
            _context3.prev = 28;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError4 = true;
            _iteratorError4 = _context3.t0;

          case 32:
            _context3.prev = 32;
            _context3.prev = 33;

            if (!(!_iteratorNormalCompletion4 && _iterator4["return"] != null)) {
              _context3.next = 37;
              break;
            }

            _context3.next = 37;
            return (0, _awaitAsyncGenerator2["default"])(_iterator4["return"]());

          case 37:
            _context3.prev = 37;

            if (!_didIteratorError4) {
              _context3.next = 40;
              break;
            }

            throw _iteratorError4;

          case 40:
            return _context3.finish(37);

          case 41:
            return _context3.finish(32);

          case 42:
            if (!(previous.length > 0)) {
              _context3.next = 45;
              break;
            }

            _context3.next = 45;
            return previous;

          case 45:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 28, 32, 42], [33,, 37, 41]]);
  }));
  return _lineAsyncIterator.apply(this, arguments);
}

function numberedLineAsyncIterator(_x6) {
  return _numberedLineAsyncIterator.apply(this, arguments);
}

function _numberedLineAsyncIterator() {
  _numberedLineAsyncIterator = (0, _wrapAsyncGenerator2["default"])(_regenerator["default"].mark(function _callee4(lineIterator) {
    var counter, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _value5, line;

    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            counter = 1;
            _iteratorNormalCompletion5 = true;
            _didIteratorError5 = false;
            _context4.prev = 3;
            _iterator5 = (0, _asyncIterator2["default"])(lineIterator);

          case 5:
            _context4.next = 7;
            return (0, _awaitAsyncGenerator2["default"])(_iterator5.next());

          case 7:
            _step5 = _context4.sent;
            _iteratorNormalCompletion5 = _step5.done;
            _context4.next = 11;
            return (0, _awaitAsyncGenerator2["default"])(_step5.value);

          case 11:
            _value5 = _context4.sent;

            if (_iteratorNormalCompletion5) {
              _context4.next = 20;
              break;
            }

            line = _value5;
            _context4.next = 16;
            return {
              counter: counter,
              line: line
            };

          case 16:
            counter++;

          case 17:
            _iteratorNormalCompletion5 = true;
            _context4.next = 5;
            break;

          case 20:
            _context4.next = 26;
            break;

          case 22:
            _context4.prev = 22;
            _context4.t0 = _context4["catch"](3);
            _didIteratorError5 = true;
            _iteratorError5 = _context4.t0;

          case 26:
            _context4.prev = 26;
            _context4.prev = 27;

            if (!(!_iteratorNormalCompletion5 && _iterator5["return"] != null)) {
              _context4.next = 31;
              break;
            }

            _context4.next = 31;
            return (0, _awaitAsyncGenerator2["default"])(_iterator5["return"]());

          case 31:
            _context4.prev = 31;

            if (!_didIteratorError5) {
              _context4.next = 34;
              break;
            }

            throw _iteratorError5;

          case 34:
            return _context4.finish(31);

          case 35:
            return _context4.finish(26);

          case 36:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _numberedLineAsyncIterator.apply(this, arguments);
}

},{"../javascript-utils/memory-copy-utils":152,"@babel/runtime/helpers/asyncIterator":15,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/awaitAsyncGenerator":17,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/wrapAsyncGenerator":41,"@babel/runtime/regenerator":43}],150:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayBuffer = toArrayBuffer;

var _assert = _interopRequireDefault(require("../utils/assert"));

var _toArrayBuffer = require("../node/utils/to-array-buffer.node");

function toArrayBuffer(data) {
  if (_toArrayBuffer.toArrayBuffer) {
    data = (0, _toArrayBuffer.toArrayBuffer)(data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    var text = data;
    var uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  return (0, _assert["default"])(false);
}

},{"../node/utils/to-array-buffer.node":174,"../utils/assert":177,"@babel/runtime/helpers/interopRequireDefault":25}],151:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWritableStream = exports.isReadableStream = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isFileReadable = exports.isBlob = exports.isFile = exports.isFetchResponse = exports.isIterator = exports.isAsyncIterable = exports.isIterable = exports.isPromise = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var isBoolean = function isBoolean(x) {
  return typeof x === 'boolean';
};

var isFunction = function isFunction(x) {
  return typeof x === 'function';
};

var isObject = function isObject(x) {
  return x !== null && (0, _typeof2["default"])(x) === 'object';
};

var isPromise = function isPromise(x) {
  return isObject(x) && isFunction(x.then);
};

exports.isPromise = isPromise;

var isIterable = function isIterable(x) {
  return x && typeof x[Symbol.iterator] === 'function';
};

exports.isIterable = isIterable;

var isAsyncIterable = function isAsyncIterable(x) {
  return x && typeof x[Symbol.asyncIterator] === 'function';
};

exports.isAsyncIterable = isAsyncIterable;

var isIterator = function isIterator(x) {
  return x && isFunction(x.next);
};

exports.isIterator = isIterator;

var isFetchResponse = function isFetchResponse(x) {
  return typeof Response !== 'undefined' && x instanceof Response || x.arrayBuffer && x.text && x.json;
};

exports.isFetchResponse = isFetchResponse;

var isFile = function isFile(x) {
  return typeof File !== 'undefined' && x instanceof File;
};

exports.isFile = isFile;

var isBlob = function isBlob(x) {
  return typeof Blob !== 'undefined' && x instanceof Blob;
};

exports.isBlob = isBlob;

var isFileReadable = function isFileReadable(x) {
  return isFile(x) || isBlob(x);
};

exports.isFileReadable = isFileReadable;

var isWritableDOMStream = function isWritableDOMStream(x) {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};

exports.isWritableDOMStream = isWritableDOMStream;

var isReadableDOMStream = function isReadableDOMStream(x) {
  return isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.pipeTo) && isFunction(x.getReader);
};

exports.isReadableDOMStream = isReadableDOMStream;

var isWritableNodeStream = function isWritableNodeStream(x) {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};

exports.isWritableNodeStream = isWritableNodeStream;

var isReadableNodeStream = function isReadableNodeStream(x) {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

exports.isReadableNodeStream = isReadableNodeStream;

var isReadableStream = function isReadableStream(x) {
  return isReadableDOMStream(x) || isReadableNodeStream(x);
};

exports.isReadableStream = isReadableStream;

var isWritableStream = function isWritableStream(x) {
  return isWritableDOMStream(x) || isWritableNodeStream(x);
};

exports.isWritableStream = isWritableStream;

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatenateArrayBuffers = concatenateArrayBuffers;

function concatenateArrayBuffers(source1, source2) {
  var sourceArray1 = source1 instanceof ArrayBuffer ? new Uint8Array(source1) : source1;
  var sourceArray2 = source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  var temp = new Uint8Array(sourceArray1.byteLength + sourceArray2.byteLength);
  temp.set(sourceArray1, 0);
  temp.set(sourceArray2, sourceArray1.byteLength);
  return temp;
}

},{}],153:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStreamIterator = getStreamIterator;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _globals = require("../utils/globals");

function getStreamIterator(stream) {
  if (_globals.isBrowser || _globals.nodeVersion >= 10) {
    if (typeof stream[Symbol.asyncIterator] === 'function') {
      return stream;
    }

    if (typeof stream.getIterator === 'function') {
      return stream.getIterator();
    }
  }

  return _globals.isBrowser ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
}

function makeBrowserStreamIterator(_x) {
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = (0, _wrapAsyncGenerator2["default"])(_regenerator["default"].mark(function _callee(stream) {
    var reader, _ref, done, value;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reader = stream.getReader();
            _context.prev = 1;

          case 2:
            if (!true) {
              _context.next = 14;
              break;
            }

            _context.next = 5;
            return (0, _awaitAsyncGenerator2["default"])(reader.read());

          case 5:
            _ref = _context.sent;
            done = _ref.done;
            value = _ref.value;

            if (!done) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return");

          case 10:
            _context.next = 12;
            return value;

          case 12:
            _context.next = 2;
            break;

          case 14:
            _context.prev = 14;
            reader.releaseLock();
            return _context.finish(14);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1,, 14, 17]]);
  }));
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function makeNodeStreamIterator(_x2) {
  return _makeNodeStreamIterator.apply(this, arguments);
}

function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = (0, _wrapAsyncGenerator2["default"])(_regenerator["default"].mark(function _callee2(stream) {
    var data;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0, _awaitAsyncGenerator2["default"])(stream);

          case 2:
            stream = _context2.sent;

          case 3:
            if (!true) {
              _context2.next = 15;
              break;
            }

            data = stream.read();

            if (!(data !== null)) {
              _context2.next = 9;
              break;
            }

            _context2.next = 8;
            return data;

          case 8:
            return _context2.abrupt("continue", 3);

          case 9:
            if (!stream._readableState.ended) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt("return");

          case 11:
            _context2.next = 13;
            return (0, _awaitAsyncGenerator2["default"])(onceReadable(stream));

          case 13:
            _context2.next = 3;
            break;

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _makeNodeStreamIterator.apply(this, arguments);
}

function onceReadable(_x3) {
  return _onceReadable.apply(this, arguments);
}

function _onceReadable() {
  _onceReadable = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(stream) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", new Promise(function (resolve) {
              stream.once('readable', resolve);
            }));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _onceReadable.apply(this, arguments);
}

},{"../utils/globals":178,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/awaitAsyncGenerator":17,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/wrapAsyncGenerator":41,"@babel/runtime/regenerator":43}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeSync = encodeSync;
exports.encodeInBatches = encodeInBatches;

function encode(data, writer, options, url) {
  if (writer.encode) {
    return writer.encode(data, options);
  }

  if (writer.encodeSync) {
    return Promise.resolve(writer.encodeSync(data, options));
  }

  throw new Error('Writer could not encode data');
}

function encodeSync(data, writer, options, url) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}

function encodeInBatches(data, writer, options, url) {
  if (writer.encodeInBatches) {
    return writer.encodeInBatches(data, options);
  }

  throw new Error('Writer could not encode data in batches');
}

},{}],155:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getErrorMessageFromResponseSync = getErrorMessageFromResponseSync;
exports.getErrorMessageFromResponse = getErrorMessageFromResponse;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function getErrorMessageFromResponseSync(response) {
  return "Failed to fetch resource ".concat(response.url, "(").concat(response.status, "): ").concat(response.statusText, " ");
}

function getErrorMessageFromResponse(_x) {
  return _getErrorMessageFromResponse.apply(this, arguments);
}

function _getErrorMessageFromResponse() {
  _getErrorMessageFromResponse = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(response) {
    var message, contentType;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
            _context.prev = 1;
            contentType = response.headers.get('Content-Type');

            if (!contentType.includes('application/json')) {
              _context.next = 10;
              break;
            }

            _context.t0 = message;
            _context.next = 7;
            return response.text();

          case 7:
            message = _context.t0 += _context.sent;
            _context.next = 11;
            break;

          case 10:
            message += response.statusText;

          case 11:
            _context.next = 16;
            break;

          case 13:
            _context.prev = 13;
            _context.t1 = _context["catch"](1);
            return _context.abrupt("return", message);

          case 16:
            return _context.abrupt("return", message);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 13]]);
  }));
  return _getErrorMessageFromResponse.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],156:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = fetchFileReadable;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assert = _interopRequireDefault(require("../../utils/assert"));

var FileReadableResponse = function () {
  function FileReadableResponse(fileOrBlob) {
    (0, _classCallCheck2["default"])(this, FileReadableResponse);
    this._fileOrBlob = fileOrBlob;
    this.bodyUsed = false;
  }

  (0, _createClass2["default"])(FileReadableResponse, [{
    key: "url",
    value: function url() {
      return this._fileOrBlob.name || '';
    }
  }, {
    key: "arrayBuffer",
    value: function () {
      var _arrayBuffer = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
        var _this$_getFileReader, reader, promise;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$_getFileReader = this._getFileReader(), reader = _this$_getFileReader.reader, promise = _this$_getFileReader.promise;
                reader.readAsArrayBuffer(this._fileOrBlob);
                return _context.abrupt("return", promise);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function arrayBuffer() {
        return _arrayBuffer.apply(this, arguments);
      }

      return arrayBuffer;
    }()
  }, {
    key: "text",
    value: function () {
      var _text = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
        var _this$_getFileReader2, reader, promise;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this$_getFileReader2 = this._getFileReader(), reader = _this$_getFileReader2.reader, promise = _this$_getFileReader2.promise;
                reader.readAsText(this._fileOrBlob);
                return _context2.abrupt("return", promise);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function text() {
        return _text.apply(this, arguments);
      }

      return text;
    }()
  }, {
    key: "json",
    value: function () {
      var _json = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
        var text;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.text();

              case 2:
                text = _context3.sent;
                return _context3.abrupt("return", JSON.parse(text));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function json() {
        return _json.apply(this, arguments);
      }

      return json;
    }()
  }, {
    key: "_getFileReader",
    value: function _getFileReader() {
      (0, _assert["default"])(!this.bodyUsed);
      this.bodyUsed = true;
      var reader;
      var promise = new Promise(function (resolve, reject) {
        try {
          reader = new FileReader();

          reader.onerror = function (error) {
            return reject(new Error(error));
          };

          reader.onabort = function () {
            return reject(new Error('Read aborted.'));
          };

          reader.onload = function () {
            return resolve(reader.result);
          };
        } catch (error) {
          reject(error);
        }
      });
      return {
        reader: reader,
        promise: promise
      };
    }
  }, {
    key: "headers",
    get: function get() {
      return new Headers({
        'Content-Length': this._fileOrBlob.size,
        'Content-Type': this._fileOrBlob.type
      });
    }
  }]);
  return FileReadableResponse;
}();

function fetchFileReadable(fileOrBlob, options) {
  return Promise.resolve(new FileReadableResponse(fileOrBlob, options));
}

},{"../../utils/assert":177,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],157:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchFile = fetchFile;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _fileAliases = require("./file-aliases");

var _fetchFile2 = _interopRequireDefault(require("./fetch-file.browser"));

function fetchFile(_x, _x2) {
  return _fetchFile.apply(this, arguments);
}

function _fetchFile() {
  _fetchFile = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(url, options) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(0, _isType.isFileReadable)(url)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", (0, _fetchFile2["default"])(url, options));

          case 2:
            url = (0, _fileAliases.resolvePath)(url);
            return _context.abrupt("return", fetch(url, options));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchFile.apply(this, arguments);
}

},{"../../javascript-utils/is-type":151,"./fetch-file.browser":156,"./file-aliases":158,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPathPrefix = setPathPrefix;
exports.getPathPrefix = getPathPrefix;
exports.addAliases = addAliases;
exports.resolvePath = resolvePath;
var pathPrefix = '';
var fileAliases = {};

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (var alias in fileAliases) {
    if (filename.startsWith(alias)) {
      var replacement = fileAliases[alias];
      return filename.replace(alias, replacement);
    }
  }

  filename += pathPrefix;
  return filename;
}

},{}],159:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSyncBrowser = readFileSyncBrowser;

var _assert = _interopRequireDefault(require("../../utils/assert"));

var DEFAULT_OPTIONS = {
  dataType: 'arraybuffer',
  nothrow: true
};

var isDataURL = function isDataURL(url) {
  return url.startsWith('data:');
};

function readFileSyncBrowser(uri, options) {
  options = getReadFileOptions(options);

  if (isDataURL(uri)) {}

  if (!options.nothrow) {
    (0, _assert["default"])(false);
  }

  return null;
}

function getReadFileOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  options.responseType = options.responseType || options.dataType;
  return options;
}

},{"../../utils/assert":177,"@babel/runtime/helpers/interopRequireDefault":25}],160:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;

var _globals = require("../../utils/globals");

var node = _interopRequireWildcard(require("../../node/read-file-sync.node"));

var _fileAliases = require("./file-aliases");

var _readFile = require("./read-file.browser");

function readFileSync(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  url = (0, _fileAliases.resolvePath)(url);

  if (!_globals.isBrowser && node.readFileSync) {
    return node.readFileSync(url, options);
  }

  return (0, _readFile.readFileSyncBrowser)(url, options);
}

},{"../../node/read-file-sync.node":173,"../../utils/globals":178,"./file-aliases":158,"./read-file.browser":159,"@babel/runtime/helpers/interopRequireWildcard":26}],161:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;

var _globals = require("../../utils/globals");

var _assert = _interopRequireDefault(require("../../utils/assert"));

var node = _interopRequireWildcard(require("../../node/write-file.node"));

var _fileAliases = require("./file-aliases");

function writeFile(filePath, arrayBufferOrString, options) {
  filePath = (0, _fileAliases.resolvePath)(filePath);

  if (!_globals.isBrowser && node.writeFile) {
    return node.writeFile(filePath, arrayBufferOrString, options);
  }

  return (0, _assert["default"])(false);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = (0, _fileAliases.resolvePath)(filePath);

  if (!_globals.isBrowser && node.writeFileSync) {
    return node.writeFileSync(filePath, arrayBufferOrString, options);
  }

  return (0, _assert["default"])(false);
}

},{"../../node/write-file.node":176,"../../utils/assert":177,"../../utils/globals":178,"./file-aliases":158,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26}],162:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadInBatches = loadInBatches;
exports.load = load;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../javascript-utils/is-type");

var _fetchFile = require("./fetch/fetch-file");

var _normalizeLoader = require("./loader-utils/normalize-loader");

var _normalizeOptions = require("./loader-utils/normalize-options");

var _autoDetectLoader = require("./loader-utils/auto-detect-loader");

var _parse = require("./parse");

var _registerLoaders = require("./register-loaders");

function loadInBatches(_x, _x2, _x3) {
  return _loadInBatches.apply(this, arguments);
}

function _loadInBatches() {
  _loadInBatches = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(url, loaders, options) {
    var response;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _fetchFile.fetchFile)(url, options);

          case 2:
            response = _context.sent;
            return _context.abrupt("return", (0, _parse.parseInBatches)(response, loaders, options, url));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadInBatches.apply(this, arguments);
}

function load(_x4, _x5, _x6) {
  return _load.apply(this, arguments);
}

function _load() {
  _load = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(url, loaders, options) {
    var autoUrl, loader, data;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              options = loaders;
              loaders = null;
            }

            autoUrl = (0, _isType.isFileReadable)(url) ? url.name : url;
            loaders = loaders || (0, _registerLoaders.getRegisteredLoaders)();
            loader = Array.isArray(loaders) ? (0, _autoDetectLoader.autoDetectLoader)(null, loaders, {
              url: autoUrl
            }) : loaders;
            options = (0, _normalizeOptions.mergeLoaderAndUserOptions)(options, loader);

            if (!(loader && loader.loadAndParse)) {
              _context2.next = 9;
              break;
            }

            _context2.next = 8;
            return loader.loadAndParse(url, options);

          case 8:
            return _context2.abrupt("return", _context2.sent);

          case 9:
            data = url;

            if (!((0, _isType.isFileReadable)(data) || typeof data === 'string')) {
              _context2.next = 14;
              break;
            }

            _context2.next = 13;
            return (0, _fetchFile.fetchFile)(url, options);

          case 13:
            data = _context2.sent;

          case 14:
            return _context2.abrupt("return", (0, _parse.parse)(data, loaders, options, autoUrl));

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _load.apply(this, arguments);
}

},{"../javascript-utils/is-type":151,"./fetch/fetch-file":157,"./loader-utils/auto-detect-loader":163,"./loader-utils/normalize-loader":165,"./loader-utils/normalize-options":166,"./parse":170,"./register-loaders":171,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],163:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoDetectLoader = autoDetectLoader;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _normalizeLoader = require("./normalize-loader");

var EXT_PATTERN = /[^.]+$/;

function autoDetectLoader(data, loaders) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$url = _ref.url,
      url = _ref$url === void 0 ? '' : _ref$url;

  var loader = null;
  loader = loader || findLoaderByUrl(loaders, url);
  loader = loader || findLoaderByExamingInitialData(loaders, data);
  return loader;
}

function findLoaderByUrl(loaders, url) {
  var match = url.match(EXT_PATTERN);
  var extension = match && match[0];
  var loader = extension && findLoaderByExtension(loaders, extension);
  return loader;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = loaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var loader = _step.value;
      (0, _normalizeLoader.normalizeLoader)(loader);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = loader.extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var loaderExtension = _step2.value;

          if (loaderExtension.toLowerCase() === extension) {
            return loader;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

function findLoaderByExamingInitialData(loaders, data) {
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = loaders[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var loader = _step3.value;

      if (typeof data === 'string') {
        if (testText(data, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        if (testBinary(data, loader)) {
          return loader;
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return null;
}

function testText(data, loader) {
  return loader.testText && loader.testText(data);
}

function testBinary(data, loader) {
  var type = Array.isArray(loader.test) ? 'array' : (0, _typeof2["default"])(loader.test);

  switch (type) {
    case 'function':
      return loader.test(data, loader);

    case 'string':
    case 'array':
      var byteOffset = 0;
      var tests = Array.isArray(loader.test) ? loader.test : [loader.test];
      return tests.some(function (test) {
        var magic = getMagicString(data, byteOffset, test.length);
        return test === magic;
      });

    default:
      return false;
  }
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }

  var dataView = new DataView(arrayBuffer);
  var magic = '';

  for (var i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}

},{"./normalize-loader":165,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],164:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUrlFromData = getUrlFromData;
exports.getArrayBufferOrStringFromDataSync = getArrayBufferOrStringFromDataSync;
exports.getArrayBufferOrStringFromData = getArrayBufferOrStringFromData;
exports.getAsyncIteratorFromData = getAsyncIteratorFromData;
exports.getIteratorFromData = getIteratorFromData;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _streamUtils = require("../../javascript-utils/stream-utils");

var _fetchFile = _interopRequireDefault(require("../fetch/fetch-file.browser"));

var ERR_DATA = 'Cannot convert supplied data type';

function getUrlFromData(data) {
  return (0, _isType.isFetchResponse)(data) ? data.url : null;
}

function getArrayBufferOrStringFromDataSync(data, loader) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    var arrayBuffer = data.buffer || data;

    if (loader.text && !loader.binary) {
      var textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }

    return arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

function getArrayBufferOrStringFromData(_x, _x2) {
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function _getArrayBufferOrStringFromData() {
  _getArrayBufferOrStringFromData = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(data, loader) {
    var isArrayBuffer;
    return _regenerator["default"].wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return data;

          case 2:
            data = _context2.sent;
            isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);

            if (!(typeof data === 'string' || isArrayBuffer)) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", getArrayBufferOrStringFromDataSync(data, loader));

          case 6:
            if (!(0, _isType.isFileReadable)(data)) {
              _context2.next = 10;
              break;
            }

            _context2.next = 9;
            return (0, _fetchFile["default"])(data);

          case 9:
            data = _context2.sent;

          case 10:
            if (!(0, _isType.isFetchResponse)(data)) {
              _context2.next = 19;
              break;
            }

            if (!loader.binary) {
              _context2.next = 17;
              break;
            }

            _context2.next = 14;
            return data.arrayBuffer();

          case 14:
            _context2.t0 = _context2.sent;
            _context2.next = 18;
            break;

          case 17:
            _context2.t0 = data.text();

          case 18:
            return _context2.abrupt("return", _context2.t0);

          case 19:
            throw new Error(ERR_DATA);

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee);
  }));
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function getAsyncIteratorFromData(data) {
  if ((0, _isType.isIterator)(data)) {
    return data;
  }

  if ((0, _isType.isFetchResponse)(data) && data.body) {
    return (0, _streamUtils.getStreamIterator)(data.body);
  }

  if ((0, _isType.isReadableStream)(data)) {
    return (0, _streamUtils.getStreamIterator)(data);
  }

  if ((0, _isType.isAsyncIterable)(data)) {
    return data[Symbol.asyncIterator]();
  }

  return getIteratorFromData(data);
}

function getIteratorFromData(data) {
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return _regenerator["default"].mark(function oneChunk() {
      return _regenerator["default"].wrap(function oneChunk$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return data.buffer || data;

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, oneChunk);
    })();
  }

  if ((0, _isType.isIterator)(data)) {
    return data;
  }

  if ((0, _isType.isIterable)(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}

},{"../../javascript-utils/is-type":151,"../../javascript-utils/stream-utils":153,"../fetch/fetch-file.browser":156,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],165:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLoaderObject = isLoaderObject;
exports.normalizeLoader = normalizeLoader;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = _interopRequireDefault(require("../../utils/assert"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  var hasParser = loader.parseTextSync || loader.parseSync || loader.parse || loader.loadAndParse || loader.parseStream || loader.parseInBatches || loader.worker;
  return hasParser;
}

function normalizeLoader(loader) {
  (0, _assert["default"])(isLoaderObject(loader));
  var options;

  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = _objectSpread({}, loader, {
      options: _objectSpread({}, loader.options, {}, options)
    });
  }

  if (loader.extension) {
    loader.extensions = loader.extensions || loader.extension;
    delete loader.extension;
  }

  if (!Array.isArray(loader.extensions)) {
    loader.extensions = [loader.extensions];
  }

  (0, _assert["default"])(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);

  if (loader.parseTextSync) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  return loader;
}

},{"../../utils/assert":177,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],166:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLoaderAndUserOptions = mergeLoaderAndUserOptions;

var _nullLog = _interopRequireDefault(require("./null-log"));

function mergeLoaderAndUserOptions(options, loader) {
  options = Object.assign({}, loader && loader.DEFAULT_OPTIONS, loader && loader.defaultOptions, loader && loader.options, options, {
    dataType: 'arraybuffer'
  });

  if (options.log === null) {
    options.log = new _nullLog["default"]();
  }

  if (!('log' in options)) {
    options.log = console;
  }

  return options;
}

},{"./null-log":167,"@babel/runtime/helpers/interopRequireDefault":25}],167:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var NullLog = function () {
  function NullLog() {
    (0, _classCallCheck2["default"])(this, NullLog);
  }

  (0, _createClass2["default"])(NullLog, [{
    key: "log",
    value: function log() {}
  }, {
    key: "info",
    value: function info() {}
  }, {
    key: "warn",
    value: function warn() {}
  }, {
    key: "error",
    value: function error() {}
  }]);
  return NullLog;
}();

exports["default"] = NullLog;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],168:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseWithLoader = parseWithLoader;
exports.parseWithLoaderSync = parseWithLoaderSync;
exports.parseWithLoaderInBatches = parseWithLoaderInBatches;
exports.parseWithLoaderInBatchesSync = parseWithLoaderInBatchesSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _parseWithWorker = _interopRequireDefault(require("./parse-with-worker"));

var _getData = require("./loader-utils/get-data");

function parseWithLoader(_x, _x2, _x3, _x4) {
  return _parseWithLoader.apply(this, arguments);
}

function _parseWithLoader() {
  _parseWithLoader = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(data, loader, options, url) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = url || (0, _getData.getUrlFromData)(data);
            _context.next = 3;
            return (0, _getData.getArrayBufferOrStringFromData)(data, loader);

          case 3:
            data = _context.sent;

            if (!(loader.parseTextSync && typeof data === 'string')) {
              _context.next = 7;
              break;
            }

            options.dataType = 'text';
            return _context.abrupt("return", loader.parseTextSync(data, options, url, loader));

          case 7:
            if (!loader.parseSync) {
              _context.next = 9;
              break;
            }

            return _context.abrupt("return", loader.parseSync(data, options, url, loader));

          case 9:
            if (!loader.parse) {
              _context.next = 13;
              break;
            }

            _context.next = 12;
            return loader.parse(data, options, url, loader);

          case 12:
            return _context.abrupt("return", _context.sent);

          case 13:
            if (!loader.worker) {
              _context.next = 17;
              break;
            }

            _context.next = 16;
            return (0, _parseWithWorker["default"])(loader.worker, data, options);

          case 16:
            return _context.abrupt("return", _context.sent);

          case 17:
            return _context.abrupt("return", (0, _assert["default"])(false));

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseWithLoader.apply(this, arguments);
}

function parseWithLoaderSync(data, loader, options, url) {
  data = (0, _getData.getArrayBufferOrStringFromDataSync)(data, loader);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options, url, loader);
  }

  if (loader.parseSync) {
    return loader.parseSync(data, options, url, loader);
  }

  return (0, _assert["default"])(false);
}

function parseWithLoaderInBatches(data, loader, options, url) {
  if (loader.parseInBatches) {
    var inputIterator = (0, _getData.getAsyncIteratorFromData)(data);
    var outputIterator = loader.parseInBatches(inputIterator, options, url, loader);
    return outputIterator;
  }

  return null;
}

function parseWithLoaderInBatchesSync(data, loader, options, url) {
  if (loader.parseInBatchesSync) {
    var inputIterator = (0, _getData.getIteratorFromData)(data);
    var outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);
    return outputIterator;
  }

  return (0, _assert["default"])(false);
}

},{"../utils/assert":177,"./loader-utils/get-data":164,"./parse-with-worker":169,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = parseWithWorker;

var _binaryUtils = require("../javascript-utils/binary-utils");

var workerCache = new Map();

function getWorker(workerSource) {
  var workerURL = workerCache.get(workerSource);

  if (!workerURL) {
    var blob = new Blob([workerSource], {
      type: 'application/javascript'
    });
    workerURL = URL.createObjectURL(blob);
    workerCache.set(workerSource, workerURL);
  }

  return new Worker(workerURL);
}

function parseWithWorker(workerSource, data, options) {
  var worker = getWorker(workerSource);
  options = removeNontransferableOptions(options);

  var parse = function parse(rawData, opts) {
    return new Promise(function (resolve, reject) {
      worker.onmessage = function (evt) {
        switch (evt.data.type) {
          case 'done':
            resolve(evt.data.result);
            worker.terminate();
            break;

          case 'error':
            reject(new Error(evt.data.message));
            break;

          default:
        }
      };

      var arraybuffer = (0, _binaryUtils.toArrayBuffer)(rawData);
      worker.postMessage({
        arraybuffer: arraybuffer,
        opts: opts
      }, [arraybuffer]);
    });
  };

  return data ? parse(data, options) : parse;
}

function removeNontransferableOptions(options) {
  options = Object.assign({}, options);

  if (options.log !== null) {
    delete options.log;
  }

  return options;
}

},{"../javascript-utils/binary-utils":150}],170:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.parseSync = parseSync;
exports.parseInBatches = parseInBatches;
exports.parseInBatchesSync = parseInBatchesSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../javascript-utils/is-type");

var _autoDetectLoader = require("./loader-utils/auto-detect-loader");

var _normalizeLoader = require("./loader-utils/normalize-loader");

var _normalizeOptions = require("./loader-utils/normalize-options");

var _registerLoaders = require("./register-loaders");

var _parseWithLoader = require("./parse-with-loader");

function parse(_x, _x2, _x3, _x4) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(data, loaders, options, url) {
    var autoUrl, loader;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              url = options;
              options = loaders;
              loaders = null;
            }

            autoUrl = (0, _isType.isFileReadable)(url) ? url.name : url;
            loaders = loaders || (0, _registerLoaders.getRegisteredLoaders)();
            loader = Array.isArray(loaders) ? (0, _autoDetectLoader.autoDetectLoader)(data, loaders, {
              url: autoUrl
            }) : loaders;

            if (loader) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", null);

          case 6:
            (0, _normalizeLoader.normalizeLoader)(loader);
            options = (0, _normalizeOptions.mergeLoaderAndUserOptions)(options, loader);
            _context.next = 10;
            return (0, _parseWithLoader.parseWithLoader)(data, loader, options, autoUrl);

          case 10:
            return _context.abrupt("return", _context.sent);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}

function parseSync(data, loaders, options, url) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  loaders = loaders || (0, _registerLoaders.getRegisteredLoaders)();
  var loader = Array.isArray(loaders) ? (0, _autoDetectLoader.autoDetectLoader)(data, loaders, {
    url: url
  }) : loaders;
  (0, _normalizeLoader.normalizeLoader)(loader);
  options = (0, _normalizeOptions.mergeLoaderAndUserOptions)(options, loader);
  return (0, _parseWithLoader.parseWithLoaderSync)(data, loader, options, url);
}

function parseInBatches(_x5, _x6, _x7, _x8) {
  return _parseInBatches.apply(this, arguments);
}

function _parseInBatches() {
  _parseInBatches = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(data, loaders, options, url) {
    var loader;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              url = options;
              options = loaders;
              loaders = null;
            }

            loaders = loaders || (0, _registerLoaders.getRegisteredLoaders)();
            loader = Array.isArray(loaders) ? (0, _autoDetectLoader.autoDetectLoader)(null, loaders, {
              url: url
            }) : loaders;
            (0, _normalizeLoader.normalizeLoader)(loader);
            options = (0, _normalizeOptions.mergeLoaderAndUserOptions)(options, loader);
            return _context2.abrupt("return", (0, _parseWithLoader.parseWithLoaderInBatches)(data, loader, options, url));

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseInBatches.apply(this, arguments);
}

function parseInBatchesSync(_x9, _x10, _x11, _x12) {
  return _parseInBatchesSync.apply(this, arguments);
}

function _parseInBatchesSync() {
  _parseInBatchesSync = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(data, loaders, options, url) {
    var loader;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              url = options;
              options = loaders;
              loaders = null;
            }

            loaders = loaders || (0, _registerLoaders.getRegisteredLoaders)();
            loader = Array.isArray(loaders) ? (0, _autoDetectLoader.autoDetectLoader)(null, loaders, {
              url: url
            }) : loaders;
            (0, _normalizeLoader.normalizeLoader)(loader);
            options = (0, _normalizeOptions.mergeLoaderAndUserOptions)(options, loader);
            return _context3.abrupt("return", (0, _parseWithLoader.parseWithLoaderInBatches)(data, loader, options, url));

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _parseInBatchesSync.apply(this, arguments);
}

},{"../javascript-utils/is-type":151,"./loader-utils/auto-detect-loader":163,"./loader-utils/normalize-loader":165,"./loader-utils/normalize-options":166,"./parse-with-loader":168,"./register-loaders":171,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],171:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerLoaders = registerLoaders;
exports.getRegisteredLoaders = getRegisteredLoaders;

var _normalizeLoader = require("./loader-utils/normalize-loader");

var registeredLoaders = {};

function registerLoaders(loaders) {
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = loaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var loader = _step.value;
      var normalizedLoader = (0, _normalizeLoader.normalizeLoader)(loader);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = normalizedLoader.extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var extension = _step2.value;
          registeredLoaders[extension] = normalizedLoader;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function getRegisteredLoaders() {
  return Object.values(registeredLoaders);
}

},{"./loader-utils/normalize-loader":165}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveSync = saveSync;

var _encode = require("./encode");

var _writeFile = require("./fetch/write-file");

function save(data, url, writer, options) {
  var encodedData = (0, _encode.encode)(data, writer, options, url);
  return (0, _writeFile.writeFile)(url, encodedData);
}

function saveSync(data, url, writer, options) {
  var encodedData = (0, _encode.encodeSync)(data, writer, options, url);
  return (0, _writeFile.writeFileSync)(url, encodedData);
}

},{"./encode":154,"./fetch/write-file":161}],173:[function(require,module,exports){
(function (Buffer){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fs = _interopRequireDefault(require("fs"));

var _toArrayBuffer = require("./utils/to-array-buffer.node");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_OPTIONS = {
  dataType: 'arraybuffer',
  nothrow: true
};

function readFileSync(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options = getReadFileOptions(options);

  if (!_fs["default"] || !_fs["default"].readFileSync) {
    return null;
  }

  var buffer = _fs["default"].readFileSync(url, options, function () {});

  return buffer instanceof Buffer ? (0, _toArrayBuffer.toArrayBuffer)(buffer) : buffer;
}

function getReadFileOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);

  if (options.responseType === 'text' || options.dataType === 'text') {
    options.encoding = options.encoding || 'utf8';
  }

  return options;
}

}).call(this,require("buffer").Buffer)
},{"./utils/to-array-buffer.node":174,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"buffer":3,"fs":2}],174:[function(require,module,exports){
(function (Buffer){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayBuffer = toArrayBuffer;

function toArrayBuffer(buffer) {
  if (Buffer.isBuffer(buffer)) {
    var typedArray = new Uint8Array(buffer);
    return typedArray.buffer;
  }

  return buffer;
}

}).call(this,{"isBuffer":require("../../../../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js":5}],175:[function(require,module,exports){
(function (Buffer){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = toBuffer;

var _assert = _interopRequireDefault(require("../../utils/assert"));

function toBuffer(binaryData) {
  if (ArrayBuffer.isView(binaryData)) {
    binaryData = binaryData.buffer;
  }

  if (typeof Buffer !== 'undefined' && binaryData instanceof ArrayBuffer) {
    var buffer = new Buffer(binaryData.byteLength);
    var view = new Uint8Array(binaryData);

    for (var i = 0; i < buffer.length; ++i) {
      buffer[i] = view[i];
    }

    return buffer;
  }

  return (0, _assert["default"])(false);
}

}).call(this,require("buffer").Buffer)
},{"../../utils/assert":177,"@babel/runtime/helpers/interopRequireDefault":25,"buffer":3}],176:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;

var _fs = _interopRequireDefault(require("fs"));

var _util = require("util");

var _toBuffer = _interopRequireDefault(require("./utils/to-buffer.node"));

function writeFile(filePath, arrayBufferOrString) {
  return (0, _util.promisify)(_fs["default"].writeFile)("".concat(filePath), (0, _toBuffer["default"])(arrayBufferOrString), {
    flag: 'w'
  });
}

function writeFileSync(filePath, arrayBufferOrString) {
  return _fs["default"].writeFileSync("".concat(filePath), (0, _toBuffer["default"])(arrayBufferOrString), {
    flag: 'w'
  });
}

},{"./utils/to-buffer.node":175,"@babel/runtime/helpers/interopRequireDefault":25,"fs":2,"util":9}],177:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}

},{}],178:[function(require,module,exports){
(function (process,global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeVersion = exports.document = exports.global = exports.window = exports.self = exports.isBrowser = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var matches = typeof process !== 'undefined' && process.version.match(/v([0-9]*)/);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],179:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _parseGlb = _interopRequireDefault(require("./lib/parse-glb"));

var _default = {
  name: 'GLB',
  extension: ['glb'],
  text: true,
  binary: true,
  parseSync: parseSync
};
exports["default"] = _default;

function parseSync(arrayBuffer, options) {
  var _options$byteOffset = options.byteOffset,
      byteOffset = _options$byteOffset === void 0 ? 0 : _options$byteOffset;
  var glb = {};
  (0, _parseGlb["default"])(glb, arrayBuffer, byteOffset, options);
  return glb;
}

},{"./lib/parse-glb":202,"@babel/runtime/helpers/interopRequireDefault":25}],180:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _encodeGlb = _interopRequireDefault(require("./lib/encode-glb"));

var _default = {
  name: 'GLB',
  extensions: ['glb'],
  encodeSync: encodeSync,
  binary: true
};
exports["default"] = _default;

function encodeSync(glb, options) {
  var _options$byteOffset = options.byteOffset,
      byteOffset = _options$byteOffset === void 0 ? 0 : _options$byteOffset;
  var byteLength = (0, _encodeGlb["default"])(glb, null, byteOffset, options);
  var arrayBuffer = new ArrayBuffer(byteLength);
  var dataView = new DataView(arrayBuffer);
  (0, _encodeGlb["default"])(glb, dataView, byteOffset, options);
  return arrayBuffer;
}

},{"./lib/encode-glb":193,"@babel/runtime/helpers/interopRequireDefault":25}],181:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.parseSync = parseSync;
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _parseGltf = require("./lib/parse-gltf");

var _gltfParser = _interopRequireDefault(require("./lib/deprecated/gltf-parser"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_OPTIONS = {
  useGLTFParser: true
};

function parse(_x) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(arrayBuffer) {
    var options,
        gltfParser,
        _options2,
        _options2$byteOffset,
        byteOffset,
        gltf,
        _args = arguments;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);

            if (!options.useGLTFParser) {
              _context.next = 5;
              break;
            }

            gltfParser = new _gltfParser["default"]();
            return _context.abrupt("return", gltfParser.parse(arrayBuffer, options));

          case 5:
            _options2 = options, _options2$byteOffset = _options2.byteOffset, byteOffset = _options2$byteOffset === void 0 ? 0 : _options2$byteOffset;
            gltf = {};
            _context.next = 9;
            return (0, _parseGltf.parseGLTF)(gltf, arrayBuffer, byteOffset, options);

          case 9:
            return _context.abrupt("return", gltf);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}

function parseSync(arrayBuffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);

  if (options.useGLTFParser) {
    return new _gltfParser["default"]().parseSync(arrayBuffer, options);
  }

  var _options = options,
      _options$byteOffset = _options.byteOffset,
      byteOffset = _options$byteOffset === void 0 ? 0 : _options$byteOffset;
  var gltf = {};
  (0, _parseGltf.parseGLTFSync)(gltf, arrayBuffer, byteOffset, options);
  return gltf;
}

var _default = {
  name: 'glTF',
  extensions: ['gltf', 'glb'],
  text: true,
  binary: true,
  test: 'glTF',
  parse: parse,
  parseSync: parseSync,
  defaultOptions: DEFAULT_OPTIONS
};
exports["default"] = _default;

},{"./lib/deprecated/gltf-parser":187,"./lib/parse-gltf":203,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],182:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _encodeGltf = require("./lib/encode-gltf");

function encodeSync(gltf) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$byteOffset = options.byteOffset,
      byteOffset = _options$byteOffset === void 0 ? 0 : _options$byteOffset;
  var byteLength = (0, _encodeGltf.encodeGLTFSync)(gltf, null, byteOffset, options);
  var arrayBuffer = new ArrayBuffer(byteLength);
  var dataView = new DataView(arrayBuffer);
  (0, _encodeGltf.encodeGLTFSync)(gltf, dataView, byteOffset, options);
  return arrayBuffer;
}

var _default = {
  name: 'glTF',
  extensions: ['glb'],
  encodeSync: encodeSync,
  binary: true,
  defaultOptions: {
    useGLTFBuilder: true
  }
};
exports["default"] = _default;

},{"./lib/encode-gltf":194}],183:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "KHR_DRACO_MESH_COMPRESSION", {
  enumerable: true,
  get: function get() {
    return _gltfConstants.KHR_DRACO_MESH_COMPRESSION;
  }
});
Object.defineProperty(exports, "UBER_POINT_CLOUD_EXTENSION", {
  enumerable: true,
  get: function get() {
    return _gltfConstants.UBER_POINT_CLOUD_EXTENSION;
  }
});
Object.defineProperty(exports, "GLTFLoader", {
  enumerable: true,
  get: function get() {
    return _gltfLoader["default"];
  }
});
Object.defineProperty(exports, "GLTFWriter", {
  enumerable: true,
  get: function get() {
    return _gltfWriter["default"];
  }
});
Object.defineProperty(exports, "GLBLoader", {
  enumerable: true,
  get: function get() {
    return _glbLoader["default"];
  }
});
Object.defineProperty(exports, "GLBWriter", {
  enumerable: true,
  get: function get() {
    return _glbWriter["default"];
  }
});
Object.defineProperty(exports, "GLTFScenegraph", {
  enumerable: true,
  get: function get() {
    return _gltfScenegraph["default"];
  }
});
Object.defineProperty(exports, "postProcessGLTF", {
  enumerable: true,
  get: function get() {
    return _postProcessGltf["default"];
  }
});
Object.defineProperty(exports, "parseGLTFSync", {
  enumerable: true,
  get: function get() {
    return _parseGltf.parseGLTFSync;
  }
});
Object.defineProperty(exports, "encodeGLTFSync", {
  enumerable: true,
  get: function get() {
    return _encodeGltf.encodeGLTFSync;
  }
});
Object.defineProperty(exports, "packBinaryJson", {
  enumerable: true,
  get: function get() {
    return _packBinaryJson["default"];
  }
});
Object.defineProperty(exports, "unpackBinaryJson", {
  enumerable: true,
  get: function get() {
    return _unpackBinaryJson["default"];
  }
});
Object.defineProperty(exports, "GLBParser", {
  enumerable: true,
  get: function get() {
    return _glbParser["default"];
  }
});
Object.defineProperty(exports, "GLBBuilder", {
  enumerable: true,
  get: function get() {
    return _glbBuilder["default"];
  }
});
Object.defineProperty(exports, "GLTFParser", {
  enumerable: true,
  get: function get() {
    return _gltfParser["default"];
  }
});
Object.defineProperty(exports, "GLTFBuilder", {
  enumerable: true,
  get: function get() {
    return _gltfBuilder["default"];
  }
});

var _gltfConstants = require("./lib/gltf-constants");

var _gltfLoader = _interopRequireDefault(require("./gltf-loader"));

var _gltfWriter = _interopRequireDefault(require("./gltf-writer"));

var _glbLoader = _interopRequireDefault(require("./glb-loader"));

var _glbWriter = _interopRequireDefault(require("./glb-writer"));

var _gltfScenegraph = _interopRequireDefault(require("./lib/gltf-scenegraph"));

var _postProcessGltf = _interopRequireDefault(require("./lib/post-process-gltf"));

var _parseGltf = require("./lib/parse-gltf");

var _encodeGltf = require("./lib/encode-gltf");

var _packBinaryJson = _interopRequireDefault(require("./lib/deprecated/packed-json/pack-binary-json"));

var _unpackBinaryJson = _interopRequireDefault(require("./lib/deprecated/packed-json/unpack-binary-json"));

var _glbParser = _interopRequireDefault(require("./lib/deprecated/glb-parser"));

var _glbBuilder = _interopRequireDefault(require("./lib/deprecated/glb-builder"));

var _gltfParser = _interopRequireDefault(require("./lib/deprecated/gltf-parser"));

var _gltfBuilder = _interopRequireDefault(require("./lib/deprecated/gltf-builder"));

},{"./glb-loader":179,"./glb-writer":180,"./gltf-loader":181,"./gltf-writer":182,"./lib/deprecated/glb-builder":184,"./lib/deprecated/glb-parser":185,"./lib/deprecated/gltf-builder":186,"./lib/deprecated/gltf-parser":187,"./lib/deprecated/packed-json/pack-binary-json":190,"./lib/deprecated/packed-json/unpack-binary-json":191,"./lib/encode-gltf":194,"./lib/gltf-constants":198,"./lib/gltf-scenegraph":199,"./lib/parse-gltf":203,"./lib/post-process-gltf":204,"@babel/runtime/helpers/interopRequireDefault":25}],184:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _images = require("@loaders.gl/images");

var _gltfUtils = require("../gltf-utils/gltf-utils");

var _encodeGlb = _interopRequireDefault(require("../encode-glb"));

var _packBinaryJson = _interopRequireDefault(require("./packed-json/pack-binary-json"));

var GLBBuilder = function () {
  function GLBBuilder() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, GLBBuilder);
    this.byteLength = 0;
    this.json = {
      buffers: [{
        byteLength: 0
      }],
      bufferViews: [],
      accessors: [],
      images: [],
      meshes: []
    };
    this.sourceBuffers = [];
    this.log = options.log || console;
  }

  (0, _createClass2["default"])(GLBBuilder, [{
    key: "getByteLength",
    value: function getByteLength() {
      return this.byteLength;
    }
  }, {
    key: "isImage",
    value: function isImage(imageData) {
      return (0, _images.isImage)(imageData);
    }
  }, {
    key: "encodeSync",
    value: function encodeSync() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.encodeAsGLB(options);
    }
  }, {
    key: "encodeAsGLB",
    value: function encodeAsGLB() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._packBinaryChunk();

      if (options.magic) {
        console.warn('Custom glTF magic number no longer supported');
      }

      var glb = {
        version: 2,
        json: this.json,
        binary: this.arrayBuffer
      };
      var byteLength = (0, _encodeGlb["default"])(glb, null, 0, options);
      var glbArrayBuffer = new ArrayBuffer(byteLength);
      var dataView = new DataView(glbArrayBuffer);
      (0, _encodeGlb["default"])(glb, dataView, 0, options);
      return glbArrayBuffer;
    }
  }, {
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var jsonData = packOptions.packTypedArrays ? (0, _packBinaryJson["default"])(data, this, packOptions) : data;
      this.json[key] = jsonData;
      return this;
    }
  }, {
    key: "addBuffer",
    value: function addBuffer(sourceBuffer) {
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        size: 3
      };
      var bufferViewIndex = this.addBufferView(sourceBuffer);
      var accessorDefaults = {
        size: accessor.size,
        componentType: (0, _gltfUtils.getComponentTypeFromArray)(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size)
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
  }, {
    key: "addBufferView",
    value: function addBufferView(buffer) {
      var byteLength = buffer.byteLength || buffer.length;
      this.json.bufferViews.push({
        buffer: 0,
        byteOffset: this.byteLength,
        byteLength: byteLength
      });
      this.byteLength += (0, _loaderUtils.padTo4Bytes)(byteLength);
      this.sourceBuffers.push(buffer);
      return this.json.bufferViews.length - 1;
    }
  }, {
    key: "addAccessor",
    value: function addAccessor(bufferViewIndex, accessor) {
      this.json.accessors.push({
        bufferView: bufferViewIndex,
        type: (0, _gltfUtils.getAccessorTypeFromSize)(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count
      });
      return this.json.accessors.length - 1;
    }
  }, {
    key: "_pack",
    value: function _pack() {
      this._packBinaryChunk();

      return {
        arrayBuffer: this.arrayBuffer,
        json: this.json
      };
    }
  }, {
    key: "_packBinaryChunk",
    value: function _packBinaryChunk() {
      if (this.arrayBuffer) {
        return;
      }

      var totalByteLength = this.byteLength;
      var arrayBuffer = new ArrayBuffer(totalByteLength);
      var targetArray = new Uint8Array(arrayBuffer);
      var dstByteOffset = 0;

      for (var i = 0; i < this.sourceBuffers.length; i++) {
        var sourceBuffer = this.sourceBuffers[i];
        dstByteOffset = (0, _loaderUtils.copyToArray)(sourceBuffer, targetArray, dstByteOffset);
      }

      this.json.buffers[0].byteLength = totalByteLength;
      this.arrayBuffer = arrayBuffer;
      this.sourceBuffers = [];
    }
  }, {
    key: "_getInternalCounts",
    value: function _getInternalCounts() {
      return {
        buffers: this.json.buffers.length,
        bufferViews: this.json.bufferViews.length,
        accessors: this.json.accessors.length,
        images: this.json.images.length
      };
    }
  }]);
  return GLBBuilder;
}();

exports["default"] = GLBBuilder;

},{"../encode-glb":193,"../gltf-utils/gltf-utils":201,"./packed-json/pack-binary-json":190,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@loaders.gl/images":208,"@loaders.gl/loader-utils":217}],185:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _parseGlb = _interopRequireWildcard(require("../parse-glb"));

var _gltfUtils = require("../gltf-utils/gltf-utils");

var _unpackBinaryJson = _interopRequireDefault(require("./packed-json/unpack-binary-json"));

var _unpackGltfBuffers = _interopRequireDefault(require("./packed-json/unpack-gltf-buffers"));

var GLBParser = function () {
  function GLBParser() {
    (0, _classCallCheck2["default"])(this, GLBParser);
  }

  (0, _createClass2["default"])(GLBParser, [{
    key: "parse",
    value: function parse(arrayBuffer) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.parseSync(arrayBuffer, options);
    }
  }, {
    key: "parseSync",
    value: function parseSync(arrayBuffer) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.glbArrayBuffer = arrayBuffer;
      this.binaryByteOffset = null;
      this.packedJson = null;
      this.json = null;

      if (this.json === null && this.binaryByteOffset === null) {
        var byteOffset = 0;
        (0, _parseGlb["default"])(this, this.glbArrayBuffer, byteOffset, options);
        this.binaryByteOffset = this.binChunkByteOffset;
        this.packedJson = this.json;
        var unpackedBuffers = (0, _unpackGltfBuffers["default"])(this.glbArrayBuffer, this.json, this.binaryByteOffset);
        this.json = (0, _unpackBinaryJson["default"])(this.json, unpackedBuffers);
        this.unpackedBuffers = unpackedBuffers;
      }

      return this;
    }
  }, {
    key: "getApplicationData",
    value: function getApplicationData(key) {
      return this.json[key];
    }
  }, {
    key: "getJSON",
    value: function getJSON() {
      return this.json;
    }
  }, {
    key: "getArrayBuffer",
    value: function getArrayBuffer() {
      return this.glbArrayBuffer;
    }
  }, {
    key: "getBinaryByteOffset",
    value: function getBinaryByteOffset() {
      return this.binaryByteOffset;
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(glTFBufferView) {
      var byteOffset = (glTFBufferView.byteOffset || 0) + this.binaryByteOffset;
      return new Uint8Array(this.glbArrayBuffer, byteOffset, glTFBufferView.byteLength);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(glTFAccessor) {
      var ArrayType = _gltfUtils.ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[glTFAccessor.componentType];
      var components = _gltfUtils.ATTRIBUTE_TYPE_TO_COMPONENTS[glTFAccessor.type];
      var bytesPerComponent = _gltfUtils.ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[glTFAccessor.componentType];
      var length = glTFAccessor.count * components;
      var byteLength = glTFAccessor.count * components * bytesPerComponent;
      var glTFBufferView = this.json.bufferViews[glTFAccessor.bufferView];
      (0, _assert["default"])(byteLength >= 0 && glTFAccessor.byteOffset + byteLength <= glTFBufferView.byteLength);
      var byteOffset = glTFBufferView.byteOffset + this.binaryByteOffset + glTFAccessor.byteOffset;
      return new ArrayType(this.glbArrayBuffer, byteOffset, length);
    }
  }, {
    key: "getImageData",
    value: function getImageData(glTFImage) {
      return {
        typedArray: this.getBufferView(glTFImage.bufferView),
        mimeType: glTFImage.mimeType || 'image/jpeg'
      };
    }
  }, {
    key: "getImage",
    value: function getImage(glTFImage) {
      var arrayBufferView = this.getBufferView(glTFImage.bufferView);
      var mimeType = glTFImage.mimeType || 'image/jpeg';
      var blob = new Blob([arrayBufferView], {
        type: mimeType
      });
      var urlCreator = self.URL || self.webkitURL;
      var imageUrl = urlCreator.createObjectURL(blob);
      var img = new Image();
      img.src = imageUrl;
      return img;
    }
  }, {
    key: "getImageAsync",
    value: function getImageAsync(glTFImage) {
      var _this = this;

      return new Promise(function (resolve) {
        var arrayBufferView = _this.getBufferView(glTFImage.bufferView);

        var mimeType = glTFImage.mimeType || 'image/jpeg';
        var blob = new Blob([arrayBufferView], {
          type: mimeType
        });
        var urlCreator = self.URL || self.webkitURL;
        var imageUrl = urlCreator.createObjectURL(blob);
        var img = new Image();

        img.onload = function () {
          return resolve(img);
        };

        img.src = imageUrl;
      });
    }
  }], [{
    key: "isGLB",
    value: function isGLB(arrayBuffer) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var byteOffset = 0;
      return (0, _parseGlb.isGLB)(arrayBuffer, byteOffset);
    }
  }]);
  return GLBParser;
}();

exports["default"] = GLBParser;

},{"../gltf-utils/gltf-utils":201,"../parse-glb":202,"../utils/assert":205,"./packed-json/unpack-binary-json":191,"./packed-json/unpack-gltf-buffers":192,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26}],186:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _images = require("@loaders.gl/images");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _gltfConstants = require("../gltf-constants");

var _glbBuilder = _interopRequireDefault(require("./glb-builder"));

var _packBinaryJson = _interopRequireDefault(require("./packed-json/pack-binary-json"));

var GLTFBuilder = function (_GLBBuilder) {
  (0, _inherits2["default"])(GLTFBuilder, _GLBBuilder);

  function GLTFBuilder() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, GLTFBuilder);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(GLTFBuilder).call(this, options));
    _this.DracoWriter = options.DracoWriter;
    _this.DracoLoader = options.DracoLoader;
    return _this;
  }

  (0, _createClass2["default"])(GLTFBuilder, [{
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var jsonData = packOptions.packTypedArrays ? (0, _packBinaryJson["default"])(data, this, packOptions) : data;
      this.json[key] = jsonData;
      return this;
    }
  }, {
    key: "addExtraData",
    value: function addExtraData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var packedJson = packOptions.packedTypedArrays ? (0, _packBinaryJson["default"])(data, this, packOptions) : data;
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = packedJson;
      return this;
    }
  }, {
    key: "addExtension",
    value: function addExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _assert["default"])(data);
      var packedJson = packOptions.packTypedArrays ? (0, _packBinaryJson["default"])(data, this, packOptions) : data;
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = packedJson;
      this.registerUsedExtension(extensionName);
      return this;
    }
  }, {
    key: "addRequiredExtension",
    value: function addRequiredExtension(extensionName, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _assert["default"])(data);
      var packedJson = packOptions.packTypedArrays ? (0, _packBinaryJson["default"])(data, this, packOptions) : data;
      this.addExtension(extensionName, packedJson);
      this.registerRequiredExtension(extensionName);
      return this;
    }
  }, {
    key: "registerUsedExtension",
    value: function registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];

      if (!this.json.extensionsUsed.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
  }, {
    key: "registerRequiredExtension",
    value: function registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];

      if (!this.json.extensionsRequired.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
  }, {
    key: "addMesh",
    value: function addMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      var accessors = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessors,
          indices: indices,
          mode: mode
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addPointCloud",
    value: function addPointCloud(attributes) {
      var accessorIndices = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addCompressedMesh",
    value: function addCompressedMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      if (!this.DracoWriter || !this.DracoLoader) {
        throw new Error('DracoWriter/DracoLoader not available');
      }

      this.registerRequiredExtension(_gltfConstants.KHR_DRACO_MESH_COMPRESSION);
      var compressedData = this.DracoWriter.encodeSync({
        attributes: attributes
      });
      var decodedData = this.DracoLoader.parseSync({
        attributes: attributes
      });

      var fauxAccessors = this._addFauxAttributes(decodedData.attributes);

      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: fauxAccessors,
          mode: mode,
          extensions: (0, _defineProperty2["default"])({}, _gltfConstants.KHR_DRACO_MESH_COMPRESSION, {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          })
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addCompressedPointCloud",
    value: function addCompressedPointCloud(attributes) {
      if (!this.DracoWriter || !this.DracoLoader) {
        throw new Error('DracoWriter/DracoLoader not available');
      }

      attributes.mode = 0;
      var compressedData = this.DracoWriter.encodeSync(attributes, {
        pointcloud: true
      });
      var bufferViewIndex = this.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: {},
          mode: 0,
          extensions: (0, _defineProperty2["default"])({}, _gltfConstants.UBER_POINT_CLOUD_EXTENSION, {
            bufferView: bufferViewIndex
          })
        }]
      };
      this.registerRequiredExtension(_gltfConstants.UBER_POINT_CLOUD_EXTENSION);
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addImage",
    value: function addImage(imageData) {
      var bufferViewIndex = this.addBufferView(imageData);
      var sizeAndType = (0, _images.getImageMetadata)(imageData) || {};

      if (sizeAndType) {
        var mimeType = sizeAndType.mimeType,
            width = sizeAndType.width,
            height = sizeAndType.height;
        this.json.images.push({
          bufferView: bufferViewIndex,
          mimeType: mimeType,
          width: width,
          height: height
        });
      } else {
        this.json.images.push({
          bufferView: bufferViewIndex
        });
      }

      return this.json.images.length - 1;
    }
  }]);
  return GLTFBuilder;
}(_glbBuilder["default"]);

exports["default"] = GLTFBuilder;

},{"../gltf-constants":198,"../utils/assert":205,"./glb-builder":184,"./packed-json/pack-binary-json":190,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@loaders.gl/images":208}],187:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@loaders.gl/core");

var _gltfUtils = require("../gltf-utils/gltf-utils");

var _gltfAttributeUtils = require("../gltf-utils/gltf-attribute-utils");

var _gltfConstants = require("../gltf-constants");

var _glbParser = _interopRequireDefault(require("./glb-parser"));

var _gltfPostProcessorOld = _interopRequireDefault(require("./gltf-post-processor-old"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_OPTIONS = {
  fetchLinkedResources: true,
  fetch: _core.fetchFile,
  decompress: false,
  DracoLoader: null,
  postProcess: true,
  createImages: false,
  log: console
};

var GLTFParser = function () {
  function GLTFParser() {
    (0, _classCallCheck2["default"])(this, GLTFParser);
  }

  (0, _createClass2["default"])(GLTFParser, [{
    key: "parse",
    value: function () {
      var _parse = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(gltf) {
        var options,
            postProcessor,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                options = Object.assign({}, DEFAULT_OPTIONS, options);
                this.parseSync(gltf, _objectSpread({}, options, {
                  postProcess: false,
                  decompress: false
                }));

                if (!options.fetchLinkedResources) {
                  _context.next = 6;
                  break;
                }

                _context.next = 6;
                return this._loadLinkedAssets(options);

              case 6:
                if (options.decompress) {
                  this._decompressMeshes(options);
                }

                if (options.postProcess) {
                  postProcessor = new _gltfPostProcessorOld["default"]();
                  postProcessor.postProcess(this.gltf, this.glbParser, options);
                }

                return _context.abrupt("return", this.gltf);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function parse(_x) {
        return _parse.apply(this, arguments);
      }

      return parse;
    }()
  }, {
    key: "parseSync",
    value: function parseSync(gltf) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options = Object.assign({}, DEFAULT_OPTIONS, options);

      if (gltf instanceof ArrayBuffer && !_glbParser["default"].isGLB(gltf, options)) {
        var textDecoder = new _core.TextDecoder();
        gltf = textDecoder.decode(gltf);
      }

      if (typeof gltf === 'string') {
        gltf = JSON.parse(gltf);
      }

      if (gltf instanceof ArrayBuffer) {
        this.glbParser = new _glbParser["default"]();
        this.gltf = this.glbParser.parseSync(gltf).json;
        this.json = this.gltf;
      } else {
        this.glbParser = null;
        this.gltf = gltf;
        this.json = gltf;
      }

      if (options.decompress) {
        this._decompressMeshes(options);
      }

      if (options.postProcess) {
        var postProcessor = new _gltfPostProcessorOld["default"]();
        postProcessor.postProcess(this.gltf, this.glbParser, options);
      }

      return this.gltf;
    }
  }, {
    key: "getApplicationData",
    value: function getApplicationData(key) {
      var data = this.json[key];
      return data;
    }
  }, {
    key: "getExtraData",
    value: function getExtraData(key) {
      var extras = this.json.extras || {};
      return extras[key];
    }
  }, {
    key: "getExtension",
    value: function getExtension(extensionName) {
      var isExtension = this.getUsedExtensions().find(function (name) {
        return name === extensionName;
      });
      var extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] || true : null;
    }
  }, {
    key: "getRequiredExtension",
    value: function getRequiredExtension(extensionName) {
      var isRequired = this.getRequiredExtensions().find(function (name) {
        return name === extensionName;
      });
      return isRequired ? this.getExtension(extensionName) : null;
    }
  }, {
    key: "getRequiredExtensions",
    value: function getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
  }, {
    key: "getUsedExtensions",
    value: function getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
  }, {
    key: "getScene",
    value: function getScene(index) {
      return this._get('scenes', index);
    }
  }, {
    key: "getNode",
    value: function getNode(index) {
      return this._get('nodes', index);
    }
  }, {
    key: "getSkin",
    value: function getSkin(index) {
      return this._get('skins', index);
    }
  }, {
    key: "getMesh",
    value: function getMesh(index) {
      return this._get('meshes', index);
    }
  }, {
    key: "getMaterial",
    value: function getMaterial(index) {
      return this._get('materials', index);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(index) {
      return this._get('accessors', index);
    }
  }, {
    key: "getCamera",
    value: function getCamera(index) {
      return null;
    }
  }, {
    key: "getTexture",
    value: function getTexture(index) {
      return this._get('textures', index);
    }
  }, {
    key: "getSampler",
    value: function getSampler(index) {
      return this._get('samplers', index);
    }
  }, {
    key: "getImage",
    value: function getImage(index) {
      return this._get('images', index);
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(index) {
      return this._get('bufferViews', index);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(index) {
      return this._get('buffers', index);
    }
  }, {
    key: "_get",
    value: function _get(array, index) {
      if ((0, _typeof2["default"])(index) === 'object') {
        return index;
      }

      var object = this.gltf[array] && this.gltf[array][index];

      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }

      return object;
    }
  }, {
    key: "_loadLinkedAssets",
    value: function () {
      var _loadLinkedAssets2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(options) {
        var _this = this;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return Promise.all(this.gltf.buffers.map(function (buffer) {
                  return _this._loadBuffer(buffer, options);
                }));

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _loadLinkedAssets(_x2) {
        return _loadLinkedAssets2.apply(this, arguments);
      }

      return _loadLinkedAssets;
    }()
  }, {
    key: "_loadBuffer",
    value: function () {
      var _loadBuffer2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(buffer, options) {
        var fetch, uri, response, arrayBuffer;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!buffer.uri) {
                  _context3.next = 11;
                  break;
                }

                fetch = options.fetch || window.fetch;
                uri = (0, _gltfUtils.getFullUri)(buffer.uri, options.uri);
                _context3.next = 5;
                return fetch(uri);

              case 5:
                response = _context3.sent;
                _context3.next = 8;
                return response.arrayBuffer();

              case 8:
                arrayBuffer = _context3.sent;
                buffer.data = arrayBuffer;
                buffer.uri = null;

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function _loadBuffer(_x3, _x4) {
        return _loadBuffer2.apply(this, arguments);
      }

      return _loadBuffer;
    }()
  }, {
    key: "_decompressMeshes",
    value: function _decompressMeshes(options) {
      if (!options.DracoLoader || !options.decompress) {
        return;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (this.gltf.meshes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var mesh = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = mesh.primitives[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var primitive = _step2.value;

              this._decompressKhronosDracoPrimitive(primitive, options);

              this._decompressUberDracoPrimitive(primitive, options);

              if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {
                throw new Error('Empty glTF primitive: decompression failure?');
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._removeExtension(_gltfConstants.KHR_DRACO_MESH_COMPRESSION);

      this._removeExtension(_gltfConstants.UBER_POINT_CLOUD_EXTENSION);
    }
  }, {
    key: "_decompressKhronosDracoPrimitive",
    value: function _decompressKhronosDracoPrimitive(primitive, options) {
      var compressedMesh = primitive.extensions && primitive.extensions[_gltfConstants.KHR_DRACO_MESH_COMPRESSION];

      if (!compressedMesh) {
        return;
      }

      delete primitive.extensions[_gltfConstants.KHR_DRACO_MESH_COMPRESSION];

      var buffer = this._getBufferViewArray(compressedMesh.bufferView);

      var decodedData = options.DracoLoader.parseSync(buffer);
      primitive.attributes = (0, _gltfAttributeUtils.getGLTFAccessors)(decodedData.attributes);

      if (decodedData.indices) {
        primitive.indices = (0, _gltfAttributeUtils.getGLTFAccessor)(decodedData.indices);
      }
    }
  }, {
    key: "_decompressUberDracoPrimitive",
    value: function _decompressUberDracoPrimitive(primitive, options) {
      var compressedMesh = primitive.extensions && primitive.extensions[_gltfConstants.UBER_POINT_CLOUD_EXTENSION];

      if (!compressedMesh) {
        return;
      }

      if (primitive.mode !== 0) {
        throw new Error(_gltfConstants.UBER_POINT_CLOUD_EXTENSION);
      }

      delete primitive.extensions[_gltfConstants.UBER_POINT_CLOUD_EXTENSION];

      var buffer = this._getBufferViewArray(compressedMesh.bufferView);

      var decodedData = options.DracoLoader.parseSync(buffer);
      primitive.attributes = decodedData.attributes;
    }
  }, {
    key: "_getBufferViewArray",
    value: function _getBufferViewArray(bufferViewIndex) {
      var bufferView = this.gltf.bufferViews[bufferViewIndex];

      if (this.glbParser) {
        return this.glbParser.getBufferView(bufferView);
      }

      var buffer = this.gltf.buffers[bufferView.buffer].data;
      var byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(buffer, byteOffset, bufferView.byteLength);
    }
  }, {
    key: "_removeExtension",
    value: function _removeExtension(extensionName) {
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }

      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }

      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
    }
  }, {
    key: "_removeStringFromArray",
    value: function _removeStringFromArray(array, string) {
      var found = true;

      while (found) {
        var index = array.indexOf(string);

        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
  }]);
  return GLTFParser;
}();

exports["default"] = GLTFParser;

},{"../gltf-constants":198,"../gltf-utils/gltf-attribute-utils":200,"../gltf-utils/gltf-utils":201,"./glb-parser":185,"./gltf-post-processor-old":188,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"@babel/runtime/regenerator":43,"@loaders.gl/core":148}],188:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _gltfUtils = require("../gltf-utils/gltf-utils");

var _DEFAULT_SAMPLER;

var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var GL_SAMPLER = {
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  REPEAT: 0x2901,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_LINEAR: 0x2702
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_SAMPLER = (_DEFAULT_SAMPLER = {}, (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MAG_FILTER, GL_SAMPLER.LINEAR), (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MIN_FILTER, GL_SAMPLER.NEAREST_MIPMAP_LINEAR), (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_S, GL_SAMPLER.REPEAT), (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_, GL_SAMPLER.REPEAT), _DEFAULT_SAMPLER);

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

var GLTFPostProcessorOld = function () {
  function GLTFPostProcessorOld() {
    (0, _classCallCheck2["default"])(this, GLTFPostProcessorOld);
  }

  (0, _createClass2["default"])(GLTFPostProcessorOld, [{
    key: "postProcess",
    value: function postProcess(gltf, glbParser) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.gltf = gltf;
      this.glbParser = glbParser;

      this._resolveToTree(options);

      return this.gltf;
    }
  }, {
    key: "_resolveToTree",
    value: function _resolveToTree() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var gltf = this.gltf;
      (gltf.bufferViews || []).forEach(function (bufView, i) {
        return _this._resolveBufferView(bufView, i);
      });
      (gltf.images || []).forEach(function (image, i) {
        return _this._resolveImage(image, i, options);
      });
      (gltf.samplers || []).forEach(function (sampler, i) {
        return _this._resolveSampler(sampler, i);
      });
      (gltf.textures || []).forEach(function (texture, i) {
        return _this._resolveTexture(texture, i);
      });
      (gltf.accessors || []).forEach(function (accessor, i) {
        return _this._resolveAccessor(accessor, i);
      });
      (gltf.materials || []).forEach(function (material, i) {
        return _this._resolveMaterial(material, i);
      });
      (gltf.meshes || []).forEach(function (mesh, i) {
        return _this._resolveMesh(mesh, i);
      });
      (gltf.nodes || []).forEach(function (node, i) {
        return _this._resolveNode(node, i);
      });
      (gltf.skins || []).forEach(function (skin, i) {
        return _this._resolveSkin(skin, i);
      });
      (gltf.scenes || []).forEach(function (scene, i) {
        return _this._resolveScene(scene, i);
      });

      if (gltf.scene !== undefined) {
        gltf.scene = gltf.scenes[this.gltf.scene];
      }

      this._process_extension_KHR_lights_punctual();

      return gltf;
    }
  }, {
    key: "getScene",
    value: function getScene(index) {
      return this._get('scenes', index);
    }
  }, {
    key: "getNode",
    value: function getNode(index) {
      return this._get('nodes', index);
    }
  }, {
    key: "getSkin",
    value: function getSkin(index) {
      return this._get('skins', index);
    }
  }, {
    key: "getMesh",
    value: function getMesh(index) {
      return this._get('meshes', index);
    }
  }, {
    key: "getMaterial",
    value: function getMaterial(index) {
      return this._get('materials', index);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(index) {
      return this._get('accessors', index);
    }
  }, {
    key: "getCamera",
    value: function getCamera(index) {
      return null;
    }
  }, {
    key: "getTexture",
    value: function getTexture(index) {
      return this._get('textures', index);
    }
  }, {
    key: "getSampler",
    value: function getSampler(index) {
      return this._get('samplers', index);
    }
  }, {
    key: "getImage",
    value: function getImage(index) {
      return this._get('images', index);
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(index) {
      return this._get('bufferViews', index);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(index) {
      return this._get('buffers', index);
    }
  }, {
    key: "_get",
    value: function _get(array, index) {
      if ((0, _typeof2["default"])(index) === 'object') {
        return index;
      }

      var object = this.gltf[array] && this.gltf[array][index];

      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }

      return object;
    }
  }, {
    key: "_resolveScene",
    value: function _resolveScene(scene, index) {
      var _this2 = this;

      scene.id = "scene-".concat(index);
      scene.nodes = (scene.nodes || []).map(function (node) {
        return _this2.getNode(node);
      });
    }
  }, {
    key: "_resolveNode",
    value: function _resolveNode(node, index) {
      var _this3 = this;

      node.id = "node-".concat(index);
      node.children = (node.children || []).map(function (child) {
        return _this3.getNode(child);
      });

      if (node.mesh !== undefined) {
        node.mesh = this.getMesh(node.mesh);
      }

      if (node.camera !== undefined) {
        node.camera = this.getCamera(node.camera);
      }

      if (node.skin !== undefined) {
        node.skin = this.getSkin(node.skin);
      }
    }
  }, {
    key: "_resolveSkin",
    value: function _resolveSkin(skin, index) {
      skin.id = "skin-".concat(index);
      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
    }
  }, {
    key: "_resolveMesh",
    value: function _resolveMesh(mesh, index) {
      mesh.id = "mesh-".concat(index);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = mesh.primitives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var primitive = _step.value;

          for (var attribute in primitive.attributes) {
            primitive.attributes[attribute] = this.getAccessor(primitive.attributes[attribute]);
          }

          if (primitive.indices !== undefined) {
            primitive.indices = this.getAccessor(primitive.indices);
          }

          if (primitive.material !== undefined) {
            primitive.material = this.getMaterial(primitive.material);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "_resolveMaterial",
    value: function _resolveMaterial(material, index) {
      material.id = "material-".concat(index);

      if (material.normalTexture) {
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }

      if (material.occlusionTexture) {
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }

      if (material.emissiveTexture) {
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }

      if (material.pbrMetallicRoughness) {
        var mr = material.pbrMetallicRoughness;

        if (mr.baseColorTexture) {
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }

        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
    }
  }, {
    key: "_resolveAccessor",
    value: function _resolveAccessor(accessor, index) {
      accessor.id = "accessor-".concat(index);

      if (accessor.bufferView !== undefined) {
        accessor.bufferView = this.getBufferView(accessor.bufferView);
      }

      accessor.bytesPerComponent = getBytesFromComponentType(accessor);
      accessor.components = getSizeFromAccessorType(accessor);
      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
    }
  }, {
    key: "_resolveTexture",
    value: function _resolveTexture(texture, index) {
      texture.id = "texture-".concat(index);
      texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
      texture.source = this.getImage(texture.source);
    }
  }, {
    key: "_resolveSampler",
    value: function _resolveSampler(sampler, index) {
      sampler.id = "sampler-".concat(index);
      sampler.parameters = {};

      for (var key in sampler) {
        var glEnum = this._enumSamplerParameter(key);

        if (glEnum !== undefined) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
    }
  }, {
    key: "_enumSamplerParameter",
    value: function _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
  }, {
    key: "_resolveImage",
    value: function _resolveImage(image, index, options) {
      var _this4 = this;

      image.id = "image-".concat(index);

      if (image.bufferView !== undefined) {
        image.bufferView = this.getBufferView(image.bufferView);
      }

      var _options$createImages = options.createImages,
          createImages = _options$createImages === void 0 ? true : _options$createImages;

      if (createImages) {
        image.image = this.glbParser.getImage(image);
      } else {
        image.getImageAsync = function () {
          if (_this4.glbParser) {
            return _this4.glbParser.getImageAsync(image);
          } else if (image.uri) {
            return new Promise(function (resolve) {
              var img = new Image();
              img.crossOrigin = 'anonymous';

              img.onload = function () {
                return resolve(img);
              };

              img.src = (0, _gltfUtils.getFullUri)(image.uri, options.uri);
            });
          }

          return null;
        };
      }
    }
  }, {
    key: "_resolveBufferView",
    value: function _resolveBufferView(bufferView, index) {
      bufferView.id = "bufferView-".concat(index);
      bufferView.buffer = this.getBuffer(bufferView.buffer);

      if (this.glbParser) {
        bufferView.data = this.glbParser.getBufferView(bufferView);
      } else {
        var byteOffset = bufferView.byteOffset || 0;
        bufferView.data = new Uint8Array(bufferView.buffer.data, byteOffset, bufferView.byteLength);
      }
    }
  }, {
    key: "_resolveCamera",
    value: function _resolveCamera(camera) {
      if (camera.perspective) {}

      if (camera.orthographic) {}
    }
  }, {
    key: "_process_extension_KHR_lights_punctual",
    value: function _process_extension_KHR_lights_punctual() {
      var gltf = this.gltf;
      var extension = gltf.extensions && gltf.extensions.KHR_lights_punctual;

      if (extension) {
        gltf.lights = extension.lights;
      }

      this._removeExtension('KHR_lights_punctual');

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (gltf.nodes || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var node = _step2.value;
          var nodeExtension = node.extensions && node.extensions.KHR_lights_punctual;

          if (nodeExtension) {
            node.light = this._get('lights', nodeExtension.light);
            delete node.extensions.KHR_lights_punctual;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      delete gltf.lights;
    }
  }, {
    key: "_removeExtension",
    value: function _removeExtension(extensionName) {
      if (this.gltf.extensionsRequired) {
        this._removeStringFromArray(this.gltf.extensionsRequired, extensionName);
      }

      if (this.gltf.extensionsUsed) {
        this._removeStringFromArray(this.gltf.extensionsUsed, extensionName);
      }

      if (this.gltf.extensions) {
        delete this.gltf.extensions[extensionName];
      }
    }
  }, {
    key: "_removeStringFromArray",
    value: function _removeStringFromArray(array, string) {
      var found = true;

      while (found) {
        var index = array.indexOf(string);

        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
  }]);
  return GLTFPostProcessorOld;
}();

exports["default"] = GLTFPostProcessorOld;

},{"../gltf-utils/gltf-utils":201,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flattenToTypedArray = flattenToTypedArray;

function flattenToTypedArray(nestedArray) {
  var ArrayType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float32Array;

  if (nestedArray.length === 0) {
    return new Float32Array(0);
  }

  if (!checkVertices(nestedArray)) {
    return null;
  }

  var count = countVertices(nestedArray);
  var typedArray = new ArrayType(count);
  flattenVerticesInPlace(nestedArray, typedArray);
  return typedArray;
}

function countVertices(nestedArray) {
  var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  var nestedCount = 0;
  var localCount = 0;
  var index = -1;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      nestedCount += countVertices(value);
    } else {
      localCount++;
    }
  }

  return nestedCount + (nestedCount === 0 && localCount < dimensions ? dimensions : localCount);
}

function checkVertices(nestedArray) {
  var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.isFinite;
  var index = -1;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (!checkVertices(value, predicate)) {
        return false;
      }
    } else if (!predicate(value)) {
      return false;
    }
  }

  return true;
}

function flattenVerticesInPlace(nestedArray, result) {
  var dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, 0);
  return result;
}

function flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, insert) {
  var index = -1;
  var vertexLength = 0;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      insert = flattenVerticesInPlaceRecursive(value, result, dimensions, insert);
    } else {
      if (vertexLength < dimensions) {
        result[insert++] = value;
        vertexLength++;
      }
    }
  }

  if (vertexLength > 0 && vertexLength < dimensions) {
    result[insert++] = 0;
  }

  return insert;
}

},{}],190:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = packBinaryJson;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _flattenToTypedArray = require("./flatten-to-typed-array");

function packBinaryJson(json, glbBuilder) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$flattenArray = options.flattenArrays,
      flattenArrays = _options$flattenArray === void 0 ? false : _options$flattenArray;
  var object = json;

  if (typeof object === 'string' && object.indexOf('#/') === 0) {
    return "#".concat(object);
  }

  if (Array.isArray(object)) {
    var typedArray = flattenArrays && (0, _flattenToTypedArray.flattenToTypedArray)(object);

    if (typedArray) {
      object = typedArray;
    } else {
      return object.map(function (element) {
        return packBinaryJson(element, glbBuilder, options);
      });
    }
  }

  if (ArrayBuffer.isView(object) && glbBuilder) {
    if (glbBuilder.isImage(object)) {
      var imageIndex = glbBuilder.addImage(object);
      return "#/images/".concat(imageIndex);
    }

    var bufferIndex = glbBuilder.addBuffer(object);
    return "#/accessors/".concat(bufferIndex);
  }

  if (object !== null && (0, _typeof2["default"])(object) === 'object') {
    var newObject = {};

    for (var key in object) {
      newObject[key] = packBinaryJson(object[key], glbBuilder, options);
    }

    return newObject;
  }

  return object;
}

},{"./flatten-to-typed-array":189,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],191:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = unpackJsonArrays;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function unpackJsonArrays(json, buffers) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return unpackJsonArraysRecursive(json, json, buffers, options);
}

function unpackJsonArraysRecursive(json, topJson, buffers) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var object = json;
  var buffer = decodeJSONPointer(object, buffers);

  if (buffer) {
    return buffer;
  }

  if (Array.isArray(object)) {
    return object.map(function (element) {
      return unpackJsonArraysRecursive(element, topJson, buffers, options);
    });
  }

  if (object !== null && (0, _typeof2["default"])(object) === 'object') {
    var newObject = {};

    for (var key in object) {
      newObject[key] = unpackJsonArraysRecursive(object[key], topJson, buffers, options);
    }

    return newObject;
  }

  return object;
}

function decodeJSONPointer(object, buffers) {
  var pointer = parseJSONPointer(object);

  if (pointer) {
    var _pointer = (0, _slicedToArray2["default"])(pointer, 2),
        field = _pointer[0],
        index = _pointer[1];

    var buffer = buffers[field] && buffers[field][index];

    if (buffer) {
      return buffer;
    }

    console.error("Invalid JSON pointer ".concat(object, ": #/").concat(field, "/").concat(index));
  }

  return null;
}

function parseJSONPointer(value) {
  if (typeof value === 'string') {
    if (value.indexOf('##/') === 0) {
      return value.slice(1);
    }

    var matches = value.match(/#\/([a-z]+)\/([0-9]+)/);

    if (matches) {
      var index = parseInt(matches[2], 10);
      return [matches[1], index];
    }

    matches = value.match(/\$\$\$([0-9]+)/);

    if (matches) {
      var _index = parseInt(matches[1], 10);

      return ['accessors', _index];
    }
  }

  return null;
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37,"@babel/runtime/helpers/typeof":40}],192:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = unpackGLBBuffers;

var _assert = _interopRequireDefault(require("../../utils/assert"));

var _gltfUtils = require("../../gltf-utils/gltf-utils");

function unpackGLBBuffers(arrayBuffer, json, binaryByteOffset) {
  if (binaryByteOffset) {
    arrayBuffer = getArrayBufferAtOffset(arrayBuffer, binaryByteOffset);
  }

  var bufferViews = json.bufferViews || [];

  for (var i = 0; i < bufferViews.length; ++i) {
    var bufferView = bufferViews[i];
    (0, _assert["default"])(bufferView.byteLength >= 0);
  }

  return {
    accessors: unpackAccessors(arrayBuffer, bufferViews, json),
    images: unpackImages(arrayBuffer, bufferViews, json)
  };
}

function unpackAccessors(arrayBuffer, bufferViews, json) {
  var accessors = json.accessors || [];
  var accessorBuffers = [];

  for (var i = 0; i < accessors.length; ++i) {
    var accessor = accessors[i];
    (0, _assert["default"])(accessor);
    var bufferView = bufferViews[accessor.bufferView];

    if (bufferView) {
      var _getAccessorArrayType = (0, _gltfUtils.getAccessorArrayTypeAndLength)(accessor, bufferView),
          ArrayType = _getAccessorArrayType.ArrayType,
          length = _getAccessorArrayType.length;

      var array = new ArrayType(arrayBuffer, bufferView.byteOffset, length);
      array.accessor = accessor;
      accessorBuffers.push(array);
    }
  }

  return accessorBuffers;
}

function unpackImages(arrayBuffer, bufferViews, json) {
  var images = json.images || [];
  var imageBuffers = [];

  for (var i = 0; i < images.length; ++i) {
    var image = images[i];
    (0, _assert["default"])(image);
    var bufferView = bufferViews[image.bufferView];
    (0, _assert["default"])(bufferView);
    var array = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    array.imate = image;
    imageBuffers.push(array);
  }

  return imageBuffers;
}

function getArrayBufferAtOffset(arrayBuffer, byteOffset) {
  var length = arrayBuffer.byteLength - byteOffset;
  var binaryBuffer = new ArrayBuffer(length);
  var sourceArray = new Uint8Array(arrayBuffer);
  var binaryArray = new Uint8Array(binaryBuffer);

  for (var i = 0; i < length; i++) {
    binaryArray[i] = sourceArray[byteOffset + i];
  }

  return binaryBuffer;
}

},{"../../gltf-utils/gltf-utils":201,"../../utils/assert":205,"@babel/runtime/helpers/interopRequireDefault":25}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = encodeGLBSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

var MAGIC_glTF = 0x46546c67;
var MAGIC_JSON = 0x4e4f534a;
var MAGIC_BIN = 0x004e4942;
var LE = true;

function encodeGLBSync(glb, dataView) {
  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _glb$magic = glb.magic,
      magic = _glb$magic === void 0 ? MAGIC_glTF : _glb$magic,
      _glb$version = glb.version,
      version = _glb$version === void 0 ? 2 : _glb$version,
      _glb$json = glb.json,
      json = _glb$json === void 0 ? {} : _glb$json,
      binary = glb.binary;
  var byteOffsetStart = byteOffset;

  if (dataView) {
    dataView.setUint32(byteOffset + 0, magic, LE);
    dataView.setUint32(byteOffset + 4, version, LE);
    dataView.setUint32(byteOffset + 8, 0, LE);
  }

  var byteOffsetFileLength = byteOffset + 8;
  byteOffset += 12;
  var byteOffsetJsonHeader = byteOffset;

  if (dataView) {
    dataView.setUint32(byteOffset + 0, 0, LE);
    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE);
  }

  byteOffset += 8;
  var jsonString = JSON.stringify(json);
  byteOffset = (0, _loaderUtils.copyPaddedStringToDataView)(dataView, byteOffset, jsonString, 4);

  if (dataView) {
    var jsonByteLength = byteOffset - byteOffsetJsonHeader - 8;
    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE);
  }

  if (binary) {
    var byteOffsetBinHeader = byteOffset;

    if (dataView) {
      dataView.setUint32(byteOffset + 0, 0, LE);
      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE);
    }

    byteOffset += 8;
    byteOffset = (0, _loaderUtils.copyPaddedArrayBufferToDataView)(dataView, byteOffset, binary, 4);

    if (dataView) {
      var binByteLength = byteOffset - byteOffsetBinHeader - 8;
      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE);
    }
  }

  if (dataView) {
    var fileByteLength = byteOffset - byteOffsetStart;
    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE);
  }

  return byteOffset;
}

},{"@loaders.gl/loader-utils":217}],194:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeGLTFSync = encodeGLTFSync;

var _encodeGlb = _interopRequireDefault(require("./encode-glb"));

function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {
  convertBuffersToBase64(gltf);
  return (0, _encodeGlb["default"])(gltf, arrayBuffer, byteOffset, options);
}

function convertBuffersToBase64(gltf) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$firstBuffer = _ref.firstBuffer,
      firstBuffer = _ref$firstBuffer === void 0 ? 0 : _ref$firstBuffer;

  if (gltf.buffers && gltf.buffers.length > firstBuffer) {
    throw new Error('encodeGLTF: multiple buffers not yet implemented');
  }
}

},{"./encode-glb":193,"@babel/runtime/helpers/interopRequireDefault":25}],195:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _gltfScenegraph = _interopRequireDefault(require("../gltf-scenegraph"));

var _gltfConstants = require("../gltf-constants");

var _gltfAttributeUtils = require("../gltf-utils/gltf-attribute-utils");

var KHR_draco_mesh_compression = function () {
  function KHR_draco_mesh_compression() {
    (0, _classCallCheck2["default"])(this, KHR_draco_mesh_compression);
  }

  (0, _createClass2["default"])(KHR_draco_mesh_compression, null, [{
    key: "decode",
    value: function decode(gltfData, options) {
      var gltfScenegraph = new _gltfScenegraph["default"](gltfData);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (gltfScenegraph.json.meshes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var mesh = _step.value;
          KHR_draco_mesh_compression.decompressMesh(mesh, options);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      gltfScenegraph.removeExtension(_gltfConstants.KHR_DRACO_MESH_COMPRESSION);
    }
  }, {
    key: "encode",
    value: function encode(gltfData, options) {
      var gltfScenegraph = new _gltfScenegraph["default"](gltfData);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (gltfScenegraph.json.meshes || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var mesh = _step2.value;
          KHR_draco_mesh_compression.compressMesh(mesh, options);
          gltfScenegraph.addRequiredExtension(_gltfConstants.KHR_DRACO_MESH_COMPRESSION);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "compressMesh",
    value: function compressMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!options.DracoWriter || !options.DracoLoader) {
        throw new Error('DracoWriter/DracoLoader not available');
      }

      var compressedData = options.DracoWriter.encodeSync({
        attributes: attributes
      });
      var decodedData = options.DracoLoader.parseSync({
        attributes: attributes
      });

      var fauxAccessors = options._addFauxAttributes(decodedData.attributes);

      var bufferViewIndex = options.addBufferView(compressedData);
      var glTFMesh = {
        primitives: [{
          attributes: fauxAccessors,
          mode: mode,
          extensions: (0, _defineProperty2["default"])({}, _gltfConstants.KHR_DRACO_MESH_COMPRESSION, {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          })
        }]
      };
      return glTFMesh;
    }
  }, {
    key: "decompressMesh",
    value: function decompressMesh(mesh) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = mesh.primitives[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var primitive = _step3.value;

          KHR_draco_mesh_compression._decompressMeshPrimitive(primitive, options);

          if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {
            throw new Error('Empty glTF primitive: decompression failure?');
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "_decompressMeshPrimitive",
    value: function _decompressMeshPrimitive(primitive, options) {
      var compressedPrimitive = primitive.extensions && primitive.extensions[_gltfConstants.KHR_DRACO_MESH_COMPRESSION];

      if (!compressedPrimitive) {
        return;
      }

      if (!options.DracoLoader || !options.decompress) {
        return;
      }

      delete primitive.extensions[_gltfConstants.KHR_DRACO_MESH_COMPRESSION];

      var buffer = this._getBufferViewArray(compressedPrimitive.bufferView);

      var decodedData = options.DracoLoader.parseSync(buffer);
      primitive.attributes = (0, _gltfAttributeUtils.getGLTFAccessors)(decodedData.attributes);

      if (decodedData.indices) {
        primitive.indices = (0, _gltfAttributeUtils.getGLTFAccessor)(decodedData.indices);
      }
    }
  }, {
    key: "name",
    get: function get() {
      return _gltfConstants.KHR_DRACO_MESH_COMPRESSION;
    }
  }]);
  return KHR_draco_mesh_compression;
}();

exports["default"] = KHR_draco_mesh_compression;

},{"../gltf-constants":198,"../gltf-scenegraph":199,"../gltf-utils/gltf-attribute-utils":200,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],196:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _gltfScenegraph = _interopRequireDefault(require("../gltf-scenegraph"));

var _gltfConstants = require("../gltf-constants");

var _assert = _interopRequireDefault(require("../utils/assert"));

var KHR_lights_punctual = function () {
  function KHR_lights_punctual() {
    (0, _classCallCheck2["default"])(this, KHR_lights_punctual);
  }

  (0, _createClass2["default"])(KHR_lights_punctual, null, [{
    key: "decode",
    value: function decode(gltfData, options) {
      var gltfScenegraph = new _gltfScenegraph["default"](gltfData);
      var extension = gltfScenegraph.getExtension(_gltfConstants.KHR_LIGHTS_PUNCTUAL);

      if (extension) {
        gltfScenegraph.json.lights = extension.lights;
        gltfScenegraph.removeExtension(_gltfConstants.KHR_LIGHTS_PUNCTUAL);
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (gltfScenegraph.nodes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;
          var nodeExtension = node.extensions && node.extensions.KHR_lights_punctual;

          if (nodeExtension) {
            node.light = gltfScenegraph._get('lights', nodeExtension.light);
            delete node.extensions.KHR_lights_punctual;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "encode",
    value: function encode(gltfData, options) {
      var gltfScenegraph = new _gltfScenegraph["default"](gltfData);
      var json = gltfScenegraph.json;

      if (json.lights) {
        var extension = gltfScenegraph.addExtensions(_gltfConstants.KHR_LIGHTS_PUNCTUAL);
        (0, _assert["default"])(!extension.lights);
        extension.lights = json.lights;
        delete json.lights;
      }

      if (gltfScenegraph.json.lights) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = gltfScenegraph.json.lights[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var light = _step2.value;
            var node = light.node;
            gltfScenegraph.addObjectExtension(node, _gltfConstants.KHR_LIGHTS_PUNCTUAL, light);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        delete gltfScenegraph.json.lights;
      }
    }
  }, {
    key: "name",
    get: function get() {
      return _gltfConstants.KHR_LIGHTS_PUNCTUAL;
    }
  }]);
  return KHR_lights_punctual;
}();

exports["default"] = KHR_lights_punctual;

},{"../gltf-constants":198,"../gltf-scenegraph":199,"../utils/assert":205,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],197:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "KHR_draco_mesh_compression", {
  enumerable: true,
  get: function get() {
    return _KHR_draco_mesh_compression["default"];
  }
});
Object.defineProperty(exports, "KHR_lights_punctual", {
  enumerable: true,
  get: function get() {
    return _KHR_lights_punctual["default"];
  }
});

var _KHR_draco_mesh_compression = _interopRequireDefault(require("./KHR_draco_mesh_compression"));

var _KHR_lights_punctual = _interopRequireDefault(require("./KHR_lights_punctual"));

},{"./KHR_draco_mesh_compression":195,"./KHR_lights_punctual":196,"@babel/runtime/helpers/interopRequireDefault":25}],198:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBytesFromComponentType = getBytesFromComponentType;
exports.getSizeFromAccessorType = getSizeFromAccessorType;
exports.getGLEnumFromSamplerParameter = getGLEnumFromSamplerParameter;
exports.KHR_LIGHTS_PUNCTUAL = exports.UBER_POINT_CLOUD_EXTENSION = exports.KHR_DRACO_MESH_COMPRESSION = void 0;
var KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';
exports.KHR_DRACO_MESH_COMPRESSION = KHR_DRACO_MESH_COMPRESSION;
var UBER_POINT_CLOUD_EXTENSION = 'UBER_draco_point_cloud_compression';
exports.UBER_POINT_CLOUD_EXTENSION = UBER_POINT_CLOUD_EXTENSION;
var KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';
exports.KHR_LIGHTS_PUNCTUAL = KHR_LIGHTS_PUNCTUAL;
var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

function getGLEnumFromSamplerParameter(parameter) {
  var GL_TEXTURE_MAG_FILTER = 0x2800;
  var GL_TEXTURE_MIN_FILTER = 0x2801;
  var GL_TEXTURE_WRAP_S = 0x2802;
  var GL_TEXTURE_WRAP_T = 0x2803;
  var PARAMETER_MAP = {
    magFilter: GL_TEXTURE_MAG_FILTER,
    minFilter: GL_TEXTURE_MIN_FILTER,
    wrapS: GL_TEXTURE_WRAP_S,
    wrapT: GL_TEXTURE_WRAP_T
  };
  return PARAMETER_MAP[parameter];
}

},{}],199:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _images = require("@loaders.gl/images");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _assert = _interopRequireDefault(require("./utils/assert"));

var _gltfUtils = require("./gltf-utils/gltf-utils");

var GLTFScenegraph = function () {
  function GLTFScenegraph(gltf) {
    (0, _classCallCheck2["default"])(this, GLTFScenegraph);

    if (gltf instanceof GLTFScenegraph) {
      return gltf;
    }

    if (!gltf) {
      gltf = {
        json: {
          version: 2,
          buffers: []
        },
        binary: null
      };
    }

    this.gltf = gltf;
  }

  (0, _createClass2["default"])(GLTFScenegraph, [{
    key: "getApplicationData",
    value: function getApplicationData(key) {
      var data = this.json[key];
      return data;
    }
  }, {
    key: "getExtraData",
    value: function getExtraData(key) {
      var extras = this.json.extras || {};
      return extras[key];
    }
  }, {
    key: "getExtension",
    value: function getExtension(extensionName) {
      var isExtension = this.getUsedExtensions().find(function (name) {
        return name === extensionName;
      });
      var extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] || true : null;
    }
  }, {
    key: "getRequiredExtension",
    value: function getRequiredExtension(extensionName) {
      var isRequired = this.getRequiredExtensions().find(function (name) {
        return name === extensionName;
      });
      return isRequired ? this.getExtension(extensionName) : null;
    }
  }, {
    key: "getRequiredExtensions",
    value: function getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
  }, {
    key: "getUsedExtensions",
    value: function getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
  }, {
    key: "getObjectExtension",
    value: function getObjectExtension(object, extensionName) {
      var extensions = object.extensions || {};
      return extensions[extensionName];
    }
  }, {
    key: "getScene",
    value: function getScene(index) {
      return this.getObject('scenes', index);
    }
  }, {
    key: "getNode",
    value: function getNode(index) {
      return this.getObject('nodes', index);
    }
  }, {
    key: "getSkin",
    value: function getSkin(index) {
      return this.getObject('skins', index);
    }
  }, {
    key: "getMesh",
    value: function getMesh(index) {
      return this.getObject('meshes', index);
    }
  }, {
    key: "getMaterial",
    value: function getMaterial(index) {
      return this.getObject('materials', index);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(index) {
      return this.getObject('accessors', index);
    }
  }, {
    key: "getCamera",
    value: function getCamera(index) {
      return null;
    }
  }, {
    key: "getTexture",
    value: function getTexture(index) {
      return this.getObject('textures', index);
    }
  }, {
    key: "getSampler",
    value: function getSampler(index) {
      return this.getObject('samplers', index);
    }
  }, {
    key: "getImage",
    value: function getImage(index) {
      return this.getObject('images', index);
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(index) {
      return this.getObject('bufferViews', index);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(index) {
      return this.getObject('buffers', index);
    }
  }, {
    key: "getObject",
    value: function getObject(array, index) {
      if ((0, _typeof2["default"])(index) === 'object') {
        return index;
      }

      var object = this.gltf[array] && this.gltf[array][index];

      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }

      return object;
    }
  }, {
    key: "getTypedArrayForBufferView",
    value: function getTypedArrayForBufferView(bufferView) {
      bufferView = this.getBufferView(bufferView);
      var buffer = this.getBuffer(bufferView.buffer);
      var arrayBuffer = buffer.data;
      var byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    }
  }, {
    key: "getTypedArrayForAccessor",
    value: function getTypedArrayForAccessor(accessor) {
      accessor = this.getAccessor(accessor);
      var bufferView = this.getBuffer(accessor.bufferView);
      var buffer = this.getBuffer(bufferView.buffer);
      var arrayBuffer = buffer.data;

      var _getAccessorArrayType = (0, _gltfUtils.getAccessorArrayTypeAndLength)(accessor, bufferView),
          ArrayType = _getAccessorArrayType.ArrayType,
          length = _getAccessorArrayType.length;

      var byteOffset = bufferView.byteOffset + accessor.byteOffset;
      return new ArrayType(arrayBuffer, byteOffset, length);
    }
  }, {
    key: "getTypedArrayForImageData",
    value: function getTypedArrayForImageData(image) {
      image = this.getAccessor(image);
      var bufferView = this.getBuffer(image.bufferView);
      var buffer = this.getBuffer(bufferView.buffer);
      var arrayBuffer = buffer.data;
      var byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    }
  }, {
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      this.json[key] = data;
      return this;
    }
  }, {
    key: "addExtraData",
    value: function addExtraData(key, data) {
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = data;
      return this;
    }
  }, {
    key: "addExtension",
    value: function addExtension(extensionName, data) {
      (0, _assert["default"])(data);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = data;
      this.registerUsedExtension(extensionName);
      return this;
    }
  }, {
    key: "addRequiredExtension",
    value: function addRequiredExtension(extensionName, data) {
      (0, _assert["default"])(data);
      this.addExtension(extensionName, data);
      this.registerRequiredExtension(extensionName);
      return this;
    }
  }, {
    key: "registerUsedExtension",
    value: function registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];

      if (!this.json.extensionsUsed.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
  }, {
    key: "registerRequiredExtension",
    value: function registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];

      if (!this.json.extensionsRequired.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
  }, {
    key: "removeExtension",
    value: function removeExtension(extensionName) {
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }

      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }

      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
    }
  }, {
    key: "setObjectExtension",
    value: function setObjectExtension(object, extensionName, data) {
      var extensions = object.extensions || {};
      extensions[extensionName] = data;
    }
  }, {
    key: "addMesh",
    value: function addMesh(attributes, indices) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      var accessors = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessors,
          indices: indices,
          mode: mode
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addPointCloud",
    value: function addPointCloud(attributes) {
      var accessorIndices = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addImage",
    value: function addImage(imageData, mimeType) {
      mimeType = mimeType || (0, _images.getImageMIMEType)(imageData);
      var bufferViewIndex = this.addBufferView(imageData);
      var glTFImage = {
        bufferView: bufferViewIndex,
        mimeType: mimeType
      };
      this.json.images = this.json.images || [];
      this.json.images.push(glTFImage);
      return this.json.images.length - 1;
    }
  }, {
    key: "addBufferView",
    value: function addBufferView(buffer) {
      var byteLength = buffer.byteLength;
      (0, _assert["default"])(Number.isFinite(byteLength));
      this.sourceBuffers = this.sourceBuffers || [];
      this.sourceBuffers.push(buffer);
      var glTFBufferView = {
        buffer: 0,
        byteOffset: this.byteLength,
        byteLength: byteLength
      };
      this.byteLength += (0, _loaderUtils.padTo4Bytes)(byteLength);
      this.json.bufferViews = this.json.bufferViews || [];
      this.json.bufferViews.push(glTFBufferView);
      return this.json.bufferViews.length - 1;
    }
  }, {
    key: "addAccessor",
    value: function addAccessor(bufferViewIndex, accessor) {
      var glTFAccessor = {
        bufferView: bufferViewIndex,
        type: (0, _gltfUtils.getAccessorTypeFromSize)(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count
      };
      this.json.accessors = this.json.accessors || [];
      this.json.accessors.push(glTFAccessor);
      return this.json.accessors.length - 1;
    }
  }, {
    key: "addBinaryBuffer",
    value: function addBinaryBuffer(sourceBuffer) {
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        size: 3
      };
      var bufferViewIndex = this.addBufferView(sourceBuffer);
      var accessorDefaults = {
        size: accessor.size,
        componentType: (0, _gltfUtils.getComponentTypeFromArray)(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size)
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
  }, {
    key: "createBinaryChunk",
    value: function createBinaryChunk() {
      if (this.arrayBuffer) {
        return;
      }

      var totalByteLength = this.byteLength;
      var arrayBuffer = new ArrayBuffer(totalByteLength);
      var targetArray = new Uint8Array(arrayBuffer);
      var dstByteOffset = 0;

      for (var i = 0; i < this.sourceBuffers.length; i++) {
        var sourceBuffer = this.sourceBuffers[i];
        dstByteOffset = (0, _loaderUtils.copyToArray)(sourceBuffer, targetArray, dstByteOffset);
      }

      this.json.buffers[0].byteLength = totalByteLength;
      this.arrayBuffer = arrayBuffer;
      this.sourceBuffers = [];
    }
  }, {
    key: "_removeStringFromArray",
    value: function _removeStringFromArray(array, string) {
      var found = true;

      while (found) {
        var index = array.indexOf(string);

        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
  }, {
    key: "json",
    get: function get() {
      return this.gltf.json;
    }
  }]);
  return GLTFScenegraph;
}();

exports["default"] = GLTFScenegraph;

},{"./gltf-utils/gltf-utils":201,"./utils/assert":205,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"@loaders.gl/images":208,"@loaders.gl/loader-utils":217}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGLTFAccessors = getGLTFAccessors;
exports.getGLTFAccessor = getGLTFAccessor;
exports.getGLTFAttribute = getGLTFAttribute;

var _gltfUtils = require("./gltf-utils");

function getGLTFAccessors(attributes) {
  var accessors = {};

  for (var name in attributes) {
    var attribute = attributes[name];

    if (name !== 'indices') {
      var glTFAccessor = getGLTFAccessor(attribute);
      accessors[name] = glTFAccessor;
    }
  }

  return accessors;
}

function getGLTFAccessor(attribute, gltfAttributeName) {
  var _getAccessorData = getAccessorData(attribute, gltfAttributeName),
      buffer = _getAccessorData.buffer,
      size = _getAccessorData.size,
      count = _getAccessorData.count;

  var glTFAccessor = {
    value: buffer,
    size: size,
    bufferView: null,
    byteOffset: 0,
    count: count,
    type: (0, _gltfUtils.getAccessorTypeFromSize)(size),
    componentType: (0, _gltfUtils.getComponentTypeFromArray)(buffer)
  };
  return glTFAccessor;
}

function getGLTFAttribute(data, gltfAttributeName) {
  return data.attributes[data.glTFAttributeMap[gltfAttributeName]];
}

function getAccessorData(attribute, attributeName) {
  var buffer = attribute;
  var size = 1;
  var count = 0;

  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }

  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }

    count = buffer.length / size;
  }

  return {
    buffer: buffer,
    size: size,
    count: count
  };
}

function toTypedArray(array, ArrayType) {
  var convertTypedArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!array) {
    return null;
  }

  if (Array.isArray(array)) {
    return new ArrayType(array);
  }

  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }

  return array;
}

},{"./gltf-utils":201}],201:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAccessorTypeFromSize = getAccessorTypeFromSize;
exports.getComponentTypeFromArray = getComponentTypeFromArray;
exports.getAccessorArrayTypeAndLength = getAccessorArrayTypeAndLength;
exports.getFullUri = getFullUri;
exports.ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = exports.ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = exports.ATTRIBUTE_TYPE_TO_COMPONENTS = void 0;

var _assert = _interopRequireDefault(require("../utils/assert"));

var TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];
var ARRAY_TO_COMPONENT_TYPE = new Map([[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126]]);
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
exports.ATTRIBUTE_TYPE_TO_COMPONENTS = ATTRIBUTE_TYPE_TO_COMPONENTS;
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
exports.ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE;
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
exports.ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY;

function getAccessorTypeFromSize(size) {
  var type = TYPES[size - 1];
  return type || TYPES[0];
}

function getComponentTypeFromArray(typedArray) {
  var componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);

  if (!componentType) {
    throw new Error('Illegal typed array');
  }

  return componentType;
}

function getAccessorArrayTypeAndLength(accessor, bufferView) {
  var ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  var components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  var bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  var length = accessor.count * components;
  var byteLength = accessor.count * components * bytesPerComponent;
  (0, _assert["default"])(byteLength >= 0 && byteLength <= bufferView.byteLength);
  return {
    ArrayType: ArrayType,
    length: length,
    byteLength: byteLength
  };
}

function getFullUri(uri, base) {
  var absolute = uri.startsWith('data:') || uri.startsWith('http:') || uri.startsWith('https:');
  return absolute ? uri : base.substr(0, base.lastIndexOf('/') + 1) + uri;
}

},{"../utils/assert":205,"@babel/runtime/helpers/interopRequireDefault":25}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGLB = isGLB;
exports["default"] = parseGLBSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

var MAGIC_glTF = 0x676c5446;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
var GLB_CHUNK_TYPE_BIN = 0x004e4942;
var LE = true;
var BE = false;

function getMagicString(dataView) {
  return "".concat(String.fromCharCode(dataView.getUint8(0))).concat(String.fromCharCode(dataView.getUint8(1))).concat(String.fromCharCode(dataView.getUint8(2))).concat(String.fromCharCode(dataView.getUint8(3)));
}

function isGLB(arrayBuffer) {
  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var dataView = new DataView(arrayBuffer);
  var _options$magic = options.magic,
      magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;
  var magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}

function parseGLBSync(glb, arrayBuffer) {
  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dataView = new DataView(arrayBuffer);
  glb.byteOffset = byteOffset;
  glb.magic = dataView.getUint32(byteOffset + 0, BE);
  glb.version = dataView.getUint32(byteOffset + 4, LE);
  glb.byteLength = dataView.getUint32(byteOffset + 8, LE);
  glb.type = getMagicString(dataView);
  var _options$magic2 = options.magic,
      magic = _options$magic2 === void 0 ? MAGIC_glTF : _options$magic2;
  var isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;

  if (!isMagicValid) {
    console.warn("Invalid GLB magic string ".concat(glb.type));
  }

  (0, _loaderUtils.assert)(glb.version === 2, "Invalid GLB version ".concat(glb.version, ". Only .glb v2 supported"));
  (0, _loaderUtils.assert)(glb.byteLength > 20);
  var jsonChunkLength = dataView.getUint32(byteOffset + 12, LE);
  var jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE);
  var isJSONChunk = jsonChunkFormat === GLB_CHUNK_TYPE_JSON || jsonChunkFormat === 0;
  (0, _loaderUtils.assert)(isJSONChunk, "JSON chunk format ".concat(jsonChunkFormat));
  var jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE;
  var jsonChunk = new Uint8Array(arrayBuffer, byteOffset + jsonChunkByteOffset, jsonChunkLength);
  var textDecoder = new TextDecoder('utf8');
  var jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  var binChunkStart = jsonChunkByteOffset + (0, _loaderUtils.padTo4Bytes)(jsonChunkLength);
  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;

  if (glb.hasBinChunk) {
    var binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);
    var binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);
    var isBinChunk = binChunkFormat === GLB_CHUNK_TYPE_BIN || binChunkFormat === 1;
    (0, _loaderUtils.assert)(isBinChunk, "BIN chunk format ".concat(binChunkFormat));
    var binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;
    glb.binChunkByteOffset = binChunkByteOffset;
    glb.binChunkLength = binChunkLength;
  }

  return byteOffset + glb.byteLength;
}

},{"@loaders.gl/loader-utils":217}],203:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGLTF = isGLTF;
exports.parseGLTFSync = parseGLTFSync;
exports.parseGLTF = parseGLTF;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _core = require("@loaders.gl/core");

var _assert = _interopRequireDefault(require("./utils/assert"));

var _gltfUtils = require("./gltf-utils/gltf-utils");

var _parseGlb = _interopRequireWildcard(require("./parse-glb"));

var EXTENSIONS = _interopRequireWildcard(require("./extensions"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_SYNC_OPTIONS = {
  fetchLinkedResources: false,
  decompress: false,
  DracoLoader: null,
  postProcess: true,
  createImages: false,
  log: console
};
var DEFAULT_ASYNC_OPTIONS = {
  fetchLinkedResources: true,
  fetch: _core.fetchFile,
  decompress: false,
  DracoLoader: null,
  postProcess: true,
  createImages: false,
  log: console
};

function isGLTF(arrayBuffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var dataView = new DataView(arrayBuffer);
  var byteOffset = 0;
  return (0, _parseGlb.isGLB)(dataView, byteOffset);
}

function parseGLTFSync(gltf, arrayBufferOrString) {
  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  options = Object.assign({}, DEFAULT_SYNC_OPTIONS, options);
  var data = arrayBufferOrString;

  if (data instanceof ArrayBuffer && !(0, _parseGlb.isGLB)(data, byteOffset, options)) {
    var textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }

  gltf.buffers = [];

  if (typeof data === 'string') {
    gltf.json = JSON.parse(data);
  } else if (data instanceof ArrayBuffer) {
    byteOffset = (0, _parseGlb["default"])(gltf, data, byteOffset, options);

    if (gltf.hasBinChunk) {
      gltf.buffers.push({
        arrayBuffer: data,
        byteOffset: gltf.binChunkByteOffset,
        byteLength: gltf.binChunkLength
      });
    }
  } else {
    gltf.json = data;
  }

  if (options.uri) {
    gltf.baseUri = options.uri;
  }

  if (options.fetchLinkedResources) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (gltf.json.buffers || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var buffer = _step.value;

        if (buffer.uri) {
          throw new Error('parseGLTFSync: Cannot decode uri buffers');
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  decodeExtensions(gltf, options);
  return byteOffset;
}

function parseGLTF(_x, _x2) {
  return _parseGLTF.apply(this, arguments);
}

function _parseGLTF() {
  _parseGLTF = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(gltf, arrayBufferOrString) {
    var byteOffset,
        options,
        _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            byteOffset = _args.length > 2 && _args[2] !== undefined ? _args[2] : 0;
            options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
            options = Object.assign({}, DEFAULT_ASYNC_OPTIONS, options);
            parseGLTFSync(gltf, arrayBufferOrString, byteOffset, _objectSpread({}, options, {
              fetchLinkedResources: false,
              postProcess: false,
              decompress: false
            }));

            if (!options.fetchLinkedResources) {
              _context.next = 7;
              break;
            }

            _context.next = 7;
            return fetchLinkedResources(gltf, options);

          case 7:
            return _context.abrupt("return", gltf);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseGLTF.apply(this, arguments);
}

function fetchLinkedResources(_x3, _x4) {
  return _fetchLinkedResources.apply(this, arguments);
}

function _fetchLinkedResources() {
  _fetchLinkedResources = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(gltf, options) {
    var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, buffer, fetch, uri, response, arrayBuffer;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            _context2.prev = 3;
            _iterator2 = gltf.json.buffers[Symbol.iterator]();

          case 5:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              _context2.next = 22;
              break;
            }

            buffer = _step2.value;

            if (!buffer.uri) {
              _context2.next = 19;
              break;
            }

            fetch = options.fetch || window.fetch;
            (0, _assert["default"])(fetch);
            uri = (0, _gltfUtils.getFullUri)(buffer.uri, options.uri);
            _context2.next = 13;
            return fetch(uri);

          case 13:
            response = _context2.sent;
            _context2.next = 16;
            return response.arrayBuffer();

          case 16:
            arrayBuffer = _context2.sent;
            buffer.data = arrayBuffer;
            delete buffer.uri;

          case 19:
            _iteratorNormalCompletion2 = true;
            _context2.next = 5;
            break;

          case 22:
            _context2.next = 28;
            break;

          case 24:
            _context2.prev = 24;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context2.t0;

          case 28:
            _context2.prev = 28;
            _context2.prev = 29;

            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }

          case 31:
            _context2.prev = 31;

            if (!_didIteratorError2) {
              _context2.next = 34;
              break;
            }

            throw _iteratorError2;

          case 34:
            return _context2.finish(31);

          case 35:
            return _context2.finish(28);

          case 36:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 24, 28, 36], [29,, 31, 35]]);
  }));
  return _fetchLinkedResources.apply(this, arguments);
}

function decodeExtensions(gltf, options) {
  for (var extensionName in EXTENSIONS) {
    var disableExtension = extensionName in options && !options[extensionName];

    if (!disableExtension) {
      var extension = EXTENSIONS[extensionName];
      extension.decode(gltf, options);
    }
  }
}

},{"./extensions":197,"./gltf-utils/gltf-utils":201,"./parse-glb":202,"./utils/assert":205,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/regenerator":43,"@loaders.gl/core":148}],204:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = postProcessGLTF;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _gltfUtils = require("./gltf-utils/gltf-utils");

var _DEFAULT_SAMPLER;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var GL_SAMPLER = {
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  REPEAT: 0x2901,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_LINEAR: 0x2702
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_SAMPLER = (_DEFAULT_SAMPLER = {}, (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MAG_FILTER, GL_SAMPLER.LINEAR), (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MIN_FILTER, GL_SAMPLER.NEAREST_MIPMAP_LINEAR), (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_S, GL_SAMPLER.REPEAT), (0, _defineProperty2["default"])(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_, GL_SAMPLER.REPEAT), _DEFAULT_SAMPLER);

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

var GLTFPostProcessor = function () {
  function GLTFPostProcessor() {
    (0, _classCallCheck2["default"])(this, GLTFPostProcessor);
  }

  (0, _createClass2["default"])(GLTFPostProcessor, [{
    key: "postProcess",
    value: function postProcess(gltf) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.gltf = gltf;
      this.json = gltf.json;
      this.buffers = gltf.buffers;
      return this._resolveTree(gltf.json, options);
    }
  }, {
    key: "_resolveTree",
    value: function _resolveTree(json) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (json.bufferViews) {
        json.bufferViews = json.bufferViews.map(function (bufView, i) {
          return _this._resolveBufferView(bufView, i);
        });
      }

      if (json.images) {
        json.images = json.images.map(function (image, i) {
          return _this._resolveImage(image, i, options);
        });
      }

      if (json.samplers) {
        json.samplers = json.samplers.map(function (sampler, i) {
          return _this._resolveSampler(sampler, i);
        });
      }

      if (json.textures) {
        json.textures = json.textures.map(function (texture, i) {
          return _this._resolveTexture(texture, i);
        });
      }

      if (json.accessors) {
        json.accessors = json.accessors.map(function (accessor, i) {
          return _this._resolveAccessor(accessor, i);
        });
      }

      if (json.materials) {
        json.materials = json.materials.map(function (material, i) {
          return _this._resolveMaterial(material, i);
        });
      }

      if (json.meshes) {
        json.meshes = json.meshes.map(function (mesh, i) {
          return _this._resolveMesh(mesh, i);
        });
      }

      if (json.nodes) {
        json.nodes = json.nodes.map(function (node, i) {
          return _this._resolveNode(node, i);
        });
      }

      if (json.skins) {
        json.skins = json.skins.map(function (skin, i) {
          return _this._resolveSkin(skin, i);
        });
      }

      if (json.scenes) {
        json.scenes = json.scenes.map(function (scene, i) {
          return _this._resolveScene(scene, i);
        });
      }

      if (json.scene !== undefined) {
        json.scene = json.scenes[this.json.scene];
      }

      return json;
    }
  }, {
    key: "getScene",
    value: function getScene(index) {
      return this._get('scenes', index);
    }
  }, {
    key: "getNode",
    value: function getNode(index) {
      return this._get('nodes', index);
    }
  }, {
    key: "getSkin",
    value: function getSkin(index) {
      return this._get('skins', index);
    }
  }, {
    key: "getMesh",
    value: function getMesh(index) {
      return this._get('meshes', index);
    }
  }, {
    key: "getMaterial",
    value: function getMaterial(index) {
      return this._get('materials', index);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(index) {
      return this._get('accessors', index);
    }
  }, {
    key: "getCamera",
    value: function getCamera(index) {
      return null;
    }
  }, {
    key: "getTexture",
    value: function getTexture(index) {
      return this._get('textures', index);
    }
  }, {
    key: "getSampler",
    value: function getSampler(index) {
      return this._get('samplers', index);
    }
  }, {
    key: "getImage",
    value: function getImage(index) {
      return this._get('images', index);
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(index) {
      return this._get('bufferViews', index);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(index) {
      return this._get('buffers', index);
    }
  }, {
    key: "_get",
    value: function _get(array, index) {
      if ((0, _typeof2["default"])(index) === 'object') {
        return index;
      }

      var object = this.json[array] && this.json[array][index];

      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }

      return object;
    }
  }, {
    key: "_resolveScene",
    value: function _resolveScene(scene, index) {
      var _this2 = this;

      scene = _objectSpread({}, scene);
      scene.id = scene.id || "scene-".concat(index);
      scene.nodes = (scene.nodes || []).map(function (node) {
        return _this2.getNode(node);
      });
      return scene;
    }
  }, {
    key: "_resolveNode",
    value: function _resolveNode(node, index) {
      var _this3 = this;

      node = _objectSpread({}, node);
      node.id = node.id || "node-".concat(index);

      if (node.children) {
        node.children = node.children.map(function (child) {
          return _this3.getNode(child);
        });
      }

      if (node.mesh !== undefined) {
        node.mesh = this.getMesh(node.mesh);
      }

      if (node.camera !== undefined) {
        node.camera = this.getCamera(node.camera);
      }

      if (node.skin !== undefined) {
        node.skin = this.getSkin(node.skin);
      }

      return node;
    }
  }, {
    key: "_resolveSkin",
    value: function _resolveSkin(skin, index) {
      skin = _objectSpread({}, skin);
      skin.id = skin.id || "skin-".concat(index);
      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
      return skin;
    }
  }, {
    key: "_resolveMesh",
    value: function _resolveMesh(mesh, index) {
      var _this4 = this;

      mesh = _objectSpread({}, mesh);
      mesh.id = mesh.id || "mesh-".concat(index);

      if (mesh.primitives) {
        mesh.primitives = mesh.primitives.map(function (primitive) {
          primitive = _objectSpread({}, primitive);
          var attributes = primitive.attributes;
          primitive.attributes = {};

          for (var attribute in attributes) {
            primitive.attributes[attribute] = _this4.getAccessor(attributes[attribute]);
          }

          if (primitive.indices !== undefined) {
            primitive.indices = _this4.getAccessor(primitive.indices);
          }

          if (primitive.material !== undefined) {
            primitive.material = _this4.getMaterial(primitive.material);
          }

          return primitive;
        });
      }

      return mesh;
    }
  }, {
    key: "_resolveMaterial",
    value: function _resolveMaterial(material, index) {
      material = _objectSpread({}, material);
      material.id = material.id || "material-".concat(index);

      if (material.normalTexture) {
        material.normalTexture = _objectSpread({}, material.normalTexture);
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }

      if (material.occlusionTexture) {
        material.occlustionTexture = _objectSpread({}, material.occlustionTexture);
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }

      if (material.emissiveTexture) {
        material.emmisiveTexture = _objectSpread({}, material.emmisiveTexture);
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }

      if (material.pbrMetallicRoughness) {
        material.pbrMetallicRoughness = _objectSpread({}, material.pbrMetallicRoughness);
        var mr = material.pbrMetallicRoughness;

        if (mr.baseColorTexture) {
          mr.baseColorTexture = _objectSpread({}, mr.baseColorTexture);
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }

        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture = _objectSpread({}, mr.metallicRoughnessTexture);
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }

      return material;
    }
  }, {
    key: "_resolveAccessor",
    value: function _resolveAccessor(accessor, index) {
      accessor = _objectSpread({}, accessor);
      accessor.id = accessor.id || "accessor-".concat(index);

      if (accessor.bufferView !== undefined) {
        accessor.bufferView = this.getBufferView(accessor.bufferView);
      }

      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
      accessor.components = getSizeFromAccessorType(accessor.type);
      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
      return accessor;
    }
  }, {
    key: "_resolveTexture",
    value: function _resolveTexture(texture, index) {
      texture = _objectSpread({}, texture);
      texture.id = texture.id || "texture-".concat(index);
      texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
      texture.source = this.getImage(texture.source);
      return texture;
    }
  }, {
    key: "_resolveSampler",
    value: function _resolveSampler(sampler, index) {
      sampler = _objectSpread({}, sampler);
      sampler.id = sampler.id || "sampler-".concat(index);
      sampler.parameters = {};

      for (var key in sampler) {
        var glEnum = this._enumSamplerParameter(key);

        if (glEnum !== undefined) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }

      return sampler;
    }
  }, {
    key: "_enumSamplerParameter",
    value: function _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
  }, {
    key: "_resolveImage",
    value: function _resolveImage(image, index, options) {
      image = _objectSpread({}, image);
      image.id = image.id || "image-".concat(index);

      if (image.bufferView !== undefined) {
        image.bufferView = this.getBufferView(image.bufferView);
      }

      if ('uri' in image) {
        var baseUri = options.uri || this.gltf.baseUri;

        if (baseUri) {
          image.baseUri = baseUri;
          image.fullUri = (0, _gltfUtils.getFullUri)(image.uri, baseUri);
        }
      }

      function getImageAsync() {
        if (image.uri) {
          return new Promise(function (resolve) {
            var img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = function () {
              return resolve(img);
            };

            img.src = image.fullUri || image.uri;
          });
        }

        return null;
      }

      image.getImageAsync = getImageAsync;
      return image;
    }
  }, {
    key: "_resolveBufferView",
    value: function _resolveBufferView(bufferView, index) {
      bufferView = _objectSpread({}, bufferView);
      bufferView.id = bufferView.id || "bufferView-".concat(index);
      var bufferIndex = bufferView.buffer;
      bufferView.buffer = this.getBuffer(bufferIndex);
      var arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
      var byteOffset = this.buffers[bufferIndex].byteOffset || 0;

      if ('byteOffset' in bufferView) {
        byteOffset += bufferView.byteOffset;
      }

      bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
      return bufferView;
    }
  }, {
    key: "_resolveCamera",
    value: function _resolveCamera(camera, index) {
      camera.id = camera.id || "camera-".concat(index);

      if (camera.perspective) {}

      if (camera.orthographic) {}

      return camera;
    }
  }]);
  return GLTFPostProcessor;
}();

function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}

},{"./gltf-utils/gltf-utils":201,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'gltf/glb assertion failed.');
  }
}

},{}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HTMLImageLoader = exports.ImageBitmapLoader = exports["default"] = void 0;

var _parseImage = require("./lib/parse-image");

var EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];
var _default = {
  name: 'Images',
  extensions: EXTENSIONS,
  parse: _parseImage.canParseImage && _parseImage.parseImage,
  loadAndParse: !_parseImage.canParseImage && _parseImage.loadImage
};
exports["default"] = _default;
var ImageBitmapLoader = {
  extensions: EXTENSIONS,
  parse: _parseImage.parseToImageBitmap
};
exports.ImageBitmapLoader = ImageBitmapLoader;
var HTMLImageLoader = {
  extensions: EXTENSIONS,
  loadAndParse: _parseImage.loadToHTMLImage
};
exports.HTMLImageLoader = HTMLImageLoader;

},{"./lib/parse-image":213}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _encodeImage = require("./lib/encode-image");

var _default = {
  name: 'Images',
  extensions: ['jpeg'],
  encode: _encodeImage.encodeImage,
  DEFAULT_OPTIONS: {
    type: 'png'
  }
};
exports["default"] = _default;

},{"./lib/encode-image":209}],208:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ImageLoader", {
  enumerable: true,
  get: function get() {
    return _imageLoader["default"];
  }
});
Object.defineProperty(exports, "HTMLImageLoader", {
  enumerable: true,
  get: function get() {
    return _imageLoader.HTMLImageLoader;
  }
});
Object.defineProperty(exports, "ImageBitmapLoader", {
  enumerable: true,
  get: function get() {
    return _imageLoader.ImageBitmapLoader;
  }
});
Object.defineProperty(exports, "ImageWriter", {
  enumerable: true,
  get: function get() {
    return _imageWriter["default"];
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function get() {
    return _parseImage.loadImage;
  }
});
Object.defineProperty(exports, "isImage", {
  enumerable: true,
  get: function get() {
    return _getImageMetadata.isImage;
  }
});
Object.defineProperty(exports, "getImageMetadata", {
  enumerable: true,
  get: function get() {
    return _getImageMetadata.getImageMetadata;
  }
});
Object.defineProperty(exports, "getImageMIMEType", {
  enumerable: true,
  get: function get() {
    return _getImageMetadata.getImageMIMEType;
  }
});
Object.defineProperty(exports, "getImageSize", {
  enumerable: true,
  get: function get() {
    return _getImageMetadata.getImageSize;
  }
});
Object.defineProperty(exports, "decodeImage", {
  enumerable: true,
  get: function get() {
    return _imageUtilsBrowser.decodeImage;
  }
});

var _imageLoader = _interopRequireWildcard(require("./image-loader"));

var _imageWriter = _interopRequireDefault(require("./image-writer"));

var _parseImage = require("./lib/parse-image");

var _getImageMetadata = require("./lib/get-image-metadata");

var _imageUtilsBrowser = require("./lib/image-utils-browser");

},{"./image-loader":206,"./image-writer":207,"./lib/get-image-metadata":210,"./lib/image-utils-browser":212,"./lib/parse-image":213,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26}],209:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeImage = encodeImage;

var _assert = _interopRequireDefault(require("../utils/assert"));

var _globals = require("../utils/globals");

function encodeImage(image, type) {
  if (_globals.global._encodeImageNode) {
    return _globals.global._encodeImageNode(image, type);
  }

  if (image instanceof HTMLCanvasElement) {
    var _canvas = image;
    return _canvas.toDataURL(type);
  }

  (0, _assert["default"])(image instanceof Image, 'getImageData accepts image or canvas');
  var canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext('2d').drawImage(image, 0, 0);
  var data = canvas.toDataURL(type || 'png').replace(/^data:image\/(png|jpg);base64,/, '');
  return Promise.resolve(data);
}

},{"../utils/assert":214,"../utils/globals":215,"@babel/runtime/helpers/interopRequireDefault":25}],210:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImage = isImage;
exports.getImageMIMEType = getImageMIMEType;
exports.getImageSize = getImageSize;
exports.getImageMetadata = getImageMetadata;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _imageParsers = require("./image-parsers");

var ERR_INVALID_MIME_TYPE = "Invalid MIME type. Supported MIME types are: ".concat(Array.from(_imageParsers.mimeTypeMap.keys()).join(', '));

function isImage(arrayBuffer, mimeType) {
  if (mimeType) {
    var _getImageTypeHandlers = getImageTypeHandlers(mimeType),
        test = _getImageTypeHandlers.test;

    var dataView = toDataView(arrayBuffer);
    return test(dataView);
  }

  return Boolean(getImageMIMEType(arrayBuffer));
}

function getImageMIMEType(arrayBuffer) {
  var dataView = toDataView(arrayBuffer);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _imageParsers.mimeTypeMap.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
          mimeType = _step$value[0],
          test = _step$value[1].test;

      if (test(dataView)) {
        return mimeType;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

function getImageSize(arrayBuffer) {
  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  mimeType = mimeType || getImageMIMEType(arrayBuffer);

  var _getImageTypeHandlers2 = getImageTypeHandlers(mimeType),
      getSize = _getImageTypeHandlers2.getSize;

  var dataView = toDataView(arrayBuffer);
  var size = getSize(dataView);

  if (!size) {
    throw new Error("invalid image data for type: ".concat(mimeType));
  }

  return size;
}

function getImageMetadata(arrayBuffer) {
  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  mimeType = mimeType || getImageMIMEType(arrayBuffer);
  var metadata = getImageSize(arrayBuffer, mimeType);
  metadata.mimeType = mimeType;
  return metadata;
}

function getImageTypeHandlers(mimeType) {
  var handlers = _imageParsers.mimeTypeMap.get(mimeType);

  if (!handlers) {
    throw new Error(ERR_INVALID_MIME_TYPE);
  }

  return handlers;
}

function toDataView(data) {
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return new DataView(data.buffer || data);
  }

  throw new Error('toDataView');
}

},{"./image-parsers":211,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],211:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mimeTypeMap = void 0;
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
var mimeTypeMap = new Map([['image/png', {
  test: isPng,
  getSize: getPngSize
}], ['image/jpeg', {
  test: isJpeg,
  getSize: getJpegSize
}], ['image/gif', {
  test: isGif,
  getSize: getGifSize
}], ['image/bmp', {
  test: isBmp,
  getSize: getBmpSize
}]]);
exports.mimeTypeMap = mimeTypeMap;

function isPng(dataView) {
  return dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
}

function getPngSize(dataView) {
  return {
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

function isGif(dataView) {
  return dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
}

function getGifSize(dataView) {
  return {
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

function isBmp(dataView) {
  return dataView.byteLength >= 2 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d;
}

function getBmpSize(dataView) {
  return {
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

function isJpeg(dataView) {
  return dataView.byteLength >= 2 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8;
}

function getJpegSize(dataView) {
  if (dataView.byteLength < 2 || dataView.getUint16(0, BIG_ENDIAN) !== 0xffd8) {
    return null;
  }

  var _getJpegMarkers = getJpegMarkers(),
      tableMarkers = _getJpegMarkers.tableMarkers,
      sofMarkers = _getJpegMarkers.sofMarkers;

  var i = 2;

  while (i < dataView.byteLength) {
    var marker = dataView.getUint16(i, BIG_ENDIAN);

    if (sofMarkers.has(marker)) {
      return {
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }

    if (!tableMarkers.has(marker)) {
      return null;
    }

    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  var tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);

  for (var i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  var sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers: tableMarkers,
    sofMarkers: sofMarkers
  };
}

},{}],212:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeImage = decodeImage;
exports.getImagePixelData = getImagePixelData;

function decodeImage(arrayBufferOrView, _ref) {
  var _ref$mimeType = _ref.mimeType,
      mimeType = _ref$mimeType === void 0 ? 'image/jpeg' : _ref$mimeType;
  var blob = new Blob([arrayBufferOrView], {
    type: mimeType
  });
  var urlCreator = window.URL || window.webkitURL;
  var imageUrl = urlCreator.createObjectURL(blob);
  return new Promise(function (resolve, reject) {
    var image = new Image();

    image.onload = function () {
      return resolve(image);
    };

    image.onerror = reject;
    image.src = imageUrl;
    return image;
  });
}

function getImagePixelData(image) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  width = width || image.width;
  height = height || image.height;
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext('2d');
  ctx.drawImage(image, 0, 0, width, height);
  return ctx.getImageData(0, 0, width, height);
}

},{}],213:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseImage = parseImage;
exports.loadImage = loadImage;
exports.parseToImageBitmap = parseToImageBitmap;
exports.loadToHTMLImage = loadToHTMLImage;
exports.canParseImage = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _globals = require("../utils/globals");

var _getImageMetadata2 = require("./get-image-metadata");

var canParseImage = _globals.global._parseImageNode || typeof ImageBitmap !== 'undefined';
exports.canParseImage = canParseImage;

function parseImage(arrayBuffer, options) {
  if (_globals.global._parseImageNode) {
    var _getImageMetadata = (0, _getImageMetadata2.getImageMetadata)(arrayBuffer),
        mimeType = _getImageMetadata.mimeType;

    return _globals.global._parseImageNode(arrayBuffer, mimeType, options);
  }

  return parseToImageBitmap(arrayBuffer, options);
}

function loadImage(_x) {
  return _loadImage.apply(this, arguments);
}

function _loadImage() {
  _loadImage = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(url) {
    var options,
        response,
        arrayBuffer,
        _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};

            if (!(typeof Image === 'undefined')) {
              _context.next = 9;
              break;
            }

            _context.next = 4;
            return fetch(url, options);

          case 4:
            response = _context.sent;
            _context.next = 7;
            return response.arrayBuffer();

          case 7:
            arrayBuffer = _context.sent;
            return _context.abrupt("return", parseImage(arrayBuffer, options));

          case 9:
            _context.next = 11;
            return loadToHTMLImage(url, options);

          case 11:
            return _context.abrupt("return", _context.sent);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadImage.apply(this, arguments);
}

function parseToImageBitmap(arrayBuffer, options) {
  if (typeof createImageBitmap === 'undefined') {
    throw new Error('parseImage');
  }

  var blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob, {
    imageOrientation: options.imageOrientation || 'none',
    premultiplyAlpha: options.premultiplyAlpha || 'default'
  });
}

function loadToHTMLImage(_x2, _x3) {
  return _loadToHTMLImage.apply(this, arguments);
}

function _loadToHTMLImage() {
  _loadToHTMLImage = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(url, options) {
    var src, response, xml;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!/\.svg((\?|#).*)?$/.test(url)) {
              _context2.next = 10;
              break;
            }

            _context2.next = 3;
            return fetch(url, options);

          case 3:
            response = _context2.sent;
            _context2.next = 6;
            return response.text();

          case 6:
            xml = _context2.sent;
            src = "data:image/svg+xml;base64,".concat(btoa(xml));
            _context2.next = 13;
            break;

          case 10:
            _context2.next = 12;
            return url;

          case 12:
            src = _context2.sent;

          case 13:
            _context2.next = 15;
            return new Promise(function (resolve, reject) {
              try {
                var image = new Image();

                image.onload = function () {
                  return resolve(image);
                };

                image.onerror = function (err) {
                  return reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
                };

                image.crossOrigin = options && options.crossOrigin || 'anonymous';
                image.src = src;
              } catch (error) {
                reject(error);
              }
            });

          case 15:
            return _context2.abrupt("return", _context2.sent);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadToHTMLImage.apply(this, arguments);
}

},{"../utils/globals":215,"./get-image-metadata":210,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/regenerator":43}],214:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '@loaders.gl/images assertion failed.');
  }
}

},{}],215:[function(require,module,exports){
(function (process,global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.global = exports.isBrowser = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global
};
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],216:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMeshSize = getMeshSize;

function getMeshSize(attributes) {
  var size = 0;

  for (var attributeName in attributes) {
    var attribute = attributes[attributeName];

    if (ArrayBuffer.isView(attribute)) {
      size += attribute.length * attribute.BYTES_PER_ELEMENT;
    }
  }

  return size;
}

},{}],217:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createWorker", {
  enumerable: true,
  get: function get() {
    return _createWorker["default"];
  }
});
Object.defineProperty(exports, "padTo4Bytes", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.padTo4Bytes;
  }
});
Object.defineProperty(exports, "copyToArray", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyToArray;
  }
});
Object.defineProperty(exports, "copyArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyArrayBuffer;
  }
});
Object.defineProperty(exports, "copyPaddedArrayBufferToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedArrayBufferToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedStringToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedStringToDataView;
  }
});
Object.defineProperty(exports, "padStringToByteAlignment", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.padStringToByteAlignment;
  }
});
Object.defineProperty(exports, "copyStringToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyStringToDataView;
  }
});
Object.defineProperty(exports, "copyBinaryToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyBinaryToDataView;
  }
});
Object.defineProperty(exports, "_getMeshSize", {
  enumerable: true,
  get: function get() {
    return _meshUtils.getMeshSize;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert["default"];
  }
});

var _createWorker = _interopRequireDefault(require("./worker-utils/create-worker"));

var _memoryCopyUtils = require("./lib/memory-copy-utils");

var _binaryCopyUtils = require("./lib/binary-copy-utils");

var _encodeUtils = require("./lib/encode-utils");

var _meshUtils = require("./categories/mesh/mesh-utils");

var _assert = _interopRequireDefault(require("./lib/utils/assert"));

},{"./categories/mesh/mesh-utils":216,"./lib/binary-copy-utils":218,"./lib/encode-utils":219,"./lib/memory-copy-utils":220,"./lib/utils/assert":221,"./worker-utils/create-worker":222,"@babel/runtime/helpers/interopRequireDefault":25}],218:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyPaddedArrayBufferToDataView = copyPaddedArrayBufferToDataView;
exports.copyPaddedStringToDataView = copyPaddedStringToDataView;

var _memoryCopyUtils = require("./memory-copy-utils");

function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  var paddedLength = (0, _memoryCopyUtils.padTo4Bytes)(sourceBuffer.byteLength);
  var padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    var targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    var sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    for (var i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }

  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  var textEncoder = new TextEncoder();
  var stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}

},{"./memory-copy-utils":220}],219:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padStringToByteAlignment = padStringToByteAlignment;
exports.copyStringToDataView = copyStringToDataView;
exports.copyBinaryToDataView = copyBinaryToDataView;

function padStringToByteAlignment(string, byteAlignment) {
  var length = string.length;
  var paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  var padding = paddedLength - length;
  var whitespace = '';

  for (var i = 0; i < padding; ++i) {
    whitespace += ' ';
  }

  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }

  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
      byteOffset++;
    }
  }

  return byteOffset + byteLength;
}

},{}],220:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padTo4Bytes = padTo4Bytes;
exports.copyArrayBuffer = copyArrayBuffer;
exports.copyToArray = copyToArray;

function padTo4Bytes(byteLength) {
  return byteLength + 3 & ~3;
}

function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  var byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  var targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  var sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

function copyToArray(source, target, targetOffset) {
  var sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    var srcByteOffset = source.byteOffset;
    var srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  target.set(sourceArray, targetOffset);
  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}

},{}],221:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"dup":177}],222:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createWorker;

var _getTransferList = _interopRequireDefault(require("./get-transfer-list"));

function createWorker(loader) {
  if (typeof self === 'undefined') {
    return;
  }

  self.onmessage = function (evt) {
    var _evt$data = evt.data,
        arraybuffer = _evt$data.arraybuffer,
        opts = _evt$data.opts;

    try {
      var data;
      var parser;

      if (loader.parseSync) {
        data = arraybuffer;
        parser = loader.parseSync;
      } else if (loader.parseTextSync) {
        var textDecoder = new TextDecoder();
        data = textDecoder.decode(arraybuffer);
        parser = loader.parseTextSync;
      } else {
        throw new Error("Could not load data with ".concat(loader.name, " loader"));
      }

      var result = parser(data, opts);
      var transferList = (0, _getTransferList["default"])(result);
      self.postMessage({
        type: 'done',
        result: result
      }, transferList);
    } catch (error) {
      self.postMessage({
        type: 'error',
        message: error.message
      });
    }
  };
}

},{"./get-transfer-list":223,"@babel/runtime/helpers/interopRequireDefault":25}],223:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getTransferList;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function getTransferList(object) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : undefined;
  var transfersSet = transfers || new Set();

  if (!object) {} else if (object instanceof ArrayBuffer) {
    transfersSet.add(object);
  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {
    transfersSet.add(object.buffer);
  } else if (recursive && (0, _typeof2["default"])(object) === 'object') {
    for (var key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  return transfers === undefined ? Array.from(transfersSet) : null;
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],224:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "OBJLoader", {
  enumerable: true,
  get: function get() {
    return _objLoader["default"];
  }
});
Object.defineProperty(exports, "OBJWorkerLoader", {
  enumerable: true,
  get: function get() {
    return _objWorkerLoader["default"];
  }
});

var _objLoader = _interopRequireDefault(require("./obj-loader"));

var _objWorkerLoader = _interopRequireDefault(require("./obj-worker-loader"));

},{"./obj-loader":226,"./obj-worker-loader":227,"@babel/runtime/helpers/interopRequireDefault":25}],225:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = loadOBJ;

var _parseObj = _interopRequireDefault(require("./parse-obj"));

function loadOBJ(text) {
  var _parseOBJ = (0, _parseObj["default"])(text),
      meshes = _parseOBJ.meshes;

  var vertexCount = meshes.reduce(function (s, mesh) {
    return s + mesh.header.vertexCount;
  }, 0);
  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: vertexCount
    },
    mode: 4,
    attributes: mergeAttributes(meshes, vertexCount)
  };
}

function mergeAttributes(meshes, vertexCount) {
  var positions = new Float32Array(vertexCount * 3);
  var normals;
  var colors;
  var uvs;
  var i = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = meshes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var mesh = _step.value;
      var _mesh$attributes = mesh.attributes,
          POSITION = _mesh$attributes.POSITION,
          NORMAL = _mesh$attributes.NORMAL,
          COLOR_0 = _mesh$attributes.COLOR_0,
          TEXCOORD_0 = _mesh$attributes.TEXCOORD_0;
      positions.set(POSITION.value, i * 3);

      if (NORMAL) {
        normals = normals || new Float32Array(vertexCount * 3);
        normals.set(NORMAL.value, i * 3);
      }

      if (COLOR_0) {
        colors = colors || new Float32Array(vertexCount * 3);
        colors.set(COLOR_0.value, i * 3);
      }

      if (TEXCOORD_0) {
        uvs = uvs || new Float32Array(vertexCount * 2);
        uvs.set(TEXCOORD_0.value, i * 2);
      }

      i += POSITION.value.length / 3;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var attributes = {};
  attributes.POSITION = {
    value: positions,
    size: 3
  };

  if (normals) {
    attributes.NORMAL = {
      value: normals,
      size: 3
    };
  }

  if (colors) {
    attributes.COLOR_0 = {
      value: colors,
      size: 3
    };
  }

  if (uvs) {
    attributes.TEXCOORD_0 = {
      value: uvs,
      size: 2
    };
  }

  return attributes;
}

},{"./parse-obj":228,"@babel/runtime/helpers/interopRequireDefault":25}],226:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _loadObj = _interopRequireDefault(require("./load-obj"));

function testOBJFile(text) {
  return text[0] === 'v';
}

var _default = {
  name: 'OBJ',
  extensions: ['obj'],
  testText: testOBJFile,
  parseTextSync: _loadObj["default"]
};
exports["default"] = _default;

},{"./load-obj":225,"@babel/runtime/helpers/interopRequireDefault":25}],227:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var worker = "!function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=3)}([function(e,t){e.exports=function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}},function(e,t){function r(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}e.exports=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e}},function(e,t){function r(e){return(r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function n(t){return\"function\"==typeof Symbol&&\"symbol\"===r(Symbol.iterator)?e.exports=n=function(e){return r(e)}:e.exports=n=function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":r(e)},n(t)}e.exports=n},function(e,t,r){\"use strict\";r.r(t);var n=r(0),i=r.n(n),a=r(1),o=r.n(a),s=/^[og]\\s*(.+)?/,l=/^mtllib /,u=/^usemtl /,h=function(){function e(t){var r=t.index,n=t.name,a=void 0===n?\"\":n,o=t.mtllib,s=t.smooth,l=t.groupStart;i()(this,e),this.index=r,this.name=a,this.mtllib=o,this.smooth=s,this.groupStart=l,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}return o()(e,[{key:\"clone\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.index;return new e({index:t,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0})}}]),e}(),c=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\";i()(this,e),this.name=t,this.geometry={vertices:[],normals:[],colors:[],uvs:[]},this.materials=[],this.smooth=!0}return o()(e,[{key:\"startMaterial\",value:function(e,t){var r=this._finalize(!1);r&&(r.inherited||r.groupCount<=0)&&this.materials.splice(r.index,1);var n=new h({index:this.materials.length,name:e,mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:\"\",smooth:void 0!==r?r.smooth:this.smooth,groupStart:void 0!==r?r.groupEnd:0});return this.materials.push(n),n}},{key:\"currentMaterial\",value:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]}},{key:\"_finalize\",value:function(e){var t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(var r=this.materials.length-1;r>=0;r--)this.materials[r].groupCount<=0&&this.materials.splice(r,1);return e&&0===this.materials.length&&this.materials.push({name:\"\",smooth:this.smooth}),t}}]),e}(),f=function(){function e(){i()(this,e),this.objects=[],this.object=null,this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[],this.startObject(\"\",!1)}return o()(e,[{key:\"startObject\",value:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.object&&!this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=t);var r=this.object&&\"function\"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&\"function\"==typeof this.object._finalize&&this.object._finalize(!0),this.object=new c(e),this.object.fromDeclaration=t,r&&r.name&&\"function\"==typeof r.clone){var n=r.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)}},{key:\"finalize\",value:function(){this.object&&\"function\"==typeof this.object._finalize&&this.object._finalize(!0)}},{key:\"parseVertexIndex\",value:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)}},{key:\"parseNormalIndex\",value:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)}},{key:\"parseUVIndex\",value:function(e,t){var r=parseInt(e,10);return 2*(r>=0?r-1:r+t/2)}},{key:\"addVertex\",value:function(e,t,r){var n=this.vertices,i=this.object.geometry.vertices;i.push(n[e+0],n[e+1],n[e+2]),i.push(n[t+0],n[t+1],n[t+2]),i.push(n[r+0],n[r+1],n[r+2])}},{key:\"addVertexPoint\",value:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])}},{key:\"addVertexLine\",value:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])}},{key:\"addNormal\",value:function(e,t,r){var n=this.normals,i=this.object.geometry.normals;i.push(n[e+0],n[e+1],n[e+2]),i.push(n[t+0],n[t+1],n[t+2]),i.push(n[r+0],n[r+1],n[r+2])}},{key:\"addColor\",value:function(e,t,r){var n=this.colors,i=this.object.geometry.colors;i.push(n[e+0],n[e+1],n[e+2]),i.push(n[t+0],n[t+1],n[t+2]),i.push(n[r+0],n[r+1],n[r+2])}},{key:\"addUV\",value:function(e,t,r){var n=this.uvs,i=this.object.geometry.uvs;i.push(n[e+0],n[e+1]),i.push(n[t+0],n[t+1]),i.push(n[r+0],n[r+1])}},{key:\"addUVLine\",value:function(e){var t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])}},{key:\"addFace\",value:function(e,t,r,n,i,a,o,s,l){var u=this.vertices.length,h=this.parseVertexIndex(e,u),c=this.parseVertexIndex(t,u),f=this.parseVertexIndex(r,u);if(this.addVertex(h,c,f),void 0!==n&&\"\"!==n){var v=this.uvs.length;h=this.parseUVIndex(n,v),c=this.parseUVIndex(i,v),f=this.parseUVIndex(a,v),this.addUV(h,c,f)}if(void 0!==o&&\"\"!==o){var d=this.normals.length;h=this.parseNormalIndex(o,d),c=o===s?h:this.parseNormalIndex(s,d),f=o===l?h:this.parseNormalIndex(l,d),this.addNormal(h,c,f)}this.colors.length>0&&this.addColor(h,c,f)}},{key:\"addPointGeometry\",value:function(e){this.object.geometry.type=\"Points\";var t=this.vertices.length,r=!0,n=!1,i=void 0;try{for(var a,o=e[Symbol.iterator]();!(r=(a=o.next()).done);r=!0){var s=a.value;this.addVertexPoint(this.parseVertexIndex(s,t))}}catch(e){n=!0,i=e}finally{try{r||null==o.return||o.return()}finally{if(n)throw i}}}},{key:\"addLineGeometry\",value:function(e,t){this.object.geometry.type=\"Line\";var r=this.vertices.length,n=this.uvs.length,i=!0,a=!1,o=void 0;try{for(var s,l=e[Symbol.iterator]();!(i=(s=l.next()).done);i=!0){var u=s.value;this.addVertexLine(this.parseVertexIndex(u,r))}}catch(e){a=!0,o=e}finally{try{i||null==l.return||l.return()}finally{if(a)throw o}}var h=!0,c=!1,f=void 0;try{for(var v,d=t[Symbol.iterator]();!(h=(v=d.next()).done);h=!0){var p=v.value;this.addUVLine(this.parseUVIndex(p,n))}}catch(e){c=!0,f=e}finally{try{h||null==d.return||d.return()}finally{if(c)throw f}}}}]),e}(),v=function(e){var t=new f;-1!==e.indexOf(\"\\r\\n\")&&(e=e.replace(/\\r\\n/g,\"\\n\")),-1!==e.indexOf(\"\\\\\\n\")&&(e=e.replace(/\\\\\\n/g,\"\"));for(var r=e.split(\"\\n\"),n=\"\",i=\"\",a=[],o=\"function\"==typeof\"\".trimLeft,h=0,c=r.length;h<c;h++)if(n=r[h],0!==(n=o?n.trimLeft():n.trim()).length&&\"#\"!==(i=n.charAt(0)))if(\"v\"===i){var v=n.split(/\\s+/);switch(v[0]){case\"v\":t.vertices.push(parseFloat(v[1]),parseFloat(v[2]),parseFloat(v[3])),8===v.length&&t.colors.push(parseFloat(v[4]),parseFloat(v[5]),parseFloat(v[6]));break;case\"vn\":t.normals.push(parseFloat(v[1]),parseFloat(v[2]),parseFloat(v[3]));break;case\"vt\":t.uvs.push(parseFloat(v[1]),parseFloat(v[2]))}}else if(\"f\"===i){for(var d=n.substr(1).trim().split(/\\s+/),p=[],m=0,y=d.length;m<y;m++){var b=d[m];if(b.length>0){var g=b.split(\"/\");p.push(g)}}for(var x=p[0],j=1,O=p.length-1;j<O;j++){var S=p[j],w=p[j+1];t.addFace(x[0],S[0],w[0],x[1],S[1],w[1],x[2],S[2],w[2])}}else if(\"l\"===i){var k=n.substring(1).trim().split(\" \"),I=void 0,F=[];if(-1===n.indexOf(\"/\"))I=k;else{I=[];for(var V=0,L=k.length;V<L;V++){var C=k[V].split(\"/\");\"\"!==C[0]&&I.push(C[0]),\"\"!==C[1]&&F.push(C[1])}}t.addLineGeometry(I,F)}else if(\"p\"===i){var _=n.substr(1).trim().split(\" \");t.addPointGeometry(_)}else if(null!==(a=s.exec(n))){var A=(\" \"+a[0].substr(1).trim()).substr(1);t.startObject(A)}else if(u.test(n))t.object.startMaterial(n.substring(7).trim(),t.materialLibraries);else if(l.test(n))t.materialLibraries.push(n.substring(7).trim());else{if(\"s\"!==i){if(\"\\0\"===n)continue;throw new Error('Unexpected line: \"'.concat(n,'\"'))}if((a=n.split(\" \")).length>1){var z=a[1].trim().toLowerCase();t.object.smooth=\"0\"!==z&&\"off\"!==z}else t.object.smooth=!0;var M=t.object.currentMaterial();M&&(M.smooth=t.object.smooth)}t.finalize();var P=[],T=[],N=!0,E=!1,U=void 0;try{for(var R,D=t.objects[Symbol.iterator]();!(N=(R=D.next()).done);N=!0){var G=R.value,B=G.geometry;if(0!==B.vertices.length){var X={header:{vertexCount:B.vertices.length/3},attributes:{}};switch(B.type){case\"Points\":X.mode=0;break;case\"Line\":X.mode=1;break;default:X.mode=4}X.attributes.POSITION={value:new Float32Array(B.vertices),size:3},B.normals.length>0&&(X.attributes.NORMAL={value:new Float32Array(B.normals),size:3}),B.colors.length>0&&(X.attributes.COLOR_0={value:new Float32Array(B.colors),size:3}),B.uvs.length>0&&(X.attributes.TEXCOORD_0={value:new Float32Array(B.uvs),size:2}),X.materials=[];var J=!0,q=!1,H=void 0;try{for(var K,Q=G.materials[Symbol.iterator]();!(J=(K=Q.next()).done);J=!0){var W=K.value,Y={name:W.name,flatShading:!W.smooth};X.materials.push(Y),T.push(Y)}}catch(e){q=!0,H=e}finally{try{J||null==Q.return||Q.return()}finally{if(q)throw H}}X.name=G.name,P.push(X)}}}catch(e){E=!0,U=e}finally{try{N||null==D.return||D.return()}finally{if(E)throw U}}return{meshes:P,materials:T}};function d(e,t){var r,n,i,a=new Float32Array(3*t),o=0,s=!0,l=!1,u=void 0;try{for(var h,c=e[Symbol.iterator]();!(s=(h=c.next()).done);s=!0){var f=h.value.attributes,v=f.POSITION,d=f.NORMAL,p=f.COLOR_0,m=f.TEXCOORD_0;a.set(v.value,3*o),d&&(r=r||new Float32Array(3*t)).set(d.value,3*o),p&&(n=n||new Float32Array(3*t)).set(p.value,3*o),m&&(i=i||new Float32Array(2*t)).set(m.value,2*o),o+=v.value.length/3}}catch(e){l=!0,u=e}finally{try{s||null==c.return||c.return()}finally{if(l)throw u}}var y={};return y.POSITION={value:a,size:3},r&&(y.NORMAL={value:r,size:3}),n&&(y.COLOR_0={value:n,size:3}),i&&(y.TEXCOORD_0={value:i,size:2}),y}var p,m={name:\"OBJ\",extensions:[\"obj\"],testText:function(e){return\"v\"===e[0]},parseTextSync:function(e){var t=v(e).meshes,r=t.reduce(function(e,t){return e+t.header.vertexCount},0);return{loaderData:{header:{}},header:{vertexCount:r},mode:4,attributes:d(t,r)}}},y=r(2),b=r.n(y);p=m,\"undefined\"!=typeof self&&(self.onmessage=function(e){var t=e.data,r=t.arraybuffer,n=t.opts;try{var i,a;if(p.parseSync)i=r,a=p.parseSync;else{if(!p.parseTextSync)throw new Error(\"Could not load data with \".concat(p.name,\" loader\"));i=(new TextDecoder).decode(r),a=p.parseTextSync}var o=a(i,n),s=function e(t){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,i=n||new Set;if(t)if(t instanceof ArrayBuffer)i.add(t);else if(t.buffer&&t.buffer instanceof ArrayBuffer)i.add(t.buffer);else if(r&&\"object\"===b()(t))for(var a in t)e(t[a],r,i);return void 0===n?Array.from(i):null}(o);self.postMessage({type:\"done\",result:o},s)}catch(e){self.postMessage({type:\"error\",message:e.message})}})}]);";
var _default = {
  name: 'OBJ',
  extensions: ['obj'],
  worker: worker
};
exports["default"] = _default;

},{}],228:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var OBJECT_RE = /^[og]\s*(.+)?/;
var MATERIAL_RE = /^mtllib /;
var MATERIAL_USE_RE = /^usemtl /;

var MeshMaterial = function () {
  function MeshMaterial(_ref) {
    var index = _ref.index,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? '' : _ref$name,
        mtllib = _ref.mtllib,
        smooth = _ref.smooth,
        groupStart = _ref.groupStart;
    (0, _classCallCheck2["default"])(this, MeshMaterial);
    this.index = index;
    this.name = name;
    this.mtllib = mtllib;
    this.smooth = smooth;
    this.groupStart = groupStart;
    this.groupEnd = -1;
    this.groupCount = -1;
    this.inherited = false;
  }

  (0, _createClass2["default"])(MeshMaterial, [{
    key: "clone",
    value: function clone() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.index;
      return new MeshMaterial({
        index: index,
        name: this.name,
        mtllib: this.mtllib,
        smooth: this.smooth,
        groupStart: 0
      });
    }
  }]);
  return MeshMaterial;
}();

var MeshObject = function () {
  function MeshObject() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    (0, _classCallCheck2["default"])(this, MeshObject);
    this.name = name;
    this.geometry = {
      vertices: [],
      normals: [],
      colors: [],
      uvs: []
    };
    this.materials = [];
    this.smooth = true;
  }

  (0, _createClass2["default"])(MeshObject, [{
    key: "startMaterial",
    value: function startMaterial(name, libraries) {
      var previous = this._finalize(false);

      if (previous && (previous.inherited || previous.groupCount <= 0)) {
        this.materials.splice(previous.index, 1);
      }

      var material = new MeshMaterial({
        index: this.materials.length,
        name: name,
        mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
        smooth: previous !== undefined ? previous.smooth : this.smooth,
        groupStart: previous !== undefined ? previous.groupEnd : 0
      });
      this.materials.push(material);
      return material;
    }
  }, {
    key: "currentMaterial",
    value: function currentMaterial() {
      if (this.materials.length > 0) {
        return this.materials[this.materials.length - 1];
      }

      return undefined;
    }
  }, {
    key: "_finalize",
    value: function _finalize(end) {
      var lastMultiMaterial = this.currentMaterial();

      if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
        lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
        lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
        lastMultiMaterial.inherited = false;
      }

      if (end && this.materials.length > 1) {
        for (var mi = this.materials.length - 1; mi >= 0; mi--) {
          if (this.materials[mi].groupCount <= 0) {
            this.materials.splice(mi, 1);
          }
        }
      }

      if (end && this.materials.length === 0) {
        this.materials.push({
          name: '',
          smooth: this.smooth
        });
      }

      return lastMultiMaterial;
    }
  }]);
  return MeshObject;
}();

var ParserState = function () {
  function ParserState() {
    (0, _classCallCheck2["default"])(this, ParserState);
    this.objects = [];
    this.object = null;
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.materialLibraries = [];
    this.startObject('', false);
  }

  (0, _createClass2["default"])(ParserState, [{
    key: "startObject",
    value: function startObject(name) {
      var fromDeclaration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (this.object && !this.object.fromDeclaration) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration;
        return;
      }

      var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;

      if (this.object && typeof this.object._finalize === 'function') {
        this.object._finalize(true);
      }

      this.object = new MeshObject(name);
      this.object.fromDeclaration = fromDeclaration;

      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
        var declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }

      this.objects.push(this.object);
    }
  }, {
    key: "finalize",
    value: function finalize() {
      if (this.object && typeof this.object._finalize === 'function') {
        this.object._finalize(true);
      }
    }
  }, {
    key: "parseVertexIndex",
    value: function parseVertexIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }
  }, {
    key: "parseNormalIndex",
    value: function parseNormalIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }
  }, {
    key: "parseUVIndex",
    value: function parseUVIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    }
  }, {
    key: "addVertex",
    value: function addVertex(a, b, c) {
      var src = this.vertices;
      var dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    }
  }, {
    key: "addVertexPoint",
    value: function addVertexPoint(a) {
      var src = this.vertices;
      var dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    }
  }, {
    key: "addVertexLine",
    value: function addVertexLine(a) {
      var src = this.vertices;
      var dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    }
  }, {
    key: "addNormal",
    value: function addNormal(a, b, c) {
      var src = this.normals;
      var dst = this.object.geometry.normals;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    }
  }, {
    key: "addColor",
    value: function addColor(a, b, c) {
      var src = this.colors;
      var dst = this.object.geometry.colors;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    }
  }, {
    key: "addUV",
    value: function addUV(a, b, c) {
      var src = this.uvs;
      var dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
      dst.push(src[b + 0], src[b + 1]);
      dst.push(src[c + 0], src[c + 1]);
    }
  }, {
    key: "addUVLine",
    value: function addUVLine(a) {
      var src = this.uvs;
      var dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
    }
  }, {
    key: "addFace",
    value: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {
      var vLen = this.vertices.length;
      var ia = this.parseVertexIndex(a, vLen);
      var ib = this.parseVertexIndex(b, vLen);
      var ic = this.parseVertexIndex(c, vLen);
      this.addVertex(ia, ib, ic);

      if (ua !== undefined && ua !== '') {
        var uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
      }

      if (na !== undefined && na !== '') {
        var nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
        ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      }

      if (this.colors.length > 0) {
        this.addColor(ia, ib, ic);
      }
    }
  }, {
    key: "addPointGeometry",
    value: function addPointGeometry(vertices) {
      this.object.geometry.type = 'Points';
      var vLen = this.vertices.length;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var vertex = _step.value;
          this.addVertexPoint(this.parseVertexIndex(vertex, vLen));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "addLineGeometry",
    value: function addLineGeometry(vertices, uvs) {
      this.object.geometry.type = 'Line';
      var vLen = this.vertices.length;
      var uvLen = this.uvs.length;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = vertices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var vertex = _step2.value;
          this.addVertexLine(this.parseVertexIndex(vertex, vLen));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = uvs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var uv = _step3.value;
          this.addUVLine(this.parseUVIndex(uv, uvLen));
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }]);
  return ParserState;
}();

var _default = function _default(text) {
  var state = new ParserState();

  if (text.indexOf('\r\n') !== -1) {
    text = text.replace(/\r\n/g, '\n');
  }

  if (text.indexOf('\\\n') !== -1) {
    text = text.replace(/\\\n/g, '');
  }

  var lines = text.split('\n');
  var line = '';
  var lineFirstChar = '';
  var lineLength = 0;
  var result = [];
  var trimLeft = typeof ''.trimLeft === 'function';

  for (var i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    line = trimLeft ? line.trimLeft() : line.trim();
    lineLength = line.length;
    if (lineLength === 0) continue;
    lineFirstChar = line.charAt(0);
    if (lineFirstChar === '#') continue;

    if (lineFirstChar === 'v') {
      var data = line.split(/\s+/);

      switch (data[0]) {
        case 'v':
          state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));

          if (data.length === 8) {
            state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
          }

          break;

        case 'vn':
          state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
          break;

        case 'vt':
          state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
          break;

        default:
      }
    } else if (lineFirstChar === 'f') {
      var lineData = line.substr(1).trim();
      var vertexData = lineData.split(/\s+/);
      var faceVertices = [];

      for (var j = 0, jl = vertexData.length; j < jl; j++) {
        var vertex = vertexData[j];

        if (vertex.length > 0) {
          var vertexParts = vertex.split('/');
          faceVertices.push(vertexParts);
        }
      }

      var v1 = faceVertices[0];

      for (var _j = 1, _jl = faceVertices.length - 1; _j < _jl; _j++) {
        var v2 = faceVertices[_j];
        var v3 = faceVertices[_j + 1];
        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
      }
    } else if (lineFirstChar === 'l') {
      var lineParts = line.substring(1).trim().split(' ');
      var lineVertices = void 0;
      var lineUVs = [];

      if (line.indexOf('/') === -1) {
        lineVertices = lineParts;
      } else {
        lineVertices = [];

        for (var li = 0, llen = lineParts.length; li < llen; li++) {
          var parts = lineParts[li].split('/');
          if (parts[0] !== '') lineVertices.push(parts[0]);
          if (parts[1] !== '') lineUVs.push(parts[1]);
        }
      }

      state.addLineGeometry(lineVertices, lineUVs);
    } else if (lineFirstChar === 'p') {
      var _lineData = line.substr(1).trim();

      var pointData = _lineData.split(' ');

      state.addPointGeometry(pointData);
    } else if ((result = OBJECT_RE.exec(line)) !== null) {
      var name = (' ' + result[0].substr(1).trim()).substr(1);
      state.startObject(name);
    } else if (MATERIAL_USE_RE.test(line)) {
      state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
    } else if (MATERIAL_RE.test(line)) {
      state.materialLibraries.push(line.substring(7).trim());
    } else if (lineFirstChar === 's') {
      result = line.split(' ');

      if (result.length > 1) {
        var value = result[1].trim().toLowerCase();
        state.object.smooth = value !== '0' && value !== 'off';
      } else {
        state.object.smooth = true;
      }

      var material = state.object.currentMaterial();
      if (material) material.smooth = state.object.smooth;
    } else {
      if (line === '\0') continue;
      throw new Error("Unexpected line: \"".concat(line, "\""));
    }
  }

  state.finalize();
  var meshes = [];
  var materials = [];
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = state.objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var object = _step4.value;
      var geometry = object.geometry;
      if (geometry.vertices.length === 0) continue;
      var mesh = {
        header: {
          vertexCount: geometry.vertices.length / 3
        },
        attributes: {}
      };

      switch (geometry.type) {
        case 'Points':
          mesh.mode = 0;
          break;

        case 'Line':
          mesh.mode = 1;
          break;

        default:
          mesh.mode = 4;
          break;
      }

      mesh.attributes.POSITION = {
        value: new Float32Array(geometry.vertices),
        size: 3
      };

      if (geometry.normals.length > 0) {
        mesh.attributes.NORMAL = {
          value: new Float32Array(geometry.normals),
          size: 3
        };
      }

      if (geometry.colors.length > 0) {
        mesh.attributes.COLOR_0 = {
          value: new Float32Array(geometry.colors),
          size: 3
        };
      }

      if (geometry.uvs.length > 0) {
        mesh.attributes.TEXCOORD_0 = {
          value: new Float32Array(geometry.uvs),
          size: 2
        };
      }

      mesh.materials = [];
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = object.materials[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var sourceMaterial = _step5.value;
          var _material = {
            name: sourceMaterial.name,
            flatShading: !sourceMaterial.smooth
          };
          mesh.materials.push(_material);
          materials.push(_material);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      mesh.name = object.name;
      meshes.push(mesh);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return {
    meshes: meshes,
    materials: materials
  };
};

exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],229:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyFrames = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var KeyFrames = function () {
  function KeyFrames(keyFrames) {
    (0, _classCallCheck2["default"])(this, KeyFrames);
    this._lastTime = -1;
    this.startIndex = -1;
    this.endIndex = -1;
    this.factor = 0;
    this.times = [];
    this.values = [];
    this.setKeyFrames(keyFrames);
    this.setTime(0);
  }

  (0, _createClass2["default"])(KeyFrames, [{
    key: "setKeyFrames",
    value: function setKeyFrames(keyFrames) {
      var numKeys = keyFrames.length;
      this.times.length = numKeys;
      this.values.length = numKeys;

      for (var i = 0; i < numKeys; ++i) {
        this.times[i] = keyFrames[i][0];
        this.values[i] = keyFrames[i][1];
      }

      this._calculateKeys(this._lastTime);
    }
  }, {
    key: "setTime",
    value: function setTime(time) {
      time = Math.max(0, time);

      if (time !== this._lastTime) {
        this._calculateKeys(time);

        this._lastTime = time;
      }
    }
  }, {
    key: "getStartTime",
    value: function getStartTime() {
      return this.times[this.startIndex];
    }
  }, {
    key: "getEndTime",
    value: function getEndTime() {
      return this.times[this.endIndex];
    }
  }, {
    key: "getStartData",
    value: function getStartData() {
      return this.values[this.startIndex];
    }
  }, {
    key: "getEndData",
    value: function getEndData() {
      return this.values[this.endIndex];
    }
  }, {
    key: "_calculateKeys",
    value: function _calculateKeys(time) {
      var index = 0;
      var numKeys = this.times.length;

      for (index = 0; index < numKeys - 2; ++index) {
        if (this.times[index + 1] > time) {
          break;
        }
      }

      this.startIndex = index;
      this.endIndex = index + 1;
      var startTime = this.times[this.startIndex];
      var endTime = this.times[this.endIndex];
      this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);
    }
  }]);
  return KeyFrames;
}();

exports.KeyFrames = KeyFrames;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],230:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timeline = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var channelHandles = 0;
var animationHandles = 0;

var Timeline = function () {
  function Timeline() {
    (0, _classCallCheck2["default"])(this, Timeline);
    this.time = 0;
    this.channels = new Map();
    this.animations = new Map();
    this.playing = false;
    this.lastEngineTime = -1;
  }

  (0, _createClass2["default"])(Timeline, [{
    key: "addChannel",
    value: function addChannel(props) {
      var _props$delay = props.delay,
          delay = _props$delay === void 0 ? 0 : _props$delay,
          _props$duration = props.duration,
          duration = _props$duration === void 0 ? Number.POSITIVE_INFINITY : _props$duration,
          _props$rate = props.rate,
          rate = _props$rate === void 0 ? 1 : _props$rate,
          _props$repeat = props.repeat,
          repeat = _props$repeat === void 0 ? 1 : _props$repeat;
      var handle = channelHandles++;
      var channel = {
        time: 0,
        delay: delay,
        duration: duration,
        rate: rate,
        repeat: repeat
      };

      this._setChannelTime(channel, this.time);

      this.channels.set(handle, channel);
      return handle;
    }
  }, {
    key: "removeChannel",
    value: function removeChannel(handle) {
      this.channels["delete"](handle);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.animations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
              animationHandle = _step$value[0],
              animation = _step$value[1];

          if (animation.channel === handle) {
            this.detachAnimation(animationHandle);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "getTime",
    value: function getTime(handle) {
      if (handle === undefined) {
        return this.time;
      }

      var channel = this.channels.get(handle);

      if (channel === undefined) {
        return -1;
      }

      return channel.time;
    }
  }, {
    key: "setTime",
    value: function setTime(time) {
      this.time = Math.max(0, time);
      var channels = this.channels.values();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = channels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var channel = _step2.value;

          this._setChannelTime(channel, this.time);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var animations = this.animations.values();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = animations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var animationData = _step3.value;
          var animation = animationData.animation,
              _channel = animationData.channel;
          animation.setTime(this.getTime(_channel));
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "play",
    value: function play() {
      this.playing = true;
    }
  }, {
    key: "pause",
    value: function pause() {
      this.playing = false;
      this.lastEngineTime = -1;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.setTime(0);
    }
  }, {
    key: "attachAnimation",
    value: function attachAnimation(animation, channelHandle) {
      var animationHandle = animationHandles++;
      this.animations.set(animationHandle, {
        animation: animation,
        channel: channelHandle
      });
      animation.setTime(this.getTime(channelHandle));
      return animationHandle;
    }
  }, {
    key: "detachAnimation",
    value: function detachAnimation(handle) {
      this.animations["delete"](handle);
    }
  }, {
    key: "update",
    value: function update(engineTime) {
      if (this.playing) {
        if (this.lastEngineTime === -1) {
          this.lastEngineTime = engineTime;
        }

        this.setTime(this.time + (engineTime - this.lastEngineTime));
        this.lastEngineTime = engineTime;
      }
    }
  }, {
    key: "_setChannelTime",
    value: function _setChannelTime(channel, time) {
      var offsetTime = time - channel.delay;
      var totalDuration = channel.duration * channel.repeat;

      if (offsetTime >= totalDuration) {
        channel.time = channel.duration * channel.rate;
      } else {
        channel.time = Math.max(0, offsetTime) % channel.duration;
        channel.time *= channel.rate;
      }
    }
  }]);
  return Timeline;
}();

exports.Timeline = Timeline;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],231:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addEvents = addEvents;

function addEvents() {
  throw new Error('@luma.gl/addons: `addEvents` is removed. Use `EventManager` from mjolnir.js instead.');
}

},{}],232:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createGLTFModel;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _core = require("@luma.gl/core");

var _gltfMaterialParser = _interopRequireDefault(require("./gltf-material-parser"));

var vs = "\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n";
var fs = "\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";

function addVersionToShader(gl, source) {
  if ((0, _core.isWebGL2)(gl)) {
    return "#version 300 es\n".concat(source);
  }

  return source;
}

function createGLTFModel(gl, options) {
  var id = options.id,
      drawMode = options.drawMode,
      vertexCount = options.vertexCount,
      attributes = options.attributes,
      modelOptions = options.modelOptions;
  var materialParser = new _gltfMaterialParser["default"](gl, options);

  _core.log.info(4, 'createGLTFModel defines: ', materialParser.defines)();

  var managedResources = [];
  managedResources.push.apply(managedResources, (0, _toConsumableArray2["default"])(materialParser.generatedTextures));
  managedResources.push.apply(managedResources, (0, _toConsumableArray2["default"])(Object.values(attributes).map(function (attribute) {
    return attribute.buffer;
  })));
  var model = new _core.ModelNode(gl, Object.assign({
    id: id,
    drawMode: drawMode,
    vertexCount: vertexCount,
    modules: [_core.pbr],
    defines: materialParser.defines,
    parameters: materialParser.parameters,
    vs: addVersionToShader(gl, vs),
    fs: addVersionToShader(gl, fs),
    managedResources: managedResources
  }, modelOptions));
  model.setProps({
    attributes: attributes
  });
  model.setUniforms(materialParser.uniforms);
  return model;
}

},{"./gltf-material-parser":237,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/toConsumableArray":39,"@luma.gl/core":253}],233:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createGLTFObjects;

var _gltfInstantiator = _interopRequireDefault(require("./gltf-instantiator"));

function createGLTFObjects(gl, gltf, options) {
  var instantiator = new _gltfInstantiator["default"](gl, options);
  var scenes = instantiator.instantiate(gltf);
  var animator = instantiator.createAnimator();
  return {
    scenes: scenes,
    animator: animator
  };
}

},{"./gltf-instantiator":236,"@babel/runtime/helpers/interopRequireDefault":25}],234:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = exports.ATTRIBUTE_TYPE_TO_COMPONENTS = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@luma.gl/core");

var _math = require("math.gl");

var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
exports.ATTRIBUTE_TYPE_TO_COMPONENTS = ATTRIBUTE_TYPE_TO_COMPONENTS;
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
exports.ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY;

function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    var ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
    var components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
    var length = components * accessor.count;
    var _accessor$bufferView$ = accessor.bufferView.data,
        buffer = _accessor$bufferView$.buffer,
        byteOffset = _accessor$bufferView$.byteOffset;
    var array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);

    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      var slicedArray = [];

      for (var i = 0; i < array.length; i += components) {
        slicedArray.push(Array.from(array.slice(i, i + components)));
      }

      accessor._animation = slicedArray;
    }
  }

  return accessor._animation;
}

var helperMatrix = new _math.Matrix4();

function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();

  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }

  if (gltfNode.rotation) {
    var rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }

  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}

var quaternion = new _math.Quaternion();

function linearInterpolate(target, path, start, stop, ratio) {
  if (path === 'rotation') {
    quaternion.slerp({
      start: start,
      target: stop,
      ratio: ratio
    });

    for (var i = 0; i < quaternion.length; i++) {
      target[path][i] = quaternion[i];
    }
  } else {
    for (var _i = 0; _i < start.length; _i++) {
      target[path][_i] = ratio * stop[_i] + (1 - ratio) * start[_i];
    }
  }
}

function cubicsplineInterpolate(target, path, _ref) {
  var p0 = _ref.p0,
      outTangent0 = _ref.outTangent0,
      inTangent1 = _ref.inTangent1,
      p1 = _ref.p1,
      tDiff = _ref.tDiff,
      t = _ref.ratio;

  for (var i = 0; i < target[path].length; i++) {
    var m0 = outTangent0[i] * tDiff;
    var m1 = inTangent1[i] * tDiff;
    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;
  }
}

function stepInterpolate(target, path, value) {
  for (var i = 0; i < value.length; i++) {
    target[path][i] = value[i];
  }
}

function interpolate(time, _ref2, target, path) {
  var input = _ref2.input,
      interpolation = _ref2.interpolation,
      output = _ref2.output;
  var maxTime = input[input.length - 1];
  var animationTime = time % maxTime;
  var nextIndex = input.findIndex(function (t) {
    return t >= animationTime;
  });
  var previousIndex = Math.max(0, nextIndex - 1);

  if (!Array.isArray(target[path])) {
    switch (path) {
      case 'translation':
        target[path] = [0, 0, 0];
        break;

      case 'rotation':
        target[path] = [0, 0, 0, 1];
        break;

      case 'scale':
        target[path] = [1, 1, 1];
        break;

      default:
        _core.log.warn("Bad animation path ".concat(path))();

    }
  }

  (0, _core.assert)(target[path].length === output[previousIndex].length);
  var previousTime = input[previousIndex];
  var nextTime = input[nextIndex];

  switch (interpolation) {
    case 'STEP':
      stepInterpolate(target, path, output[previousIndex]);
      break;

    case 'LINEAR':
      if (nextTime > previousTime) {
        var ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }

      break;

    case 'CUBICSPLINE':
      if (nextTime > previousTime) {
        var _ratio = (animationTime - previousTime) / (nextTime - previousTime);

        var tDiff = nextTime - previousTime;
        var p0 = output[3 * previousIndex + 1];
        var outTangent0 = output[3 * previousIndex + 2];
        var inTangent1 = output[3 * nextIndex + 0];
        var p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, {
          p0: p0,
          outTangent0: outTangent0,
          inTangent1: inTangent1,
          p1: p1,
          tDiff: tDiff,
          ratio: _ratio
        });
      }

      break;

    default:
      _core.log.warn("Interpolation ".concat(interpolation, " not supported"))();

      break;
  }
}

var GLTFAnimation = function () {
  function GLTFAnimation(props) {
    (0, _classCallCheck2["default"])(this, GLTFAnimation);
    this.startTime = 0;
    this.playing = true;
    this.speed = 1;
    Object.assign(this, props);
  }

  (0, _createClass2["default"])(GLTFAnimation, [{
    key: "animate",
    value: function animate(timeMs) {
      if (!this.playing) {
        return;
      }

      var absTime = timeMs / 1000;
      var time = (absTime - this.startTime) * this.speed;
      this.channels.forEach(function (_ref3) {
        var sampler = _ref3.sampler,
            target = _ref3.target,
            path = _ref3.path;
        interpolate(time, sampler, target, path);
        applyTranslationRotationScale(target, target._node);
      });
    }
  }]);
  return GLTFAnimation;
}();

var GLTFAnimator = function () {
  function GLTFAnimator(gltf) {
    (0, _classCallCheck2["default"])(this, GLTFAnimator);
    this.animations = gltf.animations.map(function (animation, index) {
      var name = animation.name || "Animation-".concat(index);
      var samplers = animation.samplers.map(function (_ref4) {
        var input = _ref4.input,
            _ref4$interpolation = _ref4.interpolation,
            interpolation = _ref4$interpolation === void 0 ? 'LINEAR' : _ref4$interpolation,
            output = _ref4.output;
        return {
          input: accessorToJsArray(gltf.accessors[input]),
          interpolation: interpolation,
          output: accessorToJsArray(gltf.accessors[output])
        };
      });
      var channels = animation.channels.map(function (_ref5) {
        var sampler = _ref5.sampler,
            target = _ref5.target;
        return {
          sampler: samplers[sampler],
          target: gltf.nodes[target.node],
          path: target.path
        };
      });
      return new GLTFAnimation({
        name: name,
        channels: channels
      });
    });
  }

  (0, _createClass2["default"])(GLTFAnimator, [{
    key: "animate",
    value: function animate(time) {
      this.setTime(time);
    }
  }, {
    key: "setTime",
    value: function setTime(time) {
      this.animations.forEach(function (animation) {
        return animation.animate(time);
      });
    }
  }, {
    key: "getAnimations",
    value: function getAnimations() {
      return this.animations;
    }
  }]);
  return GLTFAnimator;
}();

exports["default"] = GLTFAnimator;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253,"math.gl":415}],235:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@luma.gl/core");

var GLTFEnvironment = function () {
  function GLTFEnvironment(gl, _ref) {
    var brdfLutUrl = _ref.brdfLutUrl,
        getTexUrl = _ref.getTexUrl;
    (0, _classCallCheck2["default"])(this, GLTFEnvironment);
    this.gl = gl;
    this.brdfLutUrl = brdfLutUrl;
    this.getTexUrl = getTexUrl;
  }

  (0, _createClass2["default"])(GLTFEnvironment, [{
    key: "makeCube",
    value: function makeCube(_ref2) {
      var id = _ref2.id,
          getTextureForFace = _ref2.getTextureForFace,
          parameters = _ref2.parameters;
      var pixels = {};

      _core.TextureCube.FACES.forEach(function (face) {
        pixels[face] = getTextureForFace(face);
      });

      return new _core.TextureCube(this.gl, {
        id: id,
        mipmaps: false,
        parameters: parameters,
        pixels: pixels
      });
    }
  }, {
    key: "getDiffuseEnvSampler",
    value: function getDiffuseEnvSampler() {
      var _this = this;

      if (!this._DiffuseEnvSampler) {
        var _parameters;

        this._DiffuseEnvSampler = this.makeCube({
          id: 'DiffuseEnvSampler',
          getTextureForFace: function getTextureForFace(dir) {
            return (0, _core.loadImage)(_this.getTexUrl('diffuse', dir, 0));
          },
          parameters: (_parameters = {}, (0, _defineProperty2["default"])(_parameters, 10242, 33071), (0, _defineProperty2["default"])(_parameters, 10243, 33071), (0, _defineProperty2["default"])(_parameters, 10241, 9729), (0, _defineProperty2["default"])(_parameters, 10240, 9729), _parameters)
        });
      }

      return this._DiffuseEnvSampler;
    }
  }, {
    key: "getSpecularEnvSampler",
    value: function getSpecularEnvSampler() {
      var _this2 = this;

      if (!this._SpecularEnvSampler) {
        var _parameters2;

        this._SpecularEnvSampler = this.makeCube({
          id: 'SpecularEnvSampler',
          getTextureForFace: function getTextureForFace(dir) {
            var imageArray = [];

            for (var lod = 0; lod <= 9; lod++) {
              imageArray.push((0, _core.loadImage)(_this2.getTexUrl('specular', dir, lod)));
            }

            return imageArray;
          },
          parameters: (_parameters2 = {}, (0, _defineProperty2["default"])(_parameters2, 10242, 33071), (0, _defineProperty2["default"])(_parameters2, 10243, 33071), (0, _defineProperty2["default"])(_parameters2, 10241, 9987), (0, _defineProperty2["default"])(_parameters2, 10240, 9729), _parameters2)
        });
      }

      return this._SpecularEnvSampler;
    }
  }, {
    key: "getBrdfTexture",
    value: function getBrdfTexture() {
      if (!this._BrdfTexture) {
        var _parameters3;

        this._BrdfTexture = new _core.Texture2D(this.gl, {
          id: 'brdfLUT',
          parameters: (_parameters3 = {}, (0, _defineProperty2["default"])(_parameters3, 10242, 33071), (0, _defineProperty2["default"])(_parameters3, 10243, 33071), (0, _defineProperty2["default"])(_parameters3, 10241, 9729), (0, _defineProperty2["default"])(_parameters3, 10240, 9729), _parameters3),
          pixelStore: (0, _defineProperty2["default"])({}, this.gl.UNPACK_FLIP_Y_WEBGL, false),
          data: (0, _core.loadImage)(this.brdfLutUrl)
        });
      }

      return this._BrdfTexture;
    }
  }, {
    key: "delete",
    value: function _delete() {
      if (this._DiffuseEnvSampler) {
        this._DiffuseEnvSampler["delete"]();

        this._DiffuseEnvSampler = null;
      }

      if (this._SpecularEnvSampler) {
        this._SpecularEnvSampler["delete"]();

        this._SpecularEnvSampler = null;
      }

      if (this._BrdfTexture) {
        this._BrdfTexture["delete"]();

        this._BrdfTexture = null;
      }
    }
  }]);
  return GLTFEnvironment;
}();

exports["default"] = GLTFEnvironment;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],236:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _core = require("@luma.gl/core");

var _gltfAnimator = _interopRequireDefault(require("./gltf-animator"));

var _createGltfModel = _interopRequireDefault(require("./create-gltf-model"));

var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var DEFAULT_OPTIONS = {
  modelOptions: {},
  pbrDebug: false,
  imageBasedLightingEnvironment: null,
  lights: true,
  useTangents: false
};

var GLTFInstantiator = function () {
  function GLTFInstantiator(gl) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, GLTFInstantiator);
    this.gl = gl;
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
  }

  (0, _createClass2["default"])(GLTFInstantiator, [{
    key: "instantiate",
    value: function instantiate(gltf) {
      var _this = this;

      this.gltf = gltf;
      var scenes = (gltf.scenes || []).map(function (scene) {
        return _this.createScene(scene);
      });
      return scenes;
    }
  }, {
    key: "createAnimator",
    value: function createAnimator() {
      if (Array.isArray(this.gltf.animations)) {
        return new _gltfAnimator["default"](this.gltf);
      }

      return null;
    }
  }, {
    key: "createScene",
    value: function createScene(gltfScene) {
      var _this2 = this;

      var gltfNodes = gltfScene.nodes || [];
      var nodes = gltfNodes.map(function (node) {
        return _this2.createNode(node);
      });
      var scene = new _core.GroupNode({
        id: gltfScene.name || gltfScene.id,
        children: nodes
      });
      return scene;
    }
  }, {
    key: "createNode",
    value: function createNode(gltfNode) {
      var _this3 = this;

      if (!gltfNode._node) {
        var gltfChildren = gltfNode.children || [];
        var children = gltfChildren.map(function (child) {
          return _this3.createNode(child);
        });

        if (gltfNode.mesh) {
          children.push(this.createMesh(gltfNode.mesh));
        }

        var node = new _core.GroupNode({
          id: gltfNode.name || gltfNode.id,
          children: children
        });

        if (gltfNode.matrix) {
          node.setMatrix(gltfNode.matrix);
        } else {
          node.matrix.identity();

          if (gltfNode.translation) {
            node.matrix.translate(gltfNode.translation);
          }

          if (gltfNode.rotation) {
            var rotationMatrix = new _math.Matrix4().fromQuaternion(gltfNode.rotation);
            node.matrix.multiplyRight(rotationMatrix);
          }

          if (gltfNode.scale) {
            node.matrix.scale(gltfNode.scale);
          }
        }

        gltfNode._node = node;
      }

      return gltfNode._node;
    }
  }, {
    key: "createMesh",
    value: function createMesh(gltfMesh) {
      var _this4 = this;

      if (!gltfMesh._mesh) {
        var gltfPrimitives = gltfMesh.primitives || [];
        var primitives = gltfPrimitives.map(function (gltfPrimitive, i) {
          return _this4.createPrimitive(gltfPrimitive, i, gltfMesh);
        });
        var mesh = new _core.GroupNode({
          id: gltfMesh.name || gltfMesh.id,
          children: primitives
        });
        gltfMesh._mesh = mesh;
      }

      return gltfMesh._mesh;
    }
  }, {
    key: "getVertexCount",
    value: function getVertexCount(attributes) {
      _core.log.warn('getVertexCount() not found')();
    }
  }, {
    key: "createPrimitive",
    value: function createPrimitive(gltfPrimitive, i, gltfMesh) {
      return (0, _createGltfModel["default"])(this.gl, Object.assign({
        id: gltfPrimitive.name || "".concat(gltfMesh.name || gltfMesh.id, "-primitive-").concat(i),
        drawMode: gltfPrimitive.mode || 4,
        vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),
        attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),
        material: gltfPrimitive.material
      }, this.options));
    }
  }, {
    key: "createAttributes",
    value: function createAttributes(attributes, indices) {
      var _this5 = this;

      var loadedAttributes = {};
      Object.keys(attributes).forEach(function (attrName) {
        loadedAttributes[attrName] = _this5.createAccessor(attributes[attrName], _this5.createBuffer(attributes[attrName], _this5.gl.ARRAY_BUFFER));
      });

      if (indices) {
        loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));
      }

      _core.log.info(4, 'glTF Attributes', {
        attributes: attributes,
        indices: indices,
        generated: loadedAttributes
      })();

      return loadedAttributes;
    }
  }, {
    key: "createBuffer",
    value: function createBuffer(attribute, target) {
      if (!attribute.bufferView) {
        attribute.bufferView = {};
      }

      var bufferView = attribute.bufferView;

      if (!bufferView.lumaBuffers) {
        bufferView.lumaBuffers = {};
      }

      if (!bufferView.lumaBuffers[target]) {
        bufferView.lumaBuffers[target] = new _core.Buffer(this.gl, {
          id: "from-".concat(bufferView.id),
          data: bufferView.data || attribute.value,
          target: target
        });
      }

      return bufferView.lumaBuffers[target];
    }
  }, {
    key: "createAccessor",
    value: function createAccessor(accessor, buffer) {
      return new _core._Accessor({
        buffer: buffer,
        offset: accessor.byteOffset || 0,
        stride: accessor.bufferView.byteStride || 0,
        type: accessor.componentType,
        size: ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]
      });
    }
  }, {
    key: "createSampler",
    value: function createSampler(gltfSampler) {
      return gltfSampler;
    }
  }, {
    key: "needsPOT",
    value: function needsPOT() {
      return false;
    }
  }]);
  return GLTFInstantiator;
}();

exports["default"] = GLTFInstantiator;

},{"./create-gltf-model":232,"./gltf-animator":234,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253,"math.gl":415}],237:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@luma.gl/core");

var GLTFMaterialParser = function () {
  function GLTFMaterialParser(gl, _ref) {
    var attributes = _ref.attributes,
        material = _ref.material,
        pbrDebug = _ref.pbrDebug,
        imageBasedLightingEnvironment = _ref.imageBasedLightingEnvironment,
        lights = _ref.lights,
        useTangents = _ref.useTangents;
    (0, _classCallCheck2["default"])(this, GLTFMaterialParser);
    this.gl = gl;
    this.defines = {
      USE_TEX_LOD: 1,
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    };
    this.uniforms = {
      u_Camera: [0, 0, 0],
      u_MetallicRoughnessValues: [1, 1]
    };
    this.parameters = {};
    this.generatedTextures = [];

    if (imageBasedLightingEnvironment) {
      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
      this.uniforms.u_ScaleIBLAmbient = [1, 1];
    }

    if (pbrDebug) {
      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
    }

    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');
    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');
    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');
    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');
    this.defineIfPresent(lights, 'USE_LIGHTS');
    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');

    if (material) {
      this.parseMaterial(material);
    }
  }

  (0, _createClass2["default"])(GLTFMaterialParser, [{
    key: "defineIfPresent",
    value: function defineIfPresent(value, name) {
      if (value) {
        this.defines[name] = 1;
      }
    }
  }, {
    key: "parseTexture",
    value: function parseTexture(gltfTexture, name) {
      var define = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
      var texture = new _core.Texture2D(this.gl, {
        id: gltfTexture.name || gltfTexture.id,
        parameters: parameters,
        pixelStore: (0, _defineProperty2["default"])({}, this.gl.UNPACK_FLIP_Y_WEBGL, false),
        data: gltfTexture.texture.source.getImageAsync()
      });
      this.uniforms[name] = texture;
      this.defineIfPresent(define, define);
      this.generatedTextures.push(texture);
    }
  }, {
    key: "parsePbrMetallicRoughness",
    value: function parsePbrMetallicRoughness(pbrMetallicRoughness) {
      if (pbrMetallicRoughness.baseColorTexture) {
        this.parseTexture(pbrMetallicRoughness.baseColorTexture, 'u_BaseColorSampler', 'HAS_BASECOLORMAP');
      }

      this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];

      if (pbrMetallicRoughness.metallicRoughnessTexture) {
        this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, 'u_MetallicRoughnessSampler', 'HAS_METALROUGHNESSMAP');
      }

      var _pbrMetallicRoughness = pbrMetallicRoughness.metallicFactor,
          metallicFactor = _pbrMetallicRoughness === void 0 ? 1 : _pbrMetallicRoughness,
          _pbrMetallicRoughness2 = pbrMetallicRoughness.roughnessFactor,
          roughnessFactor = _pbrMetallicRoughness2 === void 0 ? 1 : _pbrMetallicRoughness2;
      this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
    }
  }, {
    key: "parseMaterial",
    value: function parseMaterial(material) {
      if (material.pbrMetallicRoughness) {
        this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
      }

      if (material.normalTexture) {
        this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');
        var _material$normalTextu = material.normalTexture.scale,
            scale = _material$normalTextu === void 0 ? 1 : _material$normalTextu;
        this.uniforms.u_NormalScale = scale;
      }

      if (material.occlusionTexture) {
        this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');
        var _material$occlusionTe = material.occlusionTexture.strength,
            strength = _material$occlusionTe === void 0 ? 1 : _material$occlusionTe;
        this.uniforms.u_OcclusionStrength = strength;
      }

      if (material.emissiveTexture) {
        this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');
        this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
      }

      if (material.alphaMode === 'MASK') {
        var _material$alphaCutoff = material.alphaCutoff,
            alphaCutoff = _material$alphaCutoff === void 0 ? 0.5 : _material$alphaCutoff;
        this.defines.ALPHA_CUTOFF = 1;
        this.uniforms.u_AlphaCutoff = alphaCutoff;
      } else if (material.alphaMode === 'BLEND') {
        _core.log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();

        Object.assign(this.parameters, {
          blend: true,
          blendEquation: this.gl.FUNC_ADD,
          blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
        });
      }
    }
  }]);
  return GLTFMaterialParser;
}();

exports["default"] = GLTFMaterialParser;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/core":253}],238:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _core = require("@luma.gl/core");

var _gltf = require("@loaders.gl/gltf");

var _createGltfObjects = _interopRequireDefault(require("./create-gltf-objects"));

function parse(_x, _x2, _x3, _x4) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(data, options, uri, loader) {
    var gltf, gltfObjects;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            (0, _core.assert)(options.gl);
            _context.next = 3;
            return _gltf.GLTFLoader.parse(data, (0, _objectSpread2["default"])({}, options, {
              uri: uri,
              decompress: true
            }));

          case 3:
            gltf = _context.sent;
            gltfObjects = (0, _createGltfObjects["default"])(options.gl, gltf, options);

            if (!options.waitForFullLoad) {
              _context.next = 8;
              break;
            }

            _context.next = 8;
            return waitForGLTFAssets(gltfObjects);

          case 8:
            return _context.abrupt("return", Object.assign({
              gltf: gltf
            }, gltfObjects));

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}

function waitForGLTFAssets(_x5) {
  return _waitForGLTFAssets.apply(this, arguments);
}

function _waitForGLTFAssets() {
  _waitForGLTFAssets = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(gltfObjects) {
    var remaining;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            remaining = [];
            gltfObjects.scenes.forEach(function (scene) {
              scene.traverse(function (model) {
                Object.values(model.model.program.uniforms).forEach(function (uniform) {
                  if (uniform.loaded === false) {
                    remaining.push(uniform);
                  }
                });
              });
            });
            _context2.next = 4;
            return waitWhileCondition(function () {
              return remaining.some(function (uniform) {
                return !uniform.loaded;
              });
            });

          case 4:
            return _context2.abrupt("return", _context2.sent);

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _waitForGLTFAssets.apply(this, arguments);
}

function waitWhileCondition(_x6) {
  return _waitWhileCondition.apply(this, arguments);
}

function _waitWhileCondition() {
  _waitWhileCondition = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(condition) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!condition()) {
              _context3.next = 5;
              break;
            }

            _context3.next = 3;
            return new Promise(function (resolve) {
              return window.requestAnimationFrame(resolve);
            });

          case 3:
            _context3.next = 0;
            break;

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _waitWhileCondition.apply(this, arguments);
}

var _default = {
  name: 'GLTF Scenegraph Loader',
  extensions: ['gltf', 'glb'],
  parse: parse
};
exports["default"] = _default;

},{"./create-gltf-objects":233,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/regenerator":43,"@loaders.gl/gltf":183,"@luma.gl/core":253}],239:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Display", {
  enumerable: true,
  get: function get() {
    return _display["default"];
  }
});
Object.defineProperty(exports, "VRDisplay", {
  enumerable: true,
  get: function get() {
    return _vrDisplay["default"];
  }
});
Object.defineProperty(exports, "GLTFScenegraphLoader", {
  enumerable: true,
  get: function get() {
    return _gltfScenegraphLoader["default"];
  }
});
Object.defineProperty(exports, "GLTFEnvironment", {
  enumerable: true,
  get: function get() {
    return _gltfEnvironment["default"];
  }
});
Object.defineProperty(exports, "createGLTFObjects", {
  enumerable: true,
  get: function get() {
    return _createGltfObjects["default"];
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function get() {
    return _timeline.Timeline;
  }
});
Object.defineProperty(exports, "KeyFrames", {
  enumerable: true,
  get: function get() {
    return _keyFrames.KeyFrames;
  }
});
Object.defineProperty(exports, "addEvents", {
  enumerable: true,
  get: function get() {
    return _addEvents.addEvents;
  }
});

var _display = _interopRequireDefault(require("./webvr/display"));

var _vrDisplay = _interopRequireDefault(require("./webvr/vr-display"));

var _gltfScenegraphLoader = _interopRequireDefault(require("./gltf/gltf-scenegraph-loader"));

var _gltfEnvironment = _interopRequireDefault(require("./gltf/gltf-environment"));

var _createGltfObjects = _interopRequireDefault(require("./gltf/create-gltf-objects"));

var _timeline = require("./animation/timeline");

var _keyFrames = require("./animation/key-frames");

var _addEvents = require("./events/add-events");

},{"./animation/key-frames":229,"./animation/timeline":230,"./events/add-events":231,"./gltf/create-gltf-objects":233,"./gltf/gltf-environment":235,"./gltf/gltf-scenegraph-loader":238,"./webvr/display":240,"./webvr/vr-display":242,"@babel/runtime/helpers/interopRequireDefault":25}],240:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@luma.gl/core");

var Display = function () {
  function Display() {
    (0, _classCallCheck2["default"])(this, Display);
  }

  (0, _createClass2["default"])(Display, [{
    key: "getViews",
    value: function getViews(options) {
      var width = options.width,
          height = options.height;
      return [{
        params: {
          viewport: [0, 0, width, height],
          scissor: [0, 0, width, height],
          scissorTest: true
        }
      }];
    }
  }, {
    key: "submitFrame",
    value: function submitFrame() {
      return true;
    }
  }, {
    key: "requestAnimationFrame",
    value: function requestAnimationFrame(renderFrame) {
      return false;
    }
  }, {
    key: "delete",
    value: function _delete() {}
  }, {
    key: "_renderFrame",
    value: function _renderFrame(options) {
      var _this = this;

      var views = this.getViews(options);

      if (!views) {
        return false;
      }

      var gl = this.animationLoop.gl;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var view = _step.value;
          (0, _core.withParameters)(gl, view.params, function () {
            return _this.animationLoop.onRender((0, _objectSpread2["default"])({}, options, view));
          });
        };

        for (var _iterator = views[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.submitFrame();
      return true;
    }
  }]);
  return Display;
}();

exports["default"] = Display;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@luma.gl/core":253}],241:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEnterVRButton = createEnterVRButton;

function createEnterVRButton(_ref) {
  var canvas = _ref.canvas,
      title = _ref.title;

  var _canvas$getBoundingCl = canvas.getBoundingClientRect(),
      top = _canvas$getBoundingCl.top,
      left = _canvas$getBoundingCl.left,
      width = _canvas$getBoundingCl.width,
      height = _canvas$getBoundingCl.height;

  var container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.top = "".concat(top, "px");
  container.style.left = "".concat(left, "px");
  container.style.width = "".concat(width, "px");
  container.style.height = "".concat(height, "px");
  container.style.pointerEvents = 'none';
  container.style.zIndex = '999';
  document.body.appendChild(container);
  var button = document.createElement('button');
  button.style.padding = '16px';
  button.style.border = '1px solid #fff';
  button.style.borderRadius = '8px';
  button.style.background = 'rgba(0,0,0,0.5)';
  button.style.color = '#fff';
  button.style.font = 'normal 20px sans-serif';
  button.style.cursor = 'pointer';
  button.style.margin = '20px auto';
  button.style.display = 'block';
  button.style.pointerEvents = 'all';
  button.textContent = title;
  container.appendChild(button);
  return button;
}

},{}],242:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var _display = _interopRequireDefault(require("./display"));

var _vrButton = require("./vr-button");

var VRDisplay = function (_Display) {
  (0, _inherits2["default"])(VRDisplay, _Display);
  (0, _createClass2["default"])(VRDisplay, null, [{
    key: "isSupported",
    value: function isSupported() {
      return typeof navigator !== 'undefined' && 'getVRDisplays' in navigator && 'VRFrameData' in window;
    }
  }]);

  function VRDisplay(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, VRDisplay);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(VRDisplay).call(this, props));
    _this._vrSupported = VRDisplay.isSupported();

    if (_this._vrSupported) {
      _this.vrFrameData = new window.VRFrameData();
      _this.vrPresenting = false;
      _this.vrFrame = false;
      window.addEventListener('vrdisplaypresentchange', _this._vrDisplayPresentChange.bind((0, _assertThisInitialized2["default"])(_this)));
    }

    return _this;
  }

  (0, _createClass2["default"])(VRDisplay, [{
    key: "delete",
    value: function _delete() {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(VRDisplay.prototype), "delete", this).call(this);

      this._removeVRButton();
    }
  }, {
    key: "getViews",
    value: function getViews(options) {
      if (this._vrSupported) {
        this._addVRButton();
      }

      if (this.vrPresenting && this.vrFrame) {
        this.vrDisplay.getFrameData(this.vrFrameData);
        var _this$vrFrameData = this.vrFrameData,
            leftProjectionMatrix = _this$vrFrameData.leftProjectionMatrix,
            leftViewMatrix = _this$vrFrameData.leftViewMatrix,
            rightProjectionMatrix = _this$vrFrameData.rightProjectionMatrix,
            rightViewMatrix = _this$vrFrameData.rightViewMatrix;
        var width = options.width,
            height = options.height;
        return [{
          displayEye: 'left',
          projectionMatrix: leftProjectionMatrix,
          viewMatrix: leftViewMatrix,
          params: {
            viewport: [0, 0, width * 0.5, height],
            scissor: [0, 0, width * 0.5, height],
            scissorTest: true
          }
        }, {
          displayEye: 'right',
          projectionMatrix: rightProjectionMatrix,
          viewMatrix: rightViewMatrix,
          params: {
            viewport: [width * 0.5, 0, width * 0.5, height],
            scissor: [width * 0.5, 0, width * 0.5, height],
            scissorTest: true
          }
        }];
      }

      return (0, _get2["default"])((0, _getPrototypeOf2["default"])(VRDisplay.prototype), "getViews", this).call(this, options);
    }
  }, {
    key: "submitFrame",
    value: function submitFrame() {
      if (this.vrPresenting && this.vrFrame) {
        this.vrDisplay.submitFrame();
        return true;
      }

      return false;
    }
  }, {
    key: "requestAnimationFrame",
    value: function requestAnimationFrame(renderFrame) {
      var _this2 = this;

      if (this.vrPresenting) {
        this.vrDisplay.requestAnimationFrame(function () {
          _this2.vrFrame = true;
          renderFrame();
          _this2.vrFrame = false;
        });
        return true;
      }

      return false;
    }
  }, {
    key: "_addVRButton",
    value: function () {
      var _addVRButton2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
        var _this3 = this;

        var canvas, displays;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.vrButton) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                canvas = this._getCanvas();

                if (canvas) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return");

              case 5:
                _context.next = 7;
                return navigator.getVRDisplays();

              case 7:
                displays = _context.sent;

                if (displays && displays.length) {
                  _core.log.info(2, 'Found VR Displays', displays)();

                  this.vrDisplay = displays[0];
                  this.vrButton = (0, _vrButton.createEnterVRButton)({
                    canvas: canvas,
                    title: "Enter VR (".concat(this.vrDisplay.displayName, ")")
                  });

                  this.vrButton.onclick = function () {
                    return _this3._startDisplay();
                  };
                }

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _addVRButton() {
        return _addVRButton2.apply(this, arguments);
      }

      return _addVRButton;
    }()
  }, {
    key: "_getCanvas",
    value: function _getCanvas() {
      return this.animationLoop.canvas || this.animationLoop.gl && this.animationLoop.gl.canvas;
    }
  }, {
    key: "_removeVRButton",
    value: function _removeVRButton() {
      if (this.vrButton) {}
    }
  }, {
    key: "_startDisplay",
    value: function _startDisplay() {
      this.vrDisplay.requestPresent([{
        source: this._getCanvas()
      }]);
    }
  }, {
    key: "_vrDisplayPresentChange",
    value: function _vrDisplayPresentChange() {
      if (this.vrDisplay.isPresenting) {
        _core.log.info(2, 'Entering VR')();

        this.vrPresenting = true;
        this.vrButton.style.display = 'none';
      } else {
        _core.log.info(2, 'Exiting VR')();

        this.vrPresenting = false;
        this.vrButton.style.display = 'block';
      }
    }
  }]);
  return VRDisplay;
}(_display["default"]);

exports["default"] = VRDisplay;

},{"./display":240,"./vr-button":241,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/regenerator":43,"@luma.gl/core":253}],243:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOverrides = exports.setOverride = exports.removeModel = exports.logModel = exports.addModel = void 0;

var _seer = _interopRequireDefault(require("seer"));

var _utils = require("../utils");

var models = {};

var addModel = function addModel(model) {
  if (models[model.id]) {
    return;
  }

  models[model.id] = model;

  _seer["default"].listItem('luma.gl', model.id);
};

exports.addModel = addModel;

var logModel = function logModel(model, uniforms) {
  if (!_seer["default"].isReady() || _seer["default"].throttle("luma.gl:".concat(model.id), 1e3)) {
    return;
  }

  var attributesObject = model.geometry ? Object.assign({}, model.geometry.attributes, model.attributes) : model.attributes;
  var uniformsObject = Object.assign({}, model.uniforms, uniforms);

  _seer["default"].multiUpdate('luma.gl', model.id, [{
    path: 'objects.uniforms',
    data: uniformsObject
  }, {
    path: 'objects.attributes',
    data: attributesObject
  }]);
};

exports.logModel = logModel;

var removeModel = function removeModel(id) {
  delete models[id];

  _seer["default"].deleteItem('luma.gl', id);
};

exports.removeModel = removeModel;

var recursiveSet = function recursiveSet(obj, path, value) {
  if (!obj) {
    return;
  }

  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

var overrides = new Map();

var setOverride = function setOverride(id, valuePath, value) {
  if (!_utils.window.__SEER_INITIALIZED__) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  var uniforms = overrides.get(id);
  uniforms.set(valuePath, value);
};

exports.setOverride = setOverride;

var getOverrides = function getOverrides(id, uniforms) {
  if (!_utils.window.__SEER_INITIALIZED__ || !id) {
    return;
  }

  var overs = overrides.get(id);

  if (!overs) {
    return;
  }

  overs.forEach(function (value, valuePath) {
    recursiveSet(uniforms, valuePath, value);
  });
};

exports.getOverrides = getOverrides;

_seer["default"].listenFor('luma.gl', function (payload) {
  var model = models[payload.itemKey];

  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {
    return;
  }

  var valuePath = payload.valuePath.slice(1);
  setOverride(payload.itemKey, valuePath, payload.value);
  var uniforms = model.getUniforms();
  recursiveSet(uniforms, valuePath, payload.value);
  model.setUniforms(uniforms);
});

},{"../utils":281,"@babel/runtime/helpers/interopRequireDefault":25,"seer":457}],244:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));

var _utils = require("../utils");

var ConeGeometry = function (_TruncatedConeGeometr) {
  (0, _inherits2["default"])(ConeGeometry, _TruncatedConeGeometr);

  function ConeGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, ConeGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('cone-geometry') : _props$id,
        _props$radius = props.radius,
        radius = _props$radius === void 0 ? 1 : _props$radius,
        _props$cap = props.cap,
        cap = _props$cap === void 0 ? true : _props$cap;
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ConeGeometry).call(this, (0, _objectSpread2["default"])({}, props, {
      id: id,
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    })));
  }

  return ConeGeometry;
}(_truncatedConeGeometry["default"]);

exports["default"] = ConeGeometry;

},{"../utils":281,"./truncated-cone-geometry":250,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35}],245:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

var CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
var CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
var CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
var CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
var ATTRIBUTES = {
  POSITION: {
    size: 3,
    value: new Float32Array(CUBE_POSITIONS)
  },
  NORMAL: {
    size: 3,
    value: new Float32Array(CUBE_NORMALS)
  },
  TEXCOORD_0: {
    size: 2,
    value: new Float32Array(CUBE_TEX_COORDS)
  }
};

var CubeGeometry = function (_Geometry) {
  (0, _inherits2["default"])(CubeGeometry, _Geometry);

  function CubeGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, CubeGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('cube-geometry') : _props$id;
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(CubeGeometry).call(this, (0, _objectSpread2["default"])({}, props, {
      id: id,
      indices: {
        size: 1,
        value: new Uint16Array(CUBE_INDICES)
      },
      attributes: (0, _objectSpread2["default"])({}, ATTRIBUTES, props.attributes)
    })));
  }

  return CubeGeometry;
}(_geometry["default"]);

exports["default"] = CubeGeometry;

},{"../geometry/geometry":252,"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35}],246:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));

var _utils = require("../utils");

var CylinderGeometry = function (_TruncatedConeGeometr) {
  (0, _inherits2["default"])(CylinderGeometry, _TruncatedConeGeometr);

  function CylinderGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, CylinderGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('cylinder-geometry') : _props$id,
        _props$radius = props.radius,
        radius = _props$radius === void 0 ? 1 : _props$radius;
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(CylinderGeometry).call(this, (0, _objectSpread2["default"])({}, props, {
      id: id,
      bottomRadius: radius,
      topRadius: radius
    })));
  }

  return CylinderGeometry;
}(_truncatedConeGeometry["default"]);

exports["default"] = CylinderGeometry;

},{"../utils":281,"./truncated-cone-geometry":250,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35}],247:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _math = require("math.gl");

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

var ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
var ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];

var IcoSphereGeometry = function (_Geometry) {
  (0, _inherits2["default"])(IcoSphereGeometry, _Geometry);

  function IcoSphereGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, IcoSphereGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('ico-sphere-geometry') : _props$id;

    var _tesselateIcosaHedron = tesselateIcosaHedron(props),
        indices = _tesselateIcosaHedron.indices,
        attributes = _tesselateIcosaHedron.attributes;

    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(IcoSphereGeometry).call(this, (0, _objectSpread2["default"])({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2["default"])({}, attributes, props.attributes)
    })));
  }

  return IcoSphereGeometry;
}(_geometry["default"]);

exports["default"] = IcoSphereGeometry;

function tesselateIcosaHedron(props) {
  var _props$iterations = props.iterations,
      iterations = _props$iterations === void 0 ? 0 : _props$iterations;
  var PI = Math.PI;
  var PI2 = PI * 2;
  var positions = [].concat(ICO_POSITIONS);
  var indices = [].concat(ICO_INDICES);
  positions.push();
  indices.push();

  var getMiddlePoint = function () {
    var pointMemo = {};
    return function (i1, i2) {
      i1 *= 3;
      i2 *= 3;
      var mini = i1 < i2 ? i1 : i2;
      var maxi = i1 > i2 ? i1 : i2;
      var key = "".concat(mini, "|").concat(maxi);

      if (key in pointMemo) {
        return pointMemo[key];
      }

      var x1 = positions[i1];
      var y1 = positions[i1 + 1];
      var z1 = positions[i1 + 2];
      var x2 = positions[i2];
      var y2 = positions[i2 + 1];
      var z2 = positions[i2 + 2];
      var xm = (x1 + x2) / 2;
      var ym = (y1 + y2) / 2;
      var zm = (z1 + z2) / 2;
      var len = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len;
      ym /= len;
      zm /= len;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  }();

  for (var i = 0; i < iterations; i++) {
    var indices2 = [];

    for (var j = 0; j < indices.length; j += 3) {
      var a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      var b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      var c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }

    indices = indices2;
  }

  var normals = new Array(positions.length);
  var texCoords = new Array(positions.length / 3 * 2);
  var l = indices.length;

  for (var _i = l - 3; _i >= 0; _i -= 3) {
    var i1 = indices[_i + 0];
    var i2 = indices[_i + 1];
    var i3 = indices[_i + 2];
    var in1 = i1 * 3;
    var in2 = i2 * 3;
    var in3 = i3 * 3;
    var iu1 = i1 * 2;
    var iu2 = i2 * 2;
    var iu3 = i3 * 2;
    var x1 = positions[in1 + 0];
    var y1 = positions[in1 + 1];
    var z1 = positions[in1 + 2];
    var theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    var phi1 = Math.atan2(y1, x1) + PI;
    var v1 = theta1 / PI;
    var u1 = 1 - phi1 / PI2;
    var x2 = positions[in2 + 0];
    var y2 = positions[in2 + 1];
    var z2 = positions[in2 + 2];
    var theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    var phi2 = Math.atan2(y2, x2) + PI;
    var v2 = theta2 / PI;
    var u2 = 1 - phi2 / PI2;
    var x3 = positions[in3 + 0];
    var y3 = positions[in3 + 1];
    var z3 = positions[in3 + 2];
    var theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    var phi3 = Math.atan2(y3, x3) + PI;
    var v3 = theta3 / PI;
    var u3 = 1 - phi3 / PI2;
    var vec1 = [x3 - x2, y3 - y2, z3 - z2];
    var vec2 = [x1 - x2, y1 - y2, z1 - z2];
    var normal = new _math.Vector3(vec1).cross(vec2).normalize();
    var newIndex = void 0;

    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }

    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }

  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}

},{"../geometry/geometry":252,"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],248:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _geometryUtils = require("../geometry/geometry-utils");

var _utils = require("../utils");

var PlaneGeometry = function (_Geometry) {
  (0, _inherits2["default"])(PlaneGeometry, _Geometry);

  function PlaneGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, PlaneGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('plane-geometry') : _props$id;

    var _tesselatePlane = tesselatePlane(props),
        indices = _tesselatePlane.indices,
        attributes = _tesselatePlane.attributes;

    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PlaneGeometry).call(this, (0, _objectSpread2["default"])({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2["default"])({}, attributes, props.attributes)
    })));
  }

  return PlaneGeometry;
}(_geometry["default"]);

exports["default"] = PlaneGeometry;

function tesselatePlane(props) {
  var _props$type = props.type,
      type = _props$type === void 0 ? 'x,y' : _props$type,
      _props$offset = props.offset,
      offset = _props$offset === void 0 ? 0 : _props$offset,
      _props$flipCull = props.flipCull,
      flipCull = _props$flipCull === void 0 ? false : _props$flipCull,
      _props$unpack = props.unpack,
      unpack = _props$unpack === void 0 ? false : _props$unpack;
  var coords = type.split(',');
  var c1len = props["".concat(coords[0], "len")] || 1;
  var c2len = props["".concat(coords[1], "len")] || 1;
  var subdivisions1 = props["n".concat(coords[0])] || 1;
  var subdivisions2 = props["n".concat(coords[1])] || 1;
  var numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var texCoords = new Float32Array(numVertices * 2);

  if (flipCull) {
    c1len = -c1len;
  }

  var i2 = 0;
  var i3 = 0;

  for (var z = 0; z <= subdivisions2; z++) {
    for (var x = 0; x <= subdivisions1; x++) {
      var u = x / subdivisions1;
      var v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;

      switch (type) {
        case 'x,y':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;

        case 'x,z':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;

        case 'y,z':
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;

        default:
          throw new Error('PlaneGeometry: unknown type');
      }

      i2 += 2;
      i3 += 3;
    }
  }

  var numVertsAcross = subdivisions1 + 1;
  var indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);

  for (var _z = 0; _z < subdivisions2; _z++) {
    for (var _x = 0; _x < subdivisions1; _x++) {
      var index = (_z * subdivisions1 + _x) * 6;
      indices[index + 0] = (_z + 0) * numVertsAcross + _x;
      indices[index + 1] = (_z + 1) * numVertsAcross + _x;
      indices[index + 2] = (_z + 0) * numVertsAcross + _x + 1;
      indices[index + 3] = (_z + 1) * numVertsAcross + _x;
      indices[index + 4] = (_z + 1) * numVertsAcross + _x + 1;
      indices[index + 5] = (_z + 0) * numVertsAcross + _x + 1;
    }
  }

  var geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? (0, _geometryUtils.unpackIndexedGeometry)(geometry) : geometry;
}

},{"../geometry/geometry":252,"../geometry/geometry-utils":251,"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35}],249:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

var SphereGeometry = function (_Geometry) {
  (0, _inherits2["default"])(SphereGeometry, _Geometry);

  function SphereGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, SphereGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('sphere-geometry') : _props$id;

    var _tesselateSphere = tesselateSphere(props),
        indices = _tesselateSphere.indices,
        attributes = _tesselateSphere.attributes;

    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(SphereGeometry).call(this, (0, _objectSpread2["default"])({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2["default"])({}, attributes, props.attributes)
    })));
  }

  return SphereGeometry;
}(_geometry["default"]);

exports["default"] = SphereGeometry;

function tesselateSphere(props) {
  var _props$nlat = props.nlat,
      nlat = _props$nlat === void 0 ? 10 : _props$nlat,
      _props$nlong = props.nlong,
      nlong = _props$nlong === void 0 ? 10 : _props$nlong;
  var _props$radius = props.radius,
      radius = _props$radius === void 0 ? 1 : _props$radius;
  var startLat = 0;
  var endLat = Math.PI;
  var latRange = endLat - startLat;
  var startLong = 0;
  var endLong = 2 * Math.PI;
  var longRange = endLong - startLong;
  var numVertices = (nlat + 1) * (nlong + 1);

  if (typeof radius === 'number') {
    var value = radius;

    radius = function radius(n1, n2, n3, u, v) {
      return value;
    };
  }

  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var texCoords = new Float32Array(numVertices * 2);
  var indices = new Uint16Array(nlat * nlong * 6);

  for (var y = 0; y <= nlat; y++) {
    for (var x = 0; x <= nlong; x++) {
      var u = x / nlong;
      var v = y / nlat;
      var index = x + y * (nlong + 1);
      var i2 = index * 2;
      var i3 = index * 3;
      var theta = longRange * u;
      var phi = latRange * v;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);
      var ux = cosTheta * sinPhi;
      var uy = cosPhi;
      var uz = sinTheta * sinPhi;
      var r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }

  var numVertsAround = nlat + 1;

  for (var _x = 0; _x < nlat; _x++) {
    for (var _y = 0; _y < nlong; _y++) {
      var _index = (_x * nlong + _y) * 6;

      indices[_index + 0] = _y * numVertsAround + _x;
      indices[_index + 1] = _y * numVertsAround + _x + 1;
      indices[_index + 2] = (_y + 1) * numVertsAround + _x;
      indices[_index + 3] = (_y + 1) * numVertsAround + _x;
      indices[_index + 4] = _y * numVertsAround + _x + 1;
      indices[_index + 5] = (_y + 1) * numVertsAround + _x + 1;
    }
  }

  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}

},{"../geometry/geometry":252,"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35}],250:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

var INDEX_OFFSETS = {
  x: [2, 0, 1],
  y: [0, 1, 2],
  z: [1, 2, 0]
};

var TruncatedConeGeometry = function (_Geometry) {
  (0, _inherits2["default"])(TruncatedConeGeometry, _Geometry);

  function TruncatedConeGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, TruncatedConeGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('truncated-code-geometry') : _props$id;

    var _tesselateTruncatedCo = tesselateTruncatedCone(props),
        indices = _tesselateTruncatedCo.indices,
        attributes = _tesselateTruncatedCo.attributes;

    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(TruncatedConeGeometry).call(this, (0, _objectSpread2["default"])({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2["default"])({}, attributes, props.attributes)
    })));
  }

  return TruncatedConeGeometry;
}(_geometry["default"]);

exports["default"] = TruncatedConeGeometry;

function tesselateTruncatedCone(props) {
  var _props$bottomRadius = props.bottomRadius,
      bottomRadius = _props$bottomRadius === void 0 ? 0 : _props$bottomRadius,
      _props$topRadius = props.topRadius,
      topRadius = _props$topRadius === void 0 ? 0 : _props$topRadius,
      _props$height = props.height,
      height = _props$height === void 0 ? 1 : _props$height,
      _props$nradial = props.nradial,
      nradial = _props$nradial === void 0 ? 10 : _props$nradial,
      _props$nvertical = props.nvertical,
      nvertical = _props$nvertical === void 0 ? 10 : _props$nvertical,
      _props$verticalAxis = props.verticalAxis,
      verticalAxis = _props$verticalAxis === void 0 ? 'y' : _props$verticalAxis,
      _props$topCap = props.topCap,
      topCap = _props$topCap === void 0 ? false : _props$topCap,
      _props$bottomCap = props.bottomCap,
      bottomCap = _props$bottomCap === void 0 ? false : _props$bottomCap;
  var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  var numVertices = (nradial + 1) * (nvertical + 1 + extra);
  var slant = Math.atan2(bottomRadius - topRadius, height);
  var msin = Math.sin;
  var mcos = Math.cos;
  var mpi = Math.PI;
  var cosSlant = mcos(slant);
  var sinSlant = msin(slant);
  var start = topCap ? -2 : 0;
  var end = nvertical + (bottomCap ? 2 : 0);
  var vertsAroundEdge = nradial + 1;
  var indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  var indexOffset = INDEX_OFFSETS[verticalAxis];
  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var texCoords = new Float32Array(numVertices * 2);
  var i3 = 0;
  var i2 = 0;

  for (var i = start; i <= end; i++) {
    var v = i / nvertical;
    var y = height * v;
    var ringRadius = void 0;

    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }

    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }

    y -= height / 2;

    for (var j = 0; j < vertsAroundEdge; j++) {
      var sin = msin(j * mpi * 2 / nradial);
      var cos = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }

  for (var _i = 0; _i < nvertical + extra; _i++) {
    for (var _j = 0; _j < nradial; _j++) {
      var index = (_i * nradial + _j) * 6;
      indices[index + 0] = vertsAroundEdge * (_i + 0) + 0 + _j;
      indices[index + 1] = vertsAroundEdge * (_i + 0) + 1 + _j;
      indices[index + 2] = vertsAroundEdge * (_i + 1) + 1 + _j;
      indices[index + 3] = vertsAroundEdge * (_i + 0) + 0 + _j;
      indices[index + 4] = vertsAroundEdge * (_i + 1) + 1 + _j;
      indices[index + 5] = vertsAroundEdge * (_i + 1) + 0 + _j;
    }
  }

  return {
    indices: indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}

},{"../geometry/geometry":252,"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35}],251:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpackIndexedGeometry = unpackIndexedGeometry;

function unpackIndexedGeometry(geometry) {
  var indices = geometry.indices,
      attributes = geometry.attributes;

  if (!indices) {
    return geometry;
  }

  var vertexCount = indices.value.length;
  var unpackedAttributes = {};

  for (var attributeName in attributes) {
    var attribute = attributes[attributeName];
    var constant = attribute.constant,
        value = attribute.value,
        size = attribute.size;

    if (constant || !size) {
      continue;
    }

    var unpackedValue = new value.constructor(vertexCount * size);

    for (var x = 0; x < vertexCount; ++x) {
      var index = indices.value[x];

      for (var i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value[index * size + i];
      }
    }

    unpackedAttributes[attributeName] = {
      size: size,
      value: unpackedValue
    };
  }

  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}

},{}],252:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.DRAW_MODE = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _utils = require("../utils");

var DRAW_MODE = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006
};
exports.DRAW_MODE = DRAW_MODE;

var Geometry = function () {
  (0, _createClass2["default"])(Geometry, null, [{
    key: "DRAW_MODE",
    get: function get() {
      return DRAW_MODE;
    }
  }]);

  function Geometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, Geometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('geometry') : _props$id,
        _props$drawMode = props.drawMode,
        drawMode = _props$drawMode === void 0 ? DRAW_MODE.TRIANGLES : _props$drawMode,
        _props$attributes = props.attributes,
        attributes = _props$attributes === void 0 ? {} : _props$attributes,
        _props$indices = props.indices,
        indices = _props$indices === void 0 ? null : _props$indices,
        _props$vertexCount = props.vertexCount,
        vertexCount = _props$vertexCount === void 0 ? null : _props$vertexCount;
    this.id = id;
    this.drawMode = drawMode | 0;
    this.attributes = {};
    this.userData = {};

    this._setAttributes(attributes, indices);

    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }

  (0, _createClass2["default"])(Geometry, [{
    key: "getVertexCount",
    value: function getVertexCount() {
      return this.vertexCount;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.indices ? (0, _objectSpread2["default"])({
        indices: this.indices
      }, this.attributes) : this.attributes;
    }
  }, {
    key: "_print",
    value: function _print(attributeName) {
      return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
    }
  }, {
    key: "_setAttributes",
    value: function _setAttributes(attributes, indices) {
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? {
          value: indices,
          size: 1
        } : indices;
      }

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        attribute = ArrayBuffer.isView(attribute) ? {
          value: attribute
        } : attribute;
        (0, _utils.assert)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));

        if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
          attribute.size = 3;
        }

        if (attributeName === 'indices') {
          (0, _utils.assert)(!this.indices);
          this.indices = attribute;
        } else {
          this.attributes[attributeName] = attribute;
        }
      }

      if (this.indices && this.indices.isIndexed !== undefined) {
        this.indices = Object.assign({}, this.indices);
        delete this.indices.isIndexed;
      }

      return this;
    }
  }, {
    key: "_calculateVertexCount",
    value: function _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }

      var vertexCount = Infinity;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var value = attribute.value,
            size = attribute.size,
            constant = attribute.constant;

        if (!constant && value && size >= 1) {
          vertexCount = Math.min(vertexCount, value.length / size);
        }
      }

      (0, _utils.assert)(Number.isFinite(vertexCount));
      return vertexCount;
    }
  }, {
    key: "mode",
    get: function get() {
      return this.drawMode;
    }
  }]);
  return Geometry;
}();

exports["default"] = Geometry;

},{"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32}],253:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function get() {
    return _webgl.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function get() {
    return _webgl.isWebGL2;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function get() {
    return _webgl.lumaStats;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function get() {
    return _webgl.createGLContext;
  }
});
Object.defineProperty(exports, "destroyGLContext", {
  enumerable: true,
  get: function get() {
    return _webgl.destroyGLContext;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function get() {
    return _webgl.resizeGLContext;
  }
});
Object.defineProperty(exports, "setGLContextDefaults", {
  enumerable: true,
  get: function get() {
    return _webgl.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function get() {
    return _webgl.getContextInfo;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function get() {
    return _webgl.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function get() {
    return _webgl.getContextLimits;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function get() {
    return _webgl.FEATURES;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function get() {
    return _webgl.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function get() {
    return _webgl.hasFeatures;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function get() {
    return _webgl.getFeatures;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function get() {
    return _webgl.canCompileGLGSExtension;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function get() {
    return _webgl.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function get() {
    return _webgl.getKeyValue;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function get() {
    return _webgl.getKey;
  }
});
Object.defineProperty(exports, "setContextDefaults", {
  enumerable: true,
  get: function get() {
    return _webgl.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "glGetDebugInfo", {
  enumerable: true,
  get: function get() {
    return _webgl.getContextDebugInfo;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function get() {
    return _webgl.Buffer;
  }
});
Object.defineProperty(exports, "Shader", {
  enumerable: true,
  get: function get() {
    return _webgl.Shader;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function get() {
    return _webgl.VertexShader;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function get() {
    return _webgl.FragmentShader;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function get() {
    return _webgl.Program;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function get() {
    return _webgl.Framebuffer;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function get() {
    return _webgl.Renderbuffer;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function get() {
    return _webgl.Texture2D;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function get() {
    return _webgl.TextureCube;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function get() {
    return _webgl.clear;
  }
});
Object.defineProperty(exports, "clearBuffer", {
  enumerable: true,
  get: function get() {
    return _webgl.clearBuffer;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function get() {
    return _webgl.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function get() {
    return _webgl.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "copyToDataUrl", {
  enumerable: true,
  get: function get() {
    return _webgl.copyToDataUrl;
  }
});
Object.defineProperty(exports, "copyToImage", {
  enumerable: true,
  get: function get() {
    return _webgl.copyToImage;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function get() {
    return _webgl.copyToTexture;
  }
});
Object.defineProperty(exports, "blit", {
  enumerable: true,
  get: function get() {
    return _webgl.blit;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function get() {
    return _webgl.Query;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function get() {
    return _webgl.Texture3D;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function get() {
    return _webgl.TransformFeedback;
  }
});
Object.defineProperty(exports, "VertexArrayObject", {
  enumerable: true,
  get: function get() {
    return _webgl.VertexArrayObject;
  }
});
Object.defineProperty(exports, "VertexArray", {
  enumerable: true,
  get: function get() {
    return _webgl.VertexArray;
  }
});
Object.defineProperty(exports, "UniformBufferLayout", {
  enumerable: true,
  get: function get() {
    return _webgl.UniformBufferLayout;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _webgl.setPathPrefix;
  }
});
Object.defineProperty(exports, "loadFile", {
  enumerable: true,
  get: function get() {
    return _webgl.loadFile;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function get() {
    return _webgl.loadImage;
  }
});
Object.defineProperty(exports, "_Accessor", {
  enumerable: true,
  get: function get() {
    return _webgl.Accessor;
  }
});
Object.defineProperty(exports, "_clearBuffer", {
  enumerable: true,
  get: function get() {
    return _webgl.clearBuffer;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return _webgl.log;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _webgl.assert;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function get() {
    return _webgl.uid;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _webgl.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _webgl.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _webgl.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _webgl.document;
  }
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.trackContextState;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.resetParameters;
  }
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.setParameter;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.setParameters;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.withParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getModifiedParameters;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function get() {
    return _geometry["default"];
  }
});
Object.defineProperty(exports, "Material", {
  enumerable: true,
  get: function get() {
    return _material["default"];
  }
});
Object.defineProperty(exports, "AmbientLight", {
  enumerable: true,
  get: function get() {
    return _lightSource.AmbientLight;
  }
});
Object.defineProperty(exports, "DirectionalLight", {
  enumerable: true,
  get: function get() {
    return _lightSource.DirectionalLight;
  }
});
Object.defineProperty(exports, "PointLight", {
  enumerable: true,
  get: function get() {
    return _lightSource.PointLight;
  }
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function get() {
    return _animationLoop["default"];
  }
});
Object.defineProperty(exports, "encodePickingColor", {
  enumerable: true,
  get: function get() {
    return _pickingColors.encodePickingColor;
  }
});
Object.defineProperty(exports, "decodePickingColor", {
  enumerable: true,
  get: function get() {
    return _pickingColors.decodePickingColor;
  }
});
Object.defineProperty(exports, "getNullPickingColor", {
  enumerable: true,
  get: function get() {
    return _pickingColors.getNullPickingColor;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function get() {
    return _model["default"];
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function get() {
    return _transform2["default"];
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function get() {
    return _clipSpace["default"];
  }
});
Object.defineProperty(exports, "_ShaderCache", {
  enumerable: true,
  get: function get() {
    return _shaderCache["default"];
  }
});
Object.defineProperty(exports, "_AnimationLoopProxy", {
  enumerable: true,
  get: function get() {
    return _animationLoopProxy["default"];
  }
});
Object.defineProperty(exports, "_MultiPassRenderer", {
  enumerable: true,
  get: function get() {
    return _multiPassRenderer["default"];
  }
});
Object.defineProperty(exports, "_RenderState", {
  enumerable: true,
  get: function get() {
    return _renderState["default"];
  }
});
Object.defineProperty(exports, "_Pass", {
  enumerable: true,
  get: function get() {
    return _pass["default"];
  }
});
Object.defineProperty(exports, "_CompositePass", {
  enumerable: true,
  get: function get() {
    return _compositePass["default"];
  }
});
Object.defineProperty(exports, "_ClearPass", {
  enumerable: true,
  get: function get() {
    return _clearPass["default"];
  }
});
Object.defineProperty(exports, "_RenderPass", {
  enumerable: true,
  get: function get() {
    return _renderPass["default"];
  }
});
Object.defineProperty(exports, "_CopyPass", {
  enumerable: true,
  get: function get() {
    return _copyPass["default"];
  }
});
Object.defineProperty(exports, "_TexturePass", {
  enumerable: true,
  get: function get() {
    return _texturePass["default"];
  }
});
Object.defineProperty(exports, "_ShaderModulePass", {
  enumerable: true,
  get: function get() {
    return _shaderModulePass["default"];
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function get() {
    return _coneGeometry["default"];
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function get() {
    return _cubeGeometry["default"];
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function get() {
    return _cylinderGeometry["default"];
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function get() {
    return _icoSphereGeometry["default"];
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function get() {
    return _planeGeometry["default"];
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function get() {
    return _sphereGeometry["default"];
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function get() {
    return _truncatedConeGeometry["default"];
  }
});
Object.defineProperty(exports, "PhongMaterial", {
  enumerable: true,
  get: function get() {
    return _phongMaterial["default"];
  }
});
Object.defineProperty(exports, "PBRMaterial", {
  enumerable: true,
  get: function get() {
    return _pbrMaterial["default"];
  }
});
Object.defineProperty(exports, "ScenegraphNode", {
  enumerable: true,
  get: function get() {
    return _scenegraphNode["default"];
  }
});
Object.defineProperty(exports, "GroupNode", {
  enumerable: true,
  get: function get() {
    return _groupNode["default"];
  }
});
Object.defineProperty(exports, "ModelNode", {
  enumerable: true,
  get: function get() {
    return _modelNode["default"];
  }
});
Object.defineProperty(exports, "CameraNode", {
  enumerable: true,
  get: function get() {
    return _cameraNode["default"];
  }
});
Object.defineProperty(exports, "registerShaderModules", {
  enumerable: true,
  get: function get() {
    return _shadertools.registerShaderModules;
  }
});
Object.defineProperty(exports, "setDefaultShaderModules", {
  enumerable: true,
  get: function get() {
    return _shadertools.setDefaultShaderModules;
  }
});
Object.defineProperty(exports, "getDefaultShaderModules", {
  enumerable: true,
  get: function get() {
    return _shadertools.getDefaultShaderModules;
  }
});
Object.defineProperty(exports, "assembleShaders", {
  enumerable: true,
  get: function get() {
    return _shadertools.assembleShaders;
  }
});
Object.defineProperty(exports, "createShaderHook", {
  enumerable: true,
  get: function get() {
    return _shadertools.createShaderHook;
  }
});
Object.defineProperty(exports, "createModuleInjection", {
  enumerable: true,
  get: function get() {
    return _shadertools.createModuleInjection;
  }
});
Object.defineProperty(exports, "combineInjects", {
  enumerable: true,
  get: function get() {
    return _shadertools.combineInjects;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function get() {
    return _shadertools.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function get() {
    return _shadertools.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function get() {
    return _shadertools.fp64;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function get() {
    return _shadertools.project;
  }
});
Object.defineProperty(exports, "lights", {
  enumerable: true,
  get: function get() {
    return _shadertools.lights;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function get() {
    return _shadertools.dirlight;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function get() {
    return _shadertools.picking;
  }
});
Object.defineProperty(exports, "diffuse", {
  enumerable: true,
  get: function get() {
    return _shadertools.diffuse;
  }
});
Object.defineProperty(exports, "gouraudlighting", {
  enumerable: true,
  get: function get() {
    return _shadertools.gouraudlighting;
  }
});
Object.defineProperty(exports, "phonglighting", {
  enumerable: true,
  get: function get() {
    return _shadertools.phonglighting;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function get() {
    return _shadertools.pbr;
  }
});
Object.defineProperty(exports, "_transform", {
  enumerable: true,
  get: function get() {
    return _shadertools._transform;
  }
});
Object.defineProperty(exports, "MODULAR_SHADERS", {
  enumerable: true,
  get: function get() {
    return _shadertools.MODULAR_SHADERS;
  }
});
Object.defineProperty(exports, "getQualifierDetails", {
  enumerable: true,
  get: function get() {
    return _shadertools.getQualifierDetails;
  }
});
Object.defineProperty(exports, "getPassthroughFS", {
  enumerable: true,
  get: function get() {
    return _shadertools.getPassthroughFS;
  }
});
Object.defineProperty(exports, "typeToChannelSuffix", {
  enumerable: true,
  get: function get() {
    return _shadertools.typeToChannelSuffix;
  }
});
Object.defineProperty(exports, "typeToChannelCount", {
  enumerable: true,
  get: function get() {
    return _shadertools.typeToChannelCount;
  }
});
Object.defineProperty(exports, "convertToVec4", {
  enumerable: true,
  get: function get() {
    return _shadertools.convertToVec4;
  }
});

var _webgl = require("@luma.gl/webgl");

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _geometry = _interopRequireDefault(require("./geometry/geometry"));

var _material = _interopRequireDefault(require("./materials/material"));

var _lightSource = require("./lighting/light-source");

var _animationLoop = _interopRequireDefault(require("./lib/animation-loop"));

var _pickingColors = require("./lib/picking-colors");

var _model = _interopRequireDefault(require("./lib/model"));

var _transform2 = _interopRequireDefault(require("./lib/transform"));

var _clipSpace = _interopRequireDefault(require("./lib/clip-space"));

var _shaderCache = _interopRequireDefault(require("./lib/shader-cache"));

var _animationLoopProxy = _interopRequireDefault(require("./lib/animation-loop-proxy"));

var _multiPassRenderer = _interopRequireDefault(require("./multipass/multi-pass-renderer"));

var _renderState = _interopRequireDefault(require("./multipass/render-state"));

var _pass = _interopRequireDefault(require("./multipass/pass"));

var _compositePass = _interopRequireDefault(require("./multipass/composite-pass"));

var _clearPass = _interopRequireDefault(require("./multipass/clear-pass"));

var _renderPass = _interopRequireDefault(require("./multipass/render-pass"));

var _copyPass = _interopRequireDefault(require("./multipass/copy-pass"));

var _texturePass = _interopRequireDefault(require("./multipass/texture-pass"));

var _shaderModulePass = _interopRequireDefault(require("./multipass/shader-module-pass"));

var _coneGeometry = _interopRequireDefault(require("./geometries/cone-geometry"));

var _cubeGeometry = _interopRequireDefault(require("./geometries/cube-geometry"));

var _cylinderGeometry = _interopRequireDefault(require("./geometries/cylinder-geometry"));

var _icoSphereGeometry = _interopRequireDefault(require("./geometries/ico-sphere-geometry"));

var _planeGeometry = _interopRequireDefault(require("./geometries/plane-geometry"));

var _sphereGeometry = _interopRequireDefault(require("./geometries/sphere-geometry"));

var _truncatedConeGeometry = _interopRequireDefault(require("./geometries/truncated-cone-geometry"));

var _phongMaterial = _interopRequireDefault(require("./materials/phong-material"));

var _pbrMaterial = _interopRequireDefault(require("./materials/pbr-material"));

var _scenegraphNode = _interopRequireDefault(require("./scenegraph/nodes/scenegraph-node"));

var _groupNode = _interopRequireDefault(require("./scenegraph/nodes/group-node"));

var _modelNode = _interopRequireDefault(require("./scenegraph/nodes/model-node"));

var _cameraNode = _interopRequireDefault(require("./scenegraph/nodes/camera-node"));

var _shadertools = require("@luma.gl/shadertools");

},{"./geometries/cone-geometry":244,"./geometries/cube-geometry":245,"./geometries/cylinder-geometry":246,"./geometries/ico-sphere-geometry":247,"./geometries/plane-geometry":248,"./geometries/sphere-geometry":249,"./geometries/truncated-cone-geometry":250,"./geometry/geometry":252,"./lib/animation-loop":255,"./lib/animation-loop-proxy":254,"./lib/clip-space":257,"./lib/model":259,"./lib/picking-colors":260,"./lib/shader-cache":261,"./lib/transform":263,"./lighting/light-source":264,"./materials/material":265,"./materials/pbr-material":266,"./materials/phong-material":267,"./multipass/clear-pass":268,"./multipass/composite-pass":269,"./multipass/copy-pass":270,"./multipass/multi-pass-renderer":271,"./multipass/pass":272,"./multipass/render-pass":273,"./multipass/render-state":274,"./multipass/shader-module-pass":275,"./multipass/texture-pass":276,"./scenegraph/nodes/camera-node":277,"./scenegraph/nodes/group-node":278,"./scenegraph/nodes/model-node":279,"./scenegraph/nodes/scenegraph-node":280,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/shadertools":282,"@luma.gl/webgl":381,"@luma.gl/webgl-state-tracker":321}],254:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

function initializeCanvas(_self, canvas) {
  var eventHandlers = new Map();

  canvas.addEventListener = function (type, handler) {
    _self.postMessage({
      command: 'addEventListener',
      type: type
    });

    if (!eventHandlers.has(type)) {
      eventHandlers.set(type, []);
    }

    eventHandlers.get(type).push(handler);
  };

  canvas.removeEventListener = function (type, handler) {
    _self.postMessage({
      command: 'removeEventListener',
      type: type
    });

    var handlers = eventHandlers.get(type);

    if (handlers) {
      handlers.splice(handlers.indexOf(handler), 1);
    }
  };

  canvas.dispatchEvent = function (type, event) {
    var handlers = eventHandlers.get(type);

    if (handlers) {
      handlers.forEach(function (handler) {
        return handler(event);
      });
    }
  };

  _self.canvas = canvas;
}

var AnimationLoopProxy = function () {
  (0, _createClass2["default"])(AnimationLoopProxy, null, [{
    key: "createWorker",
    value: function createWorker(animationLoop) {
      return function (self) {
        animationLoop.setProps({
          useDevicePixels: false,
          autoResizeDrawingBuffer: false
        });
        self.canvas = null;

        self.onmessage = function (evt) {
          var message = evt.data;

          switch (message.command) {
            case 'start':
              initializeCanvas(self, message.opts.canvas);
              animationLoop.start(message.opts);
              break;

            case 'stop':
              animationLoop.stop();
              break;

            case 'resize':
              self.canvas.width = message.width;
              self.canvas.height = message.height;
              break;

            case 'event':
              self.canvas.dispatchEvent(message.type, message.event);
              break;

            default:
          }
        };
      };
    }
  }]);

  function AnimationLoopProxy(worker) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, AnimationLoopProxy);
    var _opts$onInitialize = opts.onInitialize,
        onInitialize = _opts$onInitialize === void 0 ? function () {} : _opts$onInitialize,
        _opts$onFinalize = opts.onFinalize,
        onFinalize = _opts$onFinalize === void 0 ? function () {} : _opts$onFinalize,
        _opts$useDevicePixels = opts.useDevicePixels,
        useDevicePixels = _opts$useDevicePixels === void 0 ? true : _opts$useDevicePixels,
        _opts$autoResizeDrawi = opts.autoResizeDrawingBuffer,
        autoResizeDrawingBuffer = _opts$autoResizeDrawi === void 0 ? true : _opts$autoResizeDrawi;
    this.props = {
      onInitialize: onInitialize,
      onFinalize: onFinalize
    };
    this.setProps({
      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
      useDevicePixels: useDevicePixels
    });
    (0, _utils.assert)(worker instanceof Worker);
    this.worker = worker;
    this.canvas = null;
    this.width = null;
    this.height = null;
    this._running = false;
    this._animationFrameId = null;
    this._onMessage = this._onMessage.bind(this);
    this._onEvent = this._onEvent.bind(this);
    this._updateFrame = this._updateFrame.bind(this);
  }

  (0, _createClass2["default"])(AnimationLoopProxy, [{
    key: "setProps",
    value: function setProps(props) {
      if ('autoResizeDrawingBuffer' in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }

      if ('useDevicePixels' in props) {
        this.useDevicePixels = props.useDevicePixels;
      }

      return this;
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._running) {
        return this;
      }

      this._running = true;
      this.worker.onmessage = this._onMessage;
      (0, _webgl.getPageLoadPromise)().then(function () {
        if (!_this._running) {
          return null;
        }

        _this._createAndTransferCanvas(opts);

        return _this.props.onInitialize(_this);
      }).then(function () {
        if (_this._running) {
          _this._animationFrameId = (0, _webgl.requestAnimationFrame)(_this._updateFrame);
        }
      });
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this._running) {
        (0, _webgl.cancelAnimationFrame)(this._animationFrameId);
        this._animationFrameId = null;
        this._running = false;
        this.props.onFinalize(this);
      }

      this.worker.postMessage({
        command: 'stop'
      });
      return this;
    }
  }, {
    key: "_onMessage",
    value: function _onMessage(evt) {
      switch (evt.data.command) {
        case 'addEventListener':
          this.canvas.addEventListener(evt.data.type, this._onEvent);
          break;

        case 'removeEventListener':
          this.canvas.removeEventListener(evt.data.type, this._onEvent);
          break;

        default:
      }
    }
  }, {
    key: "_onEvent",
    value: function _onEvent(evt) {
      var devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;
      var type = evt.type;
      var safeEvent = {};

      for (var key in evt) {
        var value = evt[key];
        var valueType = (0, _typeof2["default"])(value);

        if (key === 'offsetX' || key === 'offsetY') {
          value *= devicePixelRatio;
        }

        if (valueType === 'number' || valueType === 'boolean' || valueType === 'string') {
          safeEvent[key] = value;
        }
      }

      this.worker.postMessage({
        command: 'event',
        type: type,
        event: safeEvent
      });
    }
  }, {
    key: "_updateFrame",
    value: function _updateFrame() {
      this._resizeCanvasDrawingBuffer();

      this._animationFrameId = (0, _webgl.requestAnimationFrame)(this._updateFrame);
    }
  }, {
    key: "_createAndTransferCanvas",
    value: function _createAndTransferCanvas(opts) {
      var screenCanvas = (0, _webgl.getCanvas)(opts);

      if (!screenCanvas.transferControlToOffscreen) {
        _utils.log.error('OffscreenCanvas is not available in your browser.')();
      }

      var offscreenCanvas = screenCanvas.transferControlToOffscreen();
      this.worker.postMessage({
        command: 'start',
        opts: Object.assign({}, opts, {
          canvas: offscreenCanvas
        })
      }, [offscreenCanvas]);
      this.canvas = screenCanvas;
    }
  }, {
    key: "_resizeCanvasDrawingBuffer",
    value: function _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        var devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;
        var width = this.canvas.clientWidth * devicePixelRatio;
        var height = this.canvas.clientHeight * devicePixelRatio;

        if (this.width !== width || this.height !== height) {
          this.width = width;
          this.height = height;
          this.worker.postMessage({
            command: 'resize',
            width: width,
            height: height
          });
        }
      }
    }
  }]);
  return AnimationLoopProxy;
}();

exports["default"] = AnimationLoopProxy;

},{"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"@luma.gl/webgl":381}],255:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

var statIdCounter = 0;

var AnimationLoop = function () {
  function AnimationLoop() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, AnimationLoop);
    var _props$onCreateContex = props.onCreateContext,
        onCreateContext = _props$onCreateContex === void 0 ? function (opts) {
      return (0, _webgl.createGLContext)(opts);
    } : _props$onCreateContex,
        _props$onAddHTML = props.onAddHTML,
        onAddHTML = _props$onAddHTML === void 0 ? null : _props$onAddHTML,
        _props$onInitialize = props.onInitialize,
        onInitialize = _props$onInitialize === void 0 ? function () {} : _props$onInitialize,
        _props$onRender = props.onRender,
        onRender = _props$onRender === void 0 ? function () {} : _props$onRender,
        _props$onFinalize = props.onFinalize,
        onFinalize = _props$onFinalize === void 0 ? function () {} : _props$onFinalize,
        _props$gl = props.gl,
        gl = _props$gl === void 0 ? null : _props$gl,
        _props$glOptions = props.glOptions,
        glOptions = _props$glOptions === void 0 ? {} : _props$glOptions,
        _props$debug = props.debug,
        debug = _props$debug === void 0 ? false : _props$debug,
        _props$createFramebuf = props.createFramebuffer,
        createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf,
        _props$autoResizeView = props.autoResizeViewport,
        autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView,
        _props$autoResizeDraw = props.autoResizeDrawingBuffer,
        autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw,
        _props$stats = props.stats,
        stats = _props$stats === void 0 ? _webgl.lumaStats.get("animation-loop-".concat(statIdCounter++)) : _props$stats;
    var _props$useDevicePixel = props.useDevicePixels,
        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;

    if ('useDevicePixelRatio' in props) {
      _utils.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();

      useDevicePixels = props.useDevicePixelRatio;
    }

    this.props = {
      onCreateContext: onCreateContext,
      onAddHTML: onAddHTML,
      onInitialize: onInitialize,
      onRender: onRender,
      onFinalize: onFinalize,
      gl: gl,
      glOptions: glOptions,
      debug: debug,
      createFramebuffer: createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport: autoResizeViewport,
      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
      useDevicePixels: useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }

  (0, _createClass2["default"])(AnimationLoop, [{
    key: "delete",
    value: function _delete() {
      this.stop();

      this._setDisplay(null);
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw(reason) {
      (0, _utils.assert)(typeof reason === 'string');
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('autoResizeViewport' in props) {
        this.autoResizeViewport = props.autoResizeViewport;
      }

      if ('autoResizeDrawingBuffer' in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }

      if ('useDevicePixels' in props) {
        this.useDevicePixels = props.useDevicePixels;
      }

      return this;
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._running) {
        return this;
      }

      this._running = true;
      (0, _webgl.getPageLoadPromise)().then(function () {
        if (!_this._running || _this._initialized) {
          return null;
        }

        _this._createWebGLContext(opts);

        _this._createFramebuffer();

        _this._startEventHandling();

        _this._initializeCallbackData();

        _this._updateCallbackData();

        _this._resizeCanvasDrawingBuffer();

        _this._resizeViewport();

        _this._gpuTimeQuery = _webgl.Query.isSupported(_this.gl, ['timers']) ? new _webgl.Query(_this.gl) : null;
        _this._initialized = true;
        return _this.onInitialize(_this.animationProps);
      }).then(function (appContext) {
        if (_this._running) {
          _this._addCallbackData(appContext || {});

          if (appContext !== false) {
            _this._startLoop();
          }
        }
      });
      return this;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      this._beginTimers();

      this._setupFrame();

      this._updateCallbackData();

      this._renderFrame(this.animationProps);

      this._clearNeedsRedraw();

      if (this.offScreen && this.gl.commit) {
        this.gl.commit();
      }

      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);

        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }

      this._endTimers();

      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this._running) {
        this._finalizeCallbackData();

        (0, _webgl.cancelAnimationFrame)(this._animationFrameId);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._animationFrameId = null;
        this._running = false;
      }

      return this;
    }
  }, {
    key: "attachTimeline",
    value: function attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
  }, {
    key: "detachTimeline",
    value: function detachTimeline() {
      this.timeline = null;
    }
  }, {
    key: "waitForRender",
    value: function waitForRender() {
      var _this2 = this;

      this.setNeedsRedraw('waitForRender');

      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise(function (resolve) {
          _this2._resolveNextFrame = resolve;
        });
      }

      return this._nextFramePromise;
    }
  }, {
    key: "toDataURL",
    value: function () {
      var _toDataURL = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.setNeedsRedraw('toDataURL');
                _context.next = 3;
                return this.waitForRender();

              case 3:
                return _context.abrupt("return", this.gl.canvas.toDataURL());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function toDataURL() {
        return _toDataURL.apply(this, arguments);
      }

      return toDataURL;
    }()
  }, {
    key: "onCreateContext",
    value: function onCreateContext() {
      var _this$props;

      return (_this$props = this.props).onCreateContext.apply(_this$props, arguments);
    }
  }, {
    key: "onInitialize",
    value: function onInitialize() {
      var _this$props2;

      return (_this$props2 = this.props).onInitialize.apply(_this$props2, arguments);
    }
  }, {
    key: "onRender",
    value: function onRender() {
      var _this$props3;

      return (_this$props3 = this.props).onRender.apply(_this$props3, arguments);
    }
  }, {
    key: "onFinalize",
    value: function onFinalize() {
      var _this$props4;

      return (_this$props4 = this.props).onFinalize.apply(_this$props4, arguments);
    }
  }, {
    key: "getHTMLControlValue",
    value: function getHTMLControlValue(id) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var element = document.getElementById(id);
      return element ? Number(element.value) : defaultValue;
    }
  }, {
    key: "setViewParameters",
    value: function setViewParameters() {
      _utils.log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();

      return this;
    }
  }, {
    key: "_startLoop",
    value: function _startLoop() {
      var _this3 = this;

      var renderFrame = function renderFrame() {
        if (!_this3._running) {
          return;
        }

        _this3.redraw();

        _this3._animationFrameId = _this3._requestAnimationFrame(renderFrame);
      };

      (0, _webgl.cancelAnimationFrame)(this._animationFrameId);
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    }
  }, {
    key: "_setDisplay",
    value: function _setDisplay(display) {
      if (this.display) {
        this.display["delete"]();
        this.display.animationLoop = null;
      }

      if (display) {
        display.animationLoop = this;
      }

      this.display = display;
    }
  }, {
    key: "_requestAnimationFrame",
    value: function _requestAnimationFrame(renderFrameCallback) {
      if (this.display && this.display.requestAnimationFrame(renderFrameCallback)) {
        return;
      }

      (0, _webgl.requestAnimationFrame)(renderFrameCallback);
    }
  }, {
    key: "_renderFrame",
    value: function _renderFrame() {
      if (this.display) {
        var _this$display;

        (_this$display = this.display)._renderFrame.apply(_this$display, arguments);

        return;
      }

      this.onRender.apply(this, arguments);
    }
  }, {
    key: "_clearNeedsRedraw",
    value: function _clearNeedsRedraw() {
      this.needsRedraw = null;
    }
  }, {
    key: "_setupFrame",
    value: function _setupFrame() {
      if (this._onSetupFrame) {
        this._onSetupFrame(this.animationProps);
      } else {
        this._resizeCanvasDrawingBuffer();

        this._resizeViewport();

        this._resizeFramebuffer();
      }
    }
  }, {
    key: "_initializeCallbackData",
    value: function _initializeCallbackData() {
      this.animationProps = {
        gl: this.gl,
        stop: this.stop,
        canvas: this.gl.canvas,
        framebuffer: this.framebuffer,
        useDevicePixels: this.useDevicePixels,
        needsRedraw: null,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        time: 0,
        _timeline: this.timeline,
        _loop: this,
        _animationLoop: this,
        _mousePosition: null
      };
    }
  }, {
    key: "_updateCallbackData",
    value: function _updateCallbackData() {
      var _this$_getSizeAndAspe = this._getSizeAndAspect(),
          width = _this$_getSizeAndAspe.width,
          height = _this$_getSizeAndAspe.height,
          aspect = _this$_getSizeAndAspe.aspect;

      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw('drawing buffer resized');
      }

      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw('drawing buffer aspect changed');
      }

      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;

      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }

      this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
      this.animationProps._offScreen = this.offScreen;
    }
  }, {
    key: "_finalizeCallbackData",
    value: function _finalizeCallbackData() {
      this.onFinalize(this.animationProps);
    }
  }, {
    key: "_addCallbackData",
    value: function _addCallbackData(appContext) {
      if ((0, _typeof2["default"])(appContext) === 'object' && appContext !== null) {
        this.animationProps = Object.assign({}, this.animationProps, appContext);
      }
    }
  }, {
    key: "_createWebGLContext",
    value: function _createWebGLContext(opts) {
      this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;
      opts = Object.assign({}, opts, this.props.glOptions);
      this.gl = this.props.gl ? (0, _webgl.instrumentGLContext)(this.props.gl, opts) : this.onCreateContext(opts);

      if (!(0, _webgl.isWebGL)(this.gl)) {
        throw new Error('AnimationLoop.onCreateContext - illegal context returned');
      }

      (0, _webgl.resetParameters)(this.gl);

      this._createInfoDiv();
    }
  }, {
    key: "_createInfoDiv",
    value: function _createInfoDiv() {
      if (this.gl.canvas && this.props.onAddHTML) {
        var wrapperDiv = document.createElement('div');
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = 'relative';
        var div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.left = '10px';
        div.style.bottom = '10px';
        div.style.width = '300px';
        div.style.background = 'white';
        wrapperDiv.appendChild(this.gl.canvas);
        wrapperDiv.appendChild(div);
        var html = this.props.onAddHTML(div);

        if (html) {
          div.innerHTML = html;
        }
      }
    }
  }, {
    key: "_getSizeAndAspect",
    value: function _getSizeAndAspect() {
      var width = this.gl.drawingBufferWidth;
      var height = this.gl.drawingBufferHeight;
      var aspect = 1;
      var canvas = this.gl.canvas;

      if (canvas && canvas.clientHeight) {
        aspect = canvas.clientWidth / canvas.clientHeight;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }

      return {
        width: width,
        height: height,
        aspect: aspect
      };
    }
  }, {
    key: "_resizeViewport",
    value: function _resizeViewport() {
      if (this.autoResizeViewport) {
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
      }
    }
  }, {
    key: "_resizeCanvasDrawingBuffer",
    value: function _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        (0, _webgl.resizeGLContext)(this.gl, {
          useDevicePixels: this.useDevicePixels
        });
      }
    }
  }, {
    key: "_createFramebuffer",
    value: function _createFramebuffer() {
      if (this.props.createFramebuffer) {
        this.framebuffer = new _webgl.Framebuffer(this.gl);
      }
    }
  }, {
    key: "_resizeFramebuffer",
    value: function _resizeFramebuffer() {
      if (this.framebuffer) {
        this.framebuffer.resize({
          width: this.gl.drawingBufferWidth,
          height: this.gl.drawingBufferHeight
        });
      }
    }
  }, {
    key: "_beginTimers",
    value: function _beginTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();

      if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
        this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
      }

      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.beginTimeElapsedQuery();
      }

      this.cpuTime.timeStart();
    }
  }, {
    key: "_endTimers",
    value: function _endTimers() {
      this.cpuTime.timeEnd();

      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.end();
      }
    }
  }, {
    key: "_startEventHandling",
    value: function _startEventHandling() {
      var canvas = this.gl.canvas;

      if (canvas) {
        canvas.addEventListener('mousemove', this._onMousemove);
        canvas.addEventListener('mouseleave', this._onMouseleave);
      }
    }
  }, {
    key: "_onMousemove",
    value: function _onMousemove(e) {
      this.animationProps._mousePosition = [e.offsetX, e.offsetY];
    }
  }, {
    key: "_onMouseleave",
    value: function _onMouseleave(e) {
      this.animationProps._mousePosition = null;
    }
  }]);
  return AnimationLoop;
}();

exports["default"] = AnimationLoop;

},{"../utils":281,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"@babel/runtime/regenerator":43,"@luma.gl/webgl":381}],256:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webgl = require("@luma.gl/webgl");

var _shadertools = require("@luma.gl/shadertools");

var _seerIntegration = require("../debug/seer-integration");

var _utils = require("../utils");

var LOG_DRAW_PRIORITY = 2;
var LOG_DRAW_TIMEOUT = 10000;

var BaseModel = function () {
  function BaseModel(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, BaseModel);
    (0, _utils.assert)((0, _webgl.isWebGL)(gl));
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('base-model') : _props$id;
    this.id = id;
    this.gl = gl;
    this.id = props.id || (0, _utils.uid)('Model');
    this.lastLogTime = 0;
    this.initialize(props);

    this._setBaseModelProps(props);
  }

  (0, _createClass2["default"])(BaseModel, [{
    key: "initialize",
    value: function initialize(props) {
      this.props = {};
      this.program = this._createProgram(props);
      this.vertexArray = new _webgl.VertexArray(this.gl, {
        program: this.program
      });
      this.userData = {};
      this.needsRedraw = true;
      this._attributes = {};
      this.attributes = {};
      this.animatedUniforms = {};
      this.animated = false;
      this.animationLoop = null;
      this.timerQueryEnabled = false;
      this.timeElapsedQuery = undefined;
      this.lastQueryReturned = true;
      this.stats = {
        accumulatedFrameTime: 0,
        averageFrameTime: 0,
        profileFrameCount: 0
      };
      this.pickable = true;

      this._setBaseModelProps(props);

      this.setUniforms(Object.assign({}, this.getModuleUniforms(), this.getModuleUniforms(props.moduleSettings)));
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this._setBaseModelProps(props);
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var key in this._attributes) {
        if (this._attributes[key] !== this.attributes[key]) {
          this._attributes[key]["delete"]();
        }
      }

      this.program["delete"]();
      this.vertexArray["delete"]();
      (0, _seerIntegration.removeModel)(this.id);
    }
  }, {
    key: "isAnimated",
    value: function isAnimated() {
      return this.animated;
    }
  }, {
    key: "getProgram",
    value: function getProgram() {
      return this.program;
    }
  }, {
    key: "getUniforms",
    value: function getUniforms() {
      return this.program.uniforms;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      uniforms = Object.assign({}, uniforms);
      (0, _seerIntegration.getOverrides)(this.id, uniforms);
      uniforms = this._extractAnimatedUniforms(uniforms);
      this.program.setUniforms(uniforms);
      return this;
    }
  }, {
    key: "updateModuleSettings",
    value: function updateModuleSettings(opts) {
      var uniforms = this.getModuleUniforms(opts || {});
      return this.setUniforms(uniforms);
    }
  }, {
    key: "clear",
    value: function clear(opts) {
      (0, _webgl.clear)(this.program.gl, opts);
      return this;
    }
  }, {
    key: "drawGeometry",
    value: function drawGeometry() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _opts$moduleSettings = opts.moduleSettings,
          moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,
          framebuffer = opts.framebuffer,
          _opts$uniforms = opts.uniforms,
          uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,
          _opts$attributes = opts.attributes,
          attributes = _opts$attributes === void 0 ? {} : _opts$attributes,
          _opts$transformFeedba = opts.transformFeedback,
          transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,
          _opts$parameters = opts.parameters,
          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,
          _opts$vertexArray = opts.vertexArray,
          vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray,
          animationProps = opts.animationProps;
      (0, _seerIntegration.addModel)(this);
      this.setAttributes(attributes);
      this.updateModuleSettings(moduleSettings);
      this.setUniforms(uniforms);

      this._refreshAnimationProps(animationProps);

      var logPriority = this._logDrawCallStart(2);

      var drawParams = this.vertexArray.getDrawParams(this.props);

      if (drawParams.isInstanced && !this.isInstanced) {
        _utils.log.warn('Found instanced attributes on non-instanced model', this.id)();
      }

      var isIndexed = drawParams.isIndexed,
          indexType = drawParams.indexType,
          indexOffset = drawParams.indexOffset;
      var isInstanced = this.isInstanced,
          instanceCount = this.instanceCount;

      var noop = function noop() {};

      var _this$props = this.props,
          _this$props$onBeforeR = _this$props.onBeforeRender,
          onBeforeRender = _this$props$onBeforeR === void 0 ? noop : _this$props$onBeforeR,
          _this$props$onAfterRe = _this$props.onAfterRender,
          onAfterRender = _this$props$onAfterRe === void 0 ? noop : _this$props$onAfterRe;
      onBeforeRender();

      this._timerQueryStart();

      var didDraw = this.program.draw(Object.assign({}, opts, {
        logPriority: logPriority,
        uniforms: null,
        framebuffer: framebuffer,
        parameters: parameters,
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        vertexArray: vertexArray,
        transformFeedback: transformFeedback,
        isIndexed: isIndexed,
        indexType: indexType,
        isInstanced: isInstanced,
        instanceCount: instanceCount,
        offset: isIndexed ? indexOffset : 0
      }));

      this._timerQueryEnd();

      onAfterRender();

      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);

      return didDraw;
    }
  }, {
    key: "_setBaseModelProps",
    value: function _setBaseModelProps(props) {
      Object.assign(this.props, props);

      if ('uniforms' in props) {
        this.setUniforms(props.uniforms);
      }

      if ('pickable' in props) {
        this.pickable = props.pickable;
      }

      if ('timerQueryEnabled' in props) {
        this.timerQueryEnabled = props.timerQueryEnabled && _webgl.Query.isSupported(this.gl, ['timers']);

        if (props.timerQueryEnabled && !this.timerQueryEnabled) {
          _utils.log.warn('GPU timer not supported')();
        }
      }

      if ('_animationProps' in props) {
        this._setAnimationProps(props._animationProps);
      }

      if ('_animationLoop' in props) {
        this.animationLoop = props._animationLoop;
      }
    }
  }, {
    key: "_createProgram",
    value: function _createProgram(_ref) {
      var _ref$vs = _ref.vs,
          vs = _ref$vs === void 0 ? null : _ref$vs,
          _ref$fs = _ref.fs,
          fs = _ref$fs === void 0 ? null : _ref$fs,
          _ref$modules = _ref.modules,
          modules = _ref$modules === void 0 ? null : _ref$modules,
          _ref$defines = _ref.defines,
          defines = _ref$defines === void 0 ? {} : _ref$defines,
          _ref$inject = _ref.inject,
          inject = _ref$inject === void 0 ? {} : _ref$inject,
          _ref$shaderCache = _ref.shaderCache,
          shaderCache = _ref$shaderCache === void 0 ? null : _ref$shaderCache,
          _ref$varyings = _ref.varyings,
          varyings = _ref$varyings === void 0 ? null : _ref$varyings,
          _ref$bufferMode = _ref.bufferMode,
          bufferMode = _ref$bufferMode === void 0 ? 35981 : _ref$bufferMode,
          _ref$program = _ref.program,
          program = _ref$program === void 0 ? null : _ref$program;

      this.getModuleUniforms = function (x) {};

      var id = this.id;

      if (!program) {
        vs = vs || _shadertools.MODULAR_SHADERS.vs;
        fs = fs || _shadertools.MODULAR_SHADERS.fs;
        var assembleResult = (0, _shadertools.assembleShaders)(this.gl, {
          vs: vs,
          fs: fs,
          modules: modules,
          inject: inject,
          defines: defines,
          log: _utils.log
        });
        vs = assembleResult.vs;
        fs = assembleResult.fs;

        if (shaderCache) {
          program = shaderCache.getProgram(this.gl, {
            id: id,
            vs: vs,
            fs: fs
          });
        } else {
          program = new _webgl.Program(this.gl, {
            id: id,
            vs: vs,
            fs: fs,
            varyings: varyings,
            bufferMode: bufferMode
          });
        }

        this.getModuleUniforms = assembleResult.getUniforms || function (x) {};
      }

      (0, _utils.assert)(program instanceof _webgl.Program, 'Model needs a program');
      return program;
    }
  }, {
    key: "_refreshAnimationProps",
    value: function _refreshAnimationProps(animationProps) {
      animationProps = animationProps || this.animationLoop && this.animationLoop.animationProps;

      if (animationProps) {
        this._setAnimationProps(animationProps);
      }
    }
  }, {
    key: "_evaluateAnimateUniforms",
    value: function _evaluateAnimateUniforms(animationProps) {
      if (!this.animated) {
        return {};
      }

      var animatedUniforms = {};

      for (var uniformName in this.animatedUniforms) {
        var valueFunction = this.animatedUniforms[uniformName];
        animatedUniforms[uniformName] = valueFunction(animationProps);
      }

      return animatedUniforms;
    }
  }, {
    key: "_extractAnimatedUniforms",
    value: function _extractAnimatedUniforms(uniforms) {
      var foundAnimated = false;

      for (var uniformName in uniforms) {
        var newValue = uniforms[uniformName];

        if (typeof newValue === 'function') {
          this.animatedUniforms[uniformName] = newValue;
          foundAnimated = true;
        } else {
          delete this.animatedUniforms[uniformName];
        }
      }

      this.animated = !(0, _utils.isObjectEmpty)(this.animatedUniforms);

      if (!foundAnimated) {
        return uniforms;
      }

      var staticUniforms = {};

      for (var _uniformName in uniforms) {
        if (!this.animatedUniforms[_uniformName]) {
          staticUniforms[_uniformName] = uniforms[_uniformName];
        }
      }

      return staticUniforms;
    }
  }, {
    key: "_timerQueryStart",
    value: function _timerQueryStart() {
      if (this.timerQueryEnabled === true) {
        if (!this.timeElapsedQuery) {
          this.timeElapsedQuery = new _webgl.Query(this.gl);
        }

        if (this.lastQueryReturned) {
          this.lastQueryReturned = false;
          this.timeElapsedQuery.beginTimeElapsedQuery();
        }
      }
    }
  }, {
    key: "_timerQueryEnd",
    value: function _timerQueryEnd() {
      if (this.timerQueryEnabled === true) {
        this.timeElapsedQuery.end();

        if (this.timeElapsedQuery.isResultAvailable()) {
          this.lastQueryReturned = true;
          var elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();
          this.stats.lastFrameTime = elapsedTime;
          this.stats.accumulatedFrameTime += elapsedTime;
          this.stats.profileFrameCount++;
          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount;

          _utils.log.log(LOG_DRAW_PRIORITY, "GPU time ".concat(this.program.id, ": ").concat(this.stats.lastFrameTime, "ms average ").concat(this.stats.averageFrameTime, "ms accumulated: ").concat(this.stats.accumulatedFrameTime, "ms count: ").concat(this.stats.profileFrameCount))();
        }
      }
    }
  }, {
    key: "_logDrawCallStart",
    value: function _logDrawCallStart(priority) {
      var logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;

      if (_utils.log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {
        return undefined;
      }

      this.lastLogTime = Date.now();

      _utils.log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: _utils.log.priority <= 2
      })();

      return priority;
    }
  }, {
    key: "_logDrawCallEnd",
    value: function _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {
      if (priority === undefined) {
        return;
      }

      var attributeTable = (0, _webgl.getDebugTableForVertexArray)({
        vertexArray: vertexArray,
        header: "".concat(this.id, " attributes"),
        attributes: this._attributes
      });

      var _getDebugTableForUnif = (0, _webgl.getDebugTableForUniforms)({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms)
      }),
          uniformTable = _getDebugTableForUnif.table,
          unusedTable = _getDebugTableForUnif.unusedTable,
          unusedCount = _getDebugTableForUnif.unusedCount;

      var _getDebugTableForUnif2 = (0, _webgl.getDebugTableForUniforms)({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms),
        undefinedOnly: true
      }),
          missingTable = _getDebugTableForUnif2.table,
          missingCount = _getDebugTableForUnif2.count;

      if (missingCount > 0) {
        _utils.log.log('MISSING UNIFORMS', Object.keys(missingTable))();
      }

      if (unusedCount > 0) {
        _utils.log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();
      }

      var configTable = (0, _webgl.getDebugTableForProgramConfiguration)(this.vertexArray.configuration);

      _utils.log.table(priority, attributeTable)();

      _utils.log.table(priority, uniformTable)();

      _utils.log.table(priority + 1, configTable)();

      (0, _seerIntegration.logModel)(this, uniforms);

      if (framebuffer) {
        framebuffer.log({
          priority: LOG_DRAW_PRIORITY,
          message: "Rendered to ".concat(framebuffer.id)
        });
      }

      _utils.log.groupEnd(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id))();
    }
  }]);
  return BaseModel;
}();

exports["default"] = BaseModel;

},{"../debug/seer-integration":243,"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/shadertools":282,"@luma.gl/webgl":381}],257:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _model = _interopRequireDefault(require("../lib/model"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];

var ClipSpace = function (_Model) {
  (0, _inherits2["default"])(ClipSpace, _Model);

  function ClipSpace(gl, opts) {
    var _this;

    (0, _classCallCheck2["default"])(this, ClipSpace);
    var TEX_COORDS = POSITIONS.map(function (coord) {
      return coord === -1 ? 0 : coord;
    });
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ClipSpace).call(this, gl, Object.assign({}, opts, {
      vs: CLIPSPACE_VERTEX_SHADER,
      geometry: new _geometry["default"]({
        drawMode: 5,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: {
            size: 2,
            value: new Float32Array(POSITIONS)
          },
          aTexCoord: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          },
          aCoordinate: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          }
        }
      })
    })));

    _this.setVertexCount(4);

    return _this;
  }

  return ClipSpace;
}(_model["default"]);

exports["default"] = ClipSpace;

},{"../geometry/geometry":252,"../lib/model":259,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],258:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuffersFromGeometry = getBuffersFromGeometry;
exports.inferAttributeAccessor = inferAttributeAccessor;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: 'positions',
  NORMAL: 'normals',
  COLOR_0: 'colors',
  TEXCOORD_0: 'texCoords',
  TEXCOORD_1: 'texCoords1',
  TEXCOORD_2: 'texCoords2'
};

function getBuffersFromGeometry(gl, geometry, options) {
  var buffers = {};
  var indices = geometry.indices;

  for (var name in geometry.attributes) {
    var attribute = geometry.attributes[name];
    var remappedName = mapAttributeName(name, options);

    if (name === 'indices') {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      var typedArray = attribute.value;
      var accessor = (0, _objectSpread2["default"])({}, attribute);
      delete accessor.value;
      buffers[remappedName] = [new _webgl.Buffer(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }

  if (indices) {
    var data = indices.value || indices;
    (0, _utils.assert)(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    var _accessor = {
      size: 1,
      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
    };
    buffers.indices = [new _webgl.Buffer(gl, {
      data: data,
      target: 34963
    }), _accessor];
  }

  return buffers;
}

function mapAttributeName(name, options) {
  var _ref = options || {},
      _ref$attributeMap = _ref.attributeMap,
      attributeMap = _ref$attributeMap === void 0 ? GLTF_TO_LUMA_ATTRIBUTE_MAP : _ref$attributeMap;

  return attributeMap && attributeMap[name] || name;
}

function inferAttributeAccessor(attributeName, attribute) {
  var category;

  switch (attributeName) {
    case 'texCoords':
    case 'texCoord1':
    case 'texCoord2':
    case 'texCoord3':
      category = 'uvs';
      break;

    case 'vertices':
    case 'positions':
    case 'normals':
    case 'pickingColors':
      category = 'vectors';
      break;

    default:
  }

  switch (category) {
    case 'vectors':
      attribute.size = attribute.size || 3;
      break;

    case 'uvs':
      attribute.size = attribute.size || 2;
      break;

    default:
  }

  (0, _utils.assert)(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}

},{"../utils":281,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@luma.gl/webgl":381}],259:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _webgl = require("@luma.gl/webgl");

var _modelUtils = require("./model-utils");

var _baseModel = _interopRequireDefault(require("./base-model"));

var _utils = require("../utils");

var ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';

var Model = function (_BaseModel) {
  (0, _inherits2["default"])(Model, _BaseModel);

  function Model(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Model);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('model') : _props$id;
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Model).call(this, gl, (0, _objectSpread2["default"])({}, props, {
      id: id
    })));
  }

  (0, _createClass2["default"])(Model, [{
    key: "initialize",
    value: function initialize(props) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Model.prototype), "initialize", this).call(this, props);
      this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
      this.vertexCount = props.vertexCount || 0;
      this.geometryBuffers = {};
      this.isInstanced = props.isInstanced || props.instanced;

      this._setModelProps(props);

      this.geometry = {};
      (0, _utils.assert)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Model.prototype), "setProps", this).call(this, props);

      this._setModelProps(props);
    }
  }, {
    key: "delete",
    value: function _delete() {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Model.prototype), "delete", this).call(this);

      this._deleteGeometryBuffers();
    }
  }, {
    key: "getDrawMode",
    value: function getDrawMode() {
      return this.drawMode;
    }
  }, {
    key: "getVertexCount",
    value: function getVertexCount() {
      return this.vertexCount;
    }
  }, {
    key: "getInstanceCount",
    value: function getInstanceCount() {
      return this.instanceCount;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.attributes;
    }
  }, {
    key: "setDrawMode",
    value: function setDrawMode(drawMode) {
      this.drawMode = drawMode;
      return this;
    }
  }, {
    key: "setVertexCount",
    value: function setVertexCount(vertexCount) {
      (0, _utils.assert)(Number.isFinite(vertexCount));
      this.vertexCount = vertexCount;
      return this;
    }
  }, {
    key: "setInstanceCount",
    value: function setInstanceCount(instanceCount) {
      (0, _utils.assert)(Number.isFinite(instanceCount));
      this.instanceCount = instanceCount;
      return this;
    }
  }, {
    key: "setGeometry",
    value: function setGeometry(geometry) {
      this.drawMode = geometry.drawMode;
      this.vertexCount = geometry.getVertexCount();

      this._deleteGeometryBuffers();

      this.geometryBuffers = (0, _modelUtils.getBuffersFromGeometry)(this.gl, geometry);
      this.vertexArray.setAttributes(this.geometryBuffers);
      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ((0, _utils.isObjectEmpty)(attributes)) {
        return this;
      }

      var normalizedAttributes = {};

      for (var name in attributes) {
        var attribute = attributes[name];
        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
      }

      this.vertexArray.setAttributes(normalizedAttributes);
      return this;
    }
  }, {
    key: "draw",
    value: function draw() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.drawGeometry(options);
    }
  }, {
    key: "transform",
    value: function transform() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _opts$discard = opts.discard,
          discard = _opts$discard === void 0 ? true : _opts$discard,
          feedbackBuffers = opts.feedbackBuffers,
          _opts$unbindModels = opts.unbindModels,
          unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;
      var parameters = opts.parameters;

      if (feedbackBuffers) {
        this._setFeedbackBuffers(feedbackBuffers);
      }

      if (discard) {
        parameters = Object.assign({}, parameters, (0, _defineProperty2["default"])({}, 35977, discard));
      }

      unbindModels.forEach(function (model) {
        return model.vertexArray.unbindBuffers();
      });

      try {
        this.draw(Object.assign({}, opts, {
          parameters: parameters
        }));
      } finally {
        unbindModels.forEach(function (model) {
          return model.vertexArray.bindBuffers();
        });
      }

      return this;
    }
  }, {
    key: "render",
    value: function render() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();

      return this.setUniforms(uniforms).draw();
    }
  }, {
    key: "_setModelProps",
    value: function _setModelProps(props) {
      if ('instanceCount' in props) {
        this.instanceCount = props.instanceCount;
      }

      if ('geometry' in props) {
        this.setGeometry(props.geometry);
      }

      if ('attributes' in props) {
        this.setAttributes(props.attributes);
      }

      if ('_feedbackBuffers' in props) {
        this._setFeedbackBuffers(props._feedbackBuffers);
      }
    }
  }, {
    key: "_deleteGeometryBuffers",
    value: function _deleteGeometryBuffers() {
      for (var name in this.geometryBuffers) {
        var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];

        if (buffer instanceof _webgl.Buffer) {
          buffer["delete"]();
        }
      }
    }
  }, {
    key: "_setAnimationProps",
    value: function _setAnimationProps(animationProps) {
      if (this.animated) {
        (0, _utils.assert)(animationProps, 'Model.draw(): animated uniforms but no animationProps');

        var animatedUniforms = this._evaluateAnimateUniforms(animationProps);

        this.program.setUniforms(animatedUniforms);
      }
    }
  }, {
    key: "_setFeedbackBuffers",
    value: function _setFeedbackBuffers() {
      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ((0, _utils.isObjectEmpty)(feedbackBuffers)) {
        return this;
      }

      var gl = this.program.gl;
      this.transformFeedback = this.transformFeedback || new _webgl.TransformFeedback(gl, {
        program: this.program
      });
      this.transformFeedback.setBuffers(feedbackBuffers);
      return this;
    }
  }]);
  return Model;
}(_baseModel["default"]);

exports["default"] = Model;

},{"../utils":281,"./base-model":256,"./model-utils":258,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/webgl":381}],260:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodePickingColor = encodePickingColor;
exports.decodePickingColor = decodePickingColor;
exports.getNullPickingColor = getNullPickingColor;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var NULL_PICKING_COLOR = new Uint8Array([0, 0, 0]);

function encodePickingColor(i) {
  return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 16 & 255];
}

function decodePickingColor(color) {
  var _color = (0, _slicedToArray2["default"])(color, 3),
      i1 = _color[0],
      i2 = _color[1],
      i3 = _color[2];

  var index = i1 + i2 * 256 + i3 * 65536 - 1;
  return index;
}

function getNullPickingColor() {
  return NULL_PICKING_COLOR;
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],261:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

var ShaderCache = function () {
  function ShaderCache() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        gl = _ref.gl,
        _ref$_cachePrograms = _ref._cachePrograms,
        _cachePrograms = _ref$_cachePrograms === void 0 ? false : _ref$_cachePrograms;

    (0, _classCallCheck2["default"])(this, ShaderCache);
    (0, _utils.assert)(gl);
    this.gl = gl;
    this.vertexShaders = {};
    this.fragmentShaders = {};
    this.programs = {};
    this._cachePrograms = _cachePrograms;
  }

  (0, _createClass2["default"])(ShaderCache, [{
    key: "delete",
    value: function _delete() {
      return this;
    }
  }, {
    key: "getVertexShader",
    value: function getVertexShader(gl, source) {
      (0, _utils.assert)(typeof source === 'string');
      (0, _utils.assert)(this._compareContexts(gl, this.gl));
      var shader = this.vertexShaders[source];

      if (!shader) {
        shader = new _webgl.VertexShader(gl, source);
        this.vertexShaders[source] = shader;
      }

      return shader;
    }
  }, {
    key: "getFragmentShader",
    value: function getFragmentShader(gl, source) {
      (0, _utils.assert)(typeof source === 'string');
      (0, _utils.assert)(this._compareContexts(gl, this.gl));
      var shader = this.fragmentShaders[source];

      if (!shader) {
        shader = new _webgl.FragmentShader(gl, source);
        this.fragmentShaders[source] = shader;
      }

      return shader;
    }
  }, {
    key: "getProgram",
    value: function getProgram(gl, opts) {
      (0, _utils.assert)(this._compareContexts(gl, this.gl));
      (0, _utils.assert)(typeof opts.vs === 'string');
      (0, _utils.assert)(typeof opts.fs === 'string');
      (0, _utils.assert)(typeof opts.id === 'string');

      var cacheKey = this._getProgramKey(opts);

      var program = this.programs[cacheKey];

      if (program) {
        this._resetProgram(program);

        return program;
      }

      program = this._createNewProgram(gl, opts);

      if (this._cachePrograms && this._checkProgramProp(program)) {
        program._isCached = true;
        this.programs[cacheKey] = program;
      }

      return program;
    }
  }, {
    key: "_getProgramKey",
    value: function _getProgramKey(opts) {
      return "".concat(opts.id, "-").concat(opts.vs, "-").concat(opts.fs);
    }
  }, {
    key: "_checkProgramProp",
    value: function _checkProgramProp(program) {
      return !program.varyings;
    }
  }, {
    key: "_createNewProgram",
    value: function _createNewProgram(gl, opts) {
      var vs = opts.vs,
          fs = opts.fs;
      var vertexShader = this.getVertexShader(gl, vs);
      var fragmentShader = this.getFragmentShader(gl, fs);
      return new _webgl.Program(this.gl, Object.assign({}, opts, {
        vs: vertexShader,
        fs: fragmentShader
      }));
    }
  }, {
    key: "_resetProgram",
    value: function _resetProgram(program, opts) {
      program.reset();
    }
  }, {
    key: "_compareContexts",
    value: function _compareContexts(gl1, gl2) {
      return (gl1.gl || gl1) === (gl2.gl || gl2);
    }
  }]);
  return ShaderCache;
}();

exports["default"] = ShaderCache;

},{"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/webgl":381}],262:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateForTextures = updateForTextures;
exports.getSizeUniforms = getSizeUniforms;
exports.getVaryingType = getVaryingType;
exports.processAttributeDefinition = processAttributeDefinition;

var _utils = require("../utils");

var _shadertools = require("@luma.gl/shadertools");

var SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
var SIZE_UNIFORM_PREFIX = 'transform_uSize_';
var VS_POS_VARIABLE = 'transform_position';

function updateForTextures(_ref) {
  var vs = _ref.vs,
      sourceTextureMap = _ref.sourceTextureMap,
      targetTextureVarying = _ref.targetTextureVarying,
      targetTexture = _ref.targetTexture;
  var texAttributeNames = Object.keys(sourceTextureMap);
  var sourceCount = texAttributeNames.length;
  var targetTextureType = null;
  var samplerTextureMap = {};
  var updatedVs = vs;
  var finalInject = {};

  if (sourceCount > 0 || targetTextureVarying) {
    var vsLines = updatedVs.split('\n');
    var updateVsLines = vsLines.slice();
    vsLines.forEach(function (line, index, lines) {
      if (sourceCount > 0) {
        var updated = processAttributeDefinition(line, sourceTextureMap);

        if (updated) {
          var updatedLine = updated.updatedLine,
              inject = updated.inject;
          updateVsLines[index] = updatedLine;
          finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }

      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });

    if (targetTextureVarying) {
      (0, _utils.assert)(targetTexture);
      var sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      var uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      var posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      var inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
    }

    updatedVs = updateVsLines.join('\n');
  }

  return {
    vs: updatedVs,
    targetTextureType: targetTextureType,
    inject: finalInject,
    samplerTextureMap: samplerTextureMap
  };
}

function getSizeUniforms(_ref2) {
  var sourceTextureMap = _ref2.sourceTextureMap,
      targetTextureVarying = _ref2.targetTextureVarying,
      targetTexture = _ref2.targetTexture;
  var uniforms = {};
  var width;
  var height;

  if (targetTextureVarying) {
    width = targetTexture.width;
    height = targetTexture.height;
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }

  for (var textureName in sourceTextureMap) {
    var _sourceTextureMap$tex = sourceTextureMap[textureName];
    width = _sourceTextureMap$tex.width;
    height = _sourceTextureMap$tex.height;
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }

  return uniforms;
}

function getAttributeDefinition(line) {
  return (0, _shadertools.getQualifierDetails)(line, ['attribute', 'in']);
}

function getSamplerDeclerations(textureName) {
  var samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  var sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  var uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName: samplerName,
    sizeName: sizeName,
    uniformDeclerations: uniformDeclerations
  };
}

function getVaryingType(line, varying) {
  var qualaiferDetails = (0, _shadertools.getQualifierDetails)(line, ['varying', 'out']);

  if (!qualaiferDetails) {
    return null;
  }

  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}

function processAttributeDefinition(line, textureMap) {
  var samplerTextureMap = {};
  var attributeData = getAttributeDefinition(line);

  if (!attributeData) {
    return null;
  }

  var type = attributeData.type,
      name = attributeData.name;

  if (name && textureMap[name]) {
    var updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");

    var _getSamplerDecleratio = getSamplerDeclerations(name),
        samplerName = _getSamplerDecleratio.samplerName,
        sizeName = _getSamplerDecleratio.sizeName,
        uniformDeclerations = _getSamplerDecleratio.uniformDeclerations;

    var channels = (0, _shadertools.typeToChannelSuffix)(type);
    var sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    var inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };
    return {
      updatedLine: updatedLine,
      inject: inject,
      samplerTextureMap: samplerTextureMap
    };
  }

  return null;
}

},{"../utils":281,"@luma.gl/shadertools":282}],263:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _shadertools = require("@luma.gl/shadertools");

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

var _model = _interopRequireDefault(require("./model"));

var _transformShaderUtils = require("./transform-shader-utils");

var _SRC_TEX_PARAMETER_OV;

var SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, (0, _defineProperty2["default"])(_SRC_TEX_PARAMETER_OV, 10241, 9728), (0, _defineProperty2["default"])(_SRC_TEX_PARAMETER_OV, 10240, 9728), (0, _defineProperty2["default"])(_SRC_TEX_PARAMETER_OV, 10242, 33071), (0, _defineProperty2["default"])(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);
var FS_OUTPUT_VARIABLE = 'transform_output';

var Transform = function () {
  (0, _createClass2["default"])(Transform, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      return (0, _webgl.isWebGL2)(gl);
    }
  }]);

  function Transform(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Transform);
    (0, _utils.assert)((0, _webgl.isWebGL2)(gl));
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.currentIndex = 0;
    this.sourceBuffers = new Array(2);
    this.sourceTextures = new Array(2);
    this.feedbackBuffers = new Array(2);
    this.targetTextures = new Array(2);
    this.transformFeedbacks = new Array(2);
    this.framebuffers = new Array(2);
    this.resources = {};
    this.elementIDBuffer = null;
    this._targetRefTexName = null;

    this._initialize(props);

    Object.seal(this);
  }

  (0, _createClass2["default"])(Transform, [{
    key: "delete",
    value: function _delete() {
      for (var name in this.resources) {
        this.resources[name]["delete"]();
      }

      this.model["delete"]();
    }
  }, {
    key: "getBuffer",
    value: function getBuffer() {
      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var bufferOrParams = varyingName ? this.feedbackBuffers[this.currentIndex][varyingName] : null;

      if (!bufferOrParams) {
        return null;
      }

      return bufferOrParams instanceof _webgl.Buffer ? bufferOrParams : bufferOrParams.buffer;
    }
  }, {
    key: "_getTargetTexture",
    value: function _getTargetTexture() {
      if (this.framebuffers[this.currentIndex]) {
        return this.framebuffers[this.currentIndex].attachments[36064];
      }

      return null;
    }
  }, {
    key: "getData",
    value: function getData() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$varyingName = _ref.varyingName,
          varyingName = _ref$varyingName === void 0 ? null : _ref$varyingName,
          _ref$packed = _ref.packed,
          packed = _ref$packed === void 0 ? false : _ref$packed;

      var buffer = this.getBuffer(varyingName);

      if (buffer) {
        return buffer.getData();
      }

      (0, _utils.assert)(!varyingName || varyingName === this.targetTextureVarying);
      var pixels = (0, _webgl.readPixelsToArray)(this.framebuffers[this.currentIndex]);

      if (!packed) {
        return pixels;
      }

      var ArrayType = pixels.constructor;
      var channelCount = (0, _shadertools.typeToChannelCount)(this.targetTextureType);
      var packedPixels = new ArrayType(pixels.length * channelCount / 4);
      var packCount = 0;

      for (var i = 0; i < pixels.length; i += 4) {
        for (var j = 0; j < channelCount; j++) {
          packedPixels[packCount++] = pixels[i + j];
        }
      }

      return packedPixels;
    }
  }, {
    key: "getFramebuffer",
    value: function getFramebuffer() {
      return this.framebuffers[this.currentIndex];
    }
  }, {
    key: "_getInputs",
    value: function _getInputs() {
      var uniforms = {};
      var current = this.currentIndex;
      var attributes = Object.assign({}, this.sourceBuffers[current]);

      if (this.hasSourceTextures || this.targetTextureVarying) {
        attributes.transform_elementID = this.elementIDBuffer;

        for (var sampler in this.samplerTextureMap) {
          var textureName = this.samplerTextureMap[sampler];
          uniforms[sampler] = this.sourceTextures[current][textureName];
        }

        this._setSourceTextureParameters();

        var sizeUniforms = (0, _transformShaderUtils.getSizeUniforms)({
          sourceTextureMap: this.sourceTextures[current],
          targetTextureVarying: this.targetTextureVarying,
          targetTexture: this.targetTextures[current]
        });
        Object.assign(uniforms, sizeUniforms);
      }

      return {
        attributes: attributes,
        uniforms: uniforms
      };
    }
  }, {
    key: "run",
    value: function run() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_getInputs = this._getInputs(),
          attributes = _this$_getInputs.attributes,
          uniforms = _this$_getInputs.uniforms;

      Object.assign(uniforms, opts.uniforms);
      var parameters = Object.assign({}, opts.parameters);
      var _opts$clearRenderTarg = opts.clearRenderTarget,
          clearRenderTarget = _opts$clearRenderTarg === void 0 ? true : _opts$clearRenderTarg;
      var framebuffer = null;
      var discard = true;

      if (this.renderingToTexture) {
        discard = false;
        framebuffer = this.framebuffers[this.currentIndex];
        (0, _utils.assert)(framebuffer);
        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];

        if (clearRenderTarget) {
          framebuffer.clear({
            color: true
          });
        }
      }

      this.model.setAttributes(attributes);
      this.model.transform(Object.assign({}, opts, {
        transformFeedback: this.transformFeedbacks[this.currentIndex],
        uniforms: uniforms,
        discard: discard,
        framebuffer: framebuffer,
        parameters: parameters
      }));
    }
  }, {
    key: "swapBuffers",
    value: function swapBuffers() {
      _utils.log.deprecated('swapBuffers()', 'swap()')();

      this.swap();
    }
  }, {
    key: "swap",
    value: function swap() {
      (0, _utils.assert)(this.feedbackMap || this._swapTexture);
      this.currentIndex = (this.currentIndex + 1) % 2;
    }
  }, {
    key: "update",
    value: function update() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (opts.elementCount) {
        this._setElementCount(opts.elementCount);
      }

      var _opts$sourceBuffers = opts.sourceBuffers,
          sourceBuffers = _opts$sourceBuffers === void 0 ? null : _opts$sourceBuffers,
          _opts$feedbackBuffers = opts.feedbackBuffers,
          feedbackBuffers = _opts$feedbackBuffers === void 0 ? null : _opts$feedbackBuffers;
      var currentIndex = this.currentIndex;

      if (sourceBuffers || feedbackBuffers) {
        for (var bufferName in feedbackBuffers) {
          (0, _utils.assert)(feedbackBuffers[bufferName] instanceof _webgl.Buffer || feedbackBuffers[bufferName].buffer instanceof _webgl.Buffer);
        }

        Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);
        Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);

        this._createFeedbackBuffers({
          feedbackBuffers: feedbackBuffers
        });

        if (this.transformFeedbacks[currentIndex]) {
          this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]);
        }

        this._setupSwapBuffers();
      }

      var _sourceTextures = opts._sourceTextures,
          _targetTexture = opts._targetTexture;

      if (_sourceTextures || _targetTexture) {
        Object.assign(this.sourceTextures[currentIndex], _sourceTextures);

        this._updateTargetTexture(_targetTexture || this._targetRefTexName, currentIndex);

        this._setupSwapTextures();
      }
    }
  }, {
    key: "_setSourceTextureParameters",
    value: function _setSourceTextureParameters() {
      var index = this.currentIndex;

      for (var name in this.sourceTextures[index]) {
        this.sourceTextures[index][name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
      }
    }
  }, {
    key: "_setElementCount",
    value: function _setElementCount(elementCount) {
      if (this.elementCount === elementCount) {
        return;
      }

      if (this.elementCount < elementCount) {
        this._updateElementIDBuffer(elementCount);
      }

      this.model.setVertexCount(elementCount);
      this.elementCount = elementCount;
    }
  }, {
    key: "_updateTargetTexture",
    value: function _updateTargetTexture(texture, index) {
      var targetTexture = this._buildTargetTexture(texture, index);

      if (targetTexture) {
        this.targetTextures[index] = targetTexture;

        if (this.framebuffers[index]) {
          this.framebuffers[index].update({
            attachments: (0, _defineProperty2["default"])({}, 36064, this.targetTextures[index]),
            resizeAttachments: false
          });
          this.framebuffers[index].resize({
            width: targetTexture.width,
            height: targetTexture.height
          });
        }
      }
    }
  }, {
    key: "_initialize",
    value: function _initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_validateProps = this._validateProps(props),
          feedbackBuffers = _this$_validateProps.feedbackBuffers,
          feedbackMap = _this$_validateProps.feedbackMap;

      var sourceBuffers = props.sourceBuffers,
          varyings = props.varyings,
          _targetTexture = props._targetTexture,
          _targetTextureVarying = props._targetTextureVarying,
          _swapTexture = props._swapTexture;
      var varyingsArray = varyings;

      if (feedbackMap && !Array.isArray(varyings)) {
        varyingsArray = Object.values(feedbackMap);
      }

      this.varyingsArray = varyingsArray;
      this.feedbackMap = feedbackMap;
      this._swapTexture = _swapTexture;

      if (_targetTexture) {
        this.targetTextureVarying = _targetTextureVarying;
        this.renderingToTexture = true;
        (0, _utils.assert)(this.targetTextureVarying);
      }

      this._setupBuffers({
        sourceBuffers: sourceBuffers,
        feedbackBuffers: feedbackBuffers
      });

      this._setupTextures(props);

      this._setupSwapBuffers();

      this._setupSwapTextures();

      this._buildModel(Object.assign({}, props, {
        id: props.id || 'transform-model',
        drawMode: props.drawMode || 0,
        varyings: varyingsArray
      }));
    }
  }, {
    key: "_validateProps",
    value: function _validateProps(props) {
      var feedbackBuffers = props.feedbackBuffers,
          feedbackMap = props.feedbackMap;
      var destinationBuffers = props.destinationBuffers,
          sourceDestinationMap = props.sourceDestinationMap;

      if (destinationBuffers) {
        _utils.log.deprecated('destinationBuffers', 'feedbackBuffers')();

        feedbackBuffers = feedbackBuffers || destinationBuffers;
      }

      if (sourceDestinationMap) {
        _utils.log.deprecated('sourceDestinationMap', 'feedbackMap')();

        feedbackMap = feedbackMap || sourceDestinationMap;
      }

      var vs = props.vs,
          elementCount = props.elementCount,
          varyings = props.varyings;
      var _sourceTextures = props._sourceTextures,
          _targetTexture = props._targetTexture,
          _targetTextureVarying = props._targetTextureVarying,
          _swapTexture = props._swapTexture;
      (0, _utils.assert)(vs && (varyings || feedbackMap || _targetTexture) && elementCount);

      for (var bufferName in feedbackBuffers || {}) {
        (0, _utils.assert)(feedbackBuffers[bufferName] instanceof _webgl.Buffer || feedbackBuffers[bufferName].buffer instanceof _webgl.Buffer);
      }

      for (var textureName in _sourceTextures || {}) {
        (0, _utils.assert)(_sourceTextures[textureName] instanceof _webgl.Texture2D);
      }

      (0, _utils.assert)(!_targetTexture || _targetTextureVarying);
      (0, _utils.assert)(!_swapTexture || _sourceTextures[_swapTexture]);
      return {
        feedbackBuffers: feedbackBuffers,
        feedbackMap: feedbackMap
      };
    }
  }, {
    key: "_setupBuffers",
    value: function _setupBuffers(_ref2) {
      var _ref2$sourceBuffers = _ref2.sourceBuffers,
          sourceBuffers = _ref2$sourceBuffers === void 0 ? null : _ref2$sourceBuffers,
          _ref2$feedbackBuffers = _ref2.feedbackBuffers,
          feedbackBuffers = _ref2$feedbackBuffers === void 0 ? null : _ref2$feedbackBuffers;
      this.sourceBuffers[0] = Object.assign({}, sourceBuffers);
      this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);

      this._createFeedbackBuffers({
        feedbackBuffers: feedbackBuffers
      });

      this.sourceBuffers[1] = {};
      this.feedbackBuffers[1] = {};
    }
  }, {
    key: "_setupTextures",
    value: function _setupTextures() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _sourceTextures = props._sourceTextures,
          _targetTexture = props._targetTexture;
      this.sourceTextures[0] = Object.assign({}, _sourceTextures);
      this.sourceTextures[1] = {};
      this.hasSourceTextures = Object.keys(this.sourceTextures[0]).length > 0;

      if (this.targetTextureVarying) {
        var texture = this._buildTargetTexture(_targetTexture, 0);

        (0, _utils.assert)(texture);
        this.targetTextures[0] = texture;
        this.targetTextures[1] = null;
      }
    }
  }, {
    key: "_buildTargetTexture",
    value: function _buildTargetTexture(textureOrAttribute, index) {
      var _parameters;

      if (textureOrAttribute instanceof _webgl.Texture2D) {
        return textureOrAttribute;
      }

      var refTexture = this.sourceTextures[0][textureOrAttribute];

      if (!refTexture) {
        return null;
      }

      this._targetRefTexName = textureOrAttribute;
      var texture = (0, _webgl.cloneTextureFrom)(refTexture, {
        parameters: (_parameters = {}, (0, _defineProperty2["default"])(_parameters, 10241, 9728), (0, _defineProperty2["default"])(_parameters, 10240, 9728), (0, _defineProperty2["default"])(_parameters, 10242, 33071), (0, _defineProperty2["default"])(_parameters, 10243, 33071), _parameters),
        pixelStore: (0, _defineProperty2["default"])({}, 37440, false)
      });
      var resourceName = "target-texture-".concat(index);

      if (this.resources[resourceName]) {
        this.resources[resourceName]["delete"]();
      }

      this.resources[resourceName] = texture;
      return texture;
    }
  }, {
    key: "_createFeedbackBuffers",
    value: function _createFeedbackBuffers(_ref3) {
      var feedbackBuffers = _ref3.feedbackBuffers;

      if (!this.feedbackMap) {
        return;
      }

      var current = this.currentIndex;

      for (var sourceBufferName in this.feedbackMap) {
        var feedbackBufferName = this.feedbackMap[sourceBufferName];

        if (feedbackBufferName !== this.targetTextureVarying && (!feedbackBuffers || !feedbackBuffers[feedbackBufferName])) {
          var sourceBuffer = this.sourceBuffers[current][sourceBufferName];
          var byteLength = sourceBuffer.byteLength,
              usage = sourceBuffer.usage,
              accessor = sourceBuffer.accessor;

          var buffer = this._createNewBuffer(feedbackBufferName, {
            byteLength: byteLength,
            usage: usage,
            accessor: accessor
          });

          this.feedbackBuffers[current][feedbackBufferName] = buffer;
        }
      }
    }
  }, {
    key: "_createNewBuffer",
    value: function _createNewBuffer(name, opts) {
      var buffer = new _webgl.Buffer(this.gl, opts);

      if (this.resources[name]) {
        this.resources[name]["delete"]();
      }

      this.resources[name] = buffer;
      return buffer;
    }
  }, {
    key: "_setupSwapBuffers",
    value: function _setupSwapBuffers() {
      if (!this.feedbackMap) {
        return;
      }

      var current = this.currentIndex;
      var next = (current + 1) % 2;
      Object.assign(this.sourceBuffers[next], this.sourceBuffers[current]);
      Object.assign(this.feedbackBuffers[next], this.feedbackBuffers[current]);

      for (var srcName in this.feedbackMap) {
        var dstName = this.feedbackMap[srcName];

        if (dstName !== this.targetTextureVarying) {
          this.sourceBuffers[next][srcName] = this.feedbackBuffers[current][dstName];
          this.feedbackBuffers[next][dstName] = this.sourceBuffers[current][srcName];
          (0, _utils.assert)(this.feedbackBuffers[next][dstName] instanceof _webgl.Buffer);
        }
      }

      if (this.transformFeedbacks[next]) {
        this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);
      }
    }
  }, {
    key: "_setupSwapTextures",
    value: function _setupSwapTextures() {
      if (!this._swapTexture || !this.targetTextureVarying) {
        return;
      }

      var current = this.currentIndex;
      var next = (current + 1) % 2;
      Object.assign(this.sourceTextures[next], this.sourceTextures[current]);
      this.sourceTextures[next][this._swapTexture] = this.targetTextures[current];

      this._updateTargetTexture(this.sourceTextures[current][this._swapTexture], next);
    }
  }, {
    key: "_buildModel",
    value: function _buildModel() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_getShaders = this._getShaders(props),
          vs = _this$_getShaders.vs,
          fs = _this$_getShaders.fs,
          modules = _this$_getShaders.modules,
          uniforms = _this$_getShaders.uniforms,
          inject = _this$_getShaders.inject,
          samplerTextureMap = _this$_getShaders.samplerTextureMap;

      this.model = new _model["default"](this.gl, Object.assign({}, props, {
        vs: vs,
        fs: fs,
        vertexCount: props.elementCount,
        modules: modules,
        uniforms: uniforms,
        inject: inject
      }));
      this.samplerTextureMap = samplerTextureMap;

      this._setupTransformFeedback();

      this._setupFramebuffers();

      this._setElementCount(props.elementCount);
    }
  }, {
    key: "_setupTransformFeedback",
    value: function _setupTransformFeedback() {
      if ((0, _utils.isObjectEmpty)(this.feedbackBuffers[0])) {
        return;
      }

      this.transformFeedbacks[0] = new _webgl.TransformFeedback(this.gl, {
        program: this.model.program,
        buffers: this.feedbackBuffers[0]
      });

      if (this.feedbackMap) {
        this.transformFeedbacks[1] = new _webgl.TransformFeedback(this.gl, {
          program: this.model.program,
          buffers: this.feedbackBuffers[1]
        });
      }
    }
  }, {
    key: "_setupFramebuffers",
    value: function _setupFramebuffers() {
      if (!this.renderingToTexture) {
        return;
      }

      var _this$targetTextures$ = this.targetTextures[0],
          width = _this$targetTextures$.width,
          height = _this$targetTextures$.height;
      this.framebuffers[0] = new _webgl.Framebuffer(this.gl, {
        id: "".concat(this.id || 'transform', "-framebuffer-0"),
        width: width,
        height: height,
        attachments: (0, _defineProperty2["default"])({}, 36064, this.targetTextures[0])
      });

      if (this._swapTexture) {
        var _this$targetTextures$2 = this.targetTextures[1];
        width = _this$targetTextures$2.width;
        height = _this$targetTextures$2.height;
        this.framebuffers[1] = new _webgl.Framebuffer(this.gl, {
          id: "".concat(this.id || 'transform', "-framebuffer-1"),
          width: width,
          height: height,
          attachments: (0, _defineProperty2["default"])({}, 36064, this.targetTextures[1])
        });
      }
    }
  }, {
    key: "_updateElementIDBuffer",
    value: function _updateElementIDBuffer(elementCount) {
      if (!this.hasSourceTextures && !this.targetTextureVarying) {
        return;
      }

      var elementIds = new Float32Array(elementCount);
      elementIds.forEach(function (_, index, array) {
        array[index] = index;
      });

      if (!this.elementIDBuffer) {
        this.elementIDBuffer = this._createNewBuffer('elementIDBuffer', {
          data: elementIds,
          accessor: {
            size: 1
          }
        });
      } else {
        this.elementIDBuffer.setData({
          data: elementIds
        });
      }
    }
  }, {
    key: "_getShaders",
    value: function _getShaders() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_processVertexS = this._processVertexShader(props.vs),
          vs = _this$_processVertexS.vs,
          uniforms = _this$_processVertexS.uniforms,
          targetTextureType = _this$_processVertexS.targetTextureType,
          inject = _this$_processVertexS.inject,
          samplerTextureMap = _this$_processVertexS.samplerTextureMap;

      var combinedInject = (0, _shadertools.combineInjects)([props.inject || {}, inject]);
      this.targetTextureType = targetTextureType;
      var fs = props._fs || (0, _shadertools.getPassthroughFS)({
        version: (0, _webgl.getShaderVersion)(vs),
        input: this.targetTextureVarying,
        inputType: targetTextureType,
        output: FS_OUTPUT_VARIABLE
      });
      var modules = this.hasSourceTextures || this.targetTextureVarying ? [_shadertools._transform].concat(props.modules || []) : props.modules;
      return {
        vs: vs,
        fs: fs,
        modules: modules,
        uniforms: uniforms,
        inject: combinedInject,
        samplerTextureMap: samplerTextureMap
      };
    }
  }, {
    key: "_processVertexShader",
    value: function _processVertexShader(vs) {
      return (0, _transformShaderUtils.updateForTextures)({
        vs: vs,
        sourceTextureMap: this.sourceTextures[this.currentIndex],
        targetTextureVarying: this.targetTextureVarying,
        targetTexture: this.targetTextures[this.currentIndex]
      });
    }
  }]);
  return Transform;
}();

exports["default"] = Transform;

},{"../utils":281,"./model":259,"./transform-shader-utils":262,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/shadertools":282,"@luma.gl/webgl":381}],264:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointLight = exports.DirectionalLight = exports.AmbientLight = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _math = require("math.gl");

var _utils = require("../utils");

var DEFAULT_LIGHT_COLOR = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY = 1.0;
var DEFAULT_ATTENUATION = [0, 0, 1];
var DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];
var DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];

var Light = function Light() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  (0, _classCallCheck2["default"])(this, Light);
  this.id = props.id || (0, _utils.uid)('light');
  var _props$color = props.color,
      color = _props$color === void 0 ? DEFAULT_LIGHT_COLOR : _props$color;
  this.color = color;
  var _props$intensity = props.intensity,
      intensity = _props$intensity === void 0 ? DEFAULT_LIGHT_INTENSITY : _props$intensity;
  this.intensity = intensity;
};

var AmbientLight = function (_Light) {
  (0, _inherits2["default"])(AmbientLight, _Light);

  function AmbientLight() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, AmbientLight);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(AmbientLight).call(this, props));
    _this.type = 'ambient';
    return _this;
  }

  return AmbientLight;
}(Light);

exports.AmbientLight = AmbientLight;

var DirectionalLight = function (_Light2) {
  (0, _inherits2["default"])(DirectionalLight, _Light2);

  function DirectionalLight() {
    var _this2;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, DirectionalLight);
    _this2 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(DirectionalLight).call(this, props));
    _this2.type = 'directional';
    var _props$direction = props.direction,
        direction = _props$direction === void 0 ? DEFAULT_LIGHT_DIRECTION : _props$direction;
    _this2.direction = new _math.Vector3(direction).normalize().toArray();
    return _this2;
  }

  return DirectionalLight;
}(Light);

exports.DirectionalLight = DirectionalLight;

var PointLight = function (_Light3) {
  (0, _inherits2["default"])(PointLight, _Light3);

  function PointLight() {
    var _this3;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, PointLight);
    _this3 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PointLight).call(this, props));
    _this3.type = 'point';
    var _props$position = props.position,
        position = _props$position === void 0 ? DEFAULT_LIGHT_POSITION : _props$position;
    _this3.position = position;
    _this3.attenuation = _this3._getAttenuation(props);
    return _this3;
  }

  (0, _createClass2["default"])(PointLight, [{
    key: "_getAttenuation",
    value: function _getAttenuation(props) {
      if ('attenuation' in props) {
        return props.attenuation;
      }

      if ('intensity' in props) {
        return [0, 0, props.intensity];
      }

      return DEFAULT_ATTENUATION;
    }
  }]);
  return PointLight;
}(Light);

exports.PointLight = PointLight;

},{"../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"math.gl":415}],265:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var Material = function Material() {
  (0, _classCallCheck2["default"])(this, Material);
};

exports["default"] = Material;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/interopRequireDefault":25}],266:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _material = _interopRequireDefault(require("./material"));

var PBRMaterial = function (_Material) {
  (0, _inherits2["default"])(PBRMaterial, _Material);

  function PBRMaterial() {
    (0, _classCallCheck2["default"])(this, PBRMaterial);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PBRMaterial).apply(this, arguments));
  }

  return PBRMaterial;
}(_material["default"]);

exports["default"] = PBRMaterial;

},{"./material":265,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],267:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _material = _interopRequireDefault(require("./material"));

var defaultProps = {
  ambient: 0.35,
  diffuse: 0.6,
  shininess: 32,
  specularColor: [30, 30, 30]
};

var PhongMaterial = function (_Material) {
  (0, _inherits2["default"])(PhongMaterial, _Material);

  function PhongMaterial(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, PhongMaterial);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PhongMaterial).call(this, props));
    props = Object.assign({}, defaultProps, props);
    Object.assign((0, _assertThisInitialized2["default"])(_this), props);
    return _this;
  }

  return PhongMaterial;
}(_material["default"]);

exports["default"] = PhongMaterial;

},{"./material":265,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],268:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var ClearPass = function (_Pass) {
  (0, _inherits2["default"])(ClearPass, _Pass);

  function ClearPass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, ClearPass);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ClearPass).call(this, gl, Object.assign({
      id: 'clear-pass'
    }, props)));
  }

  (0, _createClass2["default"])(ClearPass, [{
    key: "_renderPass",
    value: function _renderPass() {
      var gl = this.gl;
      var _this$props$clearBits = this.props.clearBits,
          clearBits = _this$props$clearBits === void 0 ? 16384 | 256 : _this$props$clearBits;
      gl.clear(clearBits);
    }
  }]);
  return ClearPass;
}(_pass["default"]);

exports["default"] = ClearPass;

},{"./pass":272,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],269:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var CompositePass = function (_Pass) {
  (0, _inherits2["default"])(CompositePass, _Pass);

  function CompositePass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, CompositePass);
    props = Array.isArray(props) ? {
      passes: props
    } : props;
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(CompositePass).call(this, gl, Object.assign({
      id: 'composite-pass'
    }, props)));
  }

  (0, _createClass2["default"])(CompositePass, [{
    key: "render",
    value: function render() {
      var _this$props$passes = this.props.passes,
          passes = _this$props$passes === void 0 ? [] : _this$props$passes;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pass = _step.value;
          pass.render.apply(pass, arguments);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return CompositePass;
}(_pass["default"]);

exports["default"] = CompositePass;

},{"./pass":272,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],270:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _clipSpace = _interopRequireDefault(require("../lib/clip-space"));

var _pass = _interopRequireDefault(require("./pass"));

var fs = "uniform sampler2D uDiffuseSampler;\nuniform float uOpacity;\n\nvarying vec2 uv;\n\nvoid main() {\n  vec4 texel = texture2D(uDiffuseSampler, uv);\n  gl_FragColor = uOpacity * texel;\n}\n";

var CopyPass = function (_Pass) {
  (0, _inherits2["default"])(CopyPass, _Pass);

  function CopyPass(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, CopyPass);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(CopyPass).call(this, gl, Object.assign({
      id: 'copy-pass',
      swap: true
    }, props)));
    _this.clipspace = new _clipSpace["default"](gl, {
      id: 'copy-pass',
      fs: fs
    });
    return _this;
  }

  (0, _createClass2["default"])(CopyPass, [{
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var inputBuffer = _ref.inputBuffer;
      var _this$props$opacity = this.props.opacity,
          opacity = _this$props$opacity === void 0 ? 1.0 : _this$props$opacity;
      this.clipspace.draw({
        uniforms: {
          uDiffuseSampler: inputBuffer,
          uOpacity: opacity
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return CopyPass;
}(_pass["default"]);

exports["default"] = CopyPass;

},{"../lib/clip-space":257,"./pass":272,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],271:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _compositePass = _interopRequireDefault(require("./composite-pass"));

var _renderState = _interopRequireDefault(require("./render-state"));

var MultiPassRenderer = function (_CompositePass) {
  (0, _inherits2["default"])(MultiPassRenderer, _CompositePass);

  function MultiPassRenderer(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, MultiPassRenderer);
    props = Array.isArray(props) ? {
      passes: props
    } : props;
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(MultiPassRenderer).call(this, gl, Object.assign({
      id: 'multi-pass'
    }, props)));
    _this.renderState = new _renderState["default"](gl, props);
    return _this;
  }

  (0, _createClass2["default"])(MultiPassRenderer, [{
    key: "render",
    value: function render(animationProps) {
      this.renderState.reset();
      var _this$props$passes = this.props.passes,
          passes = _this$props$passes === void 0 ? [] : _this$props$passes;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pass = _step.value;
          pass.render(this.renderState, animationProps);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return this;
    }
  }]);
  return MultiPassRenderer;
}(_compositePass["default"]);

exports["default"] = MultiPassRenderer;

},{"./composite-pass":269,"./render-state":274,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],272:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webgl = require("@luma.gl/webgl");

var Pass = function () {
  function Pass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Pass);
    var _props$id = props.id,
        id = _props$id === void 0 ? 'pass' : _props$id;
    this.id = id;
    this.gl = gl;
    this.props = {
      enabled: true,
      screen: false,
      swap: false
    };
    Object.assign(this.props, props);
  }

  (0, _createClass2["default"])(Pass, [{
    key: "setProps",
    value: function setProps(props) {
      Object.assign(this.props, props);
    }
  }, {
    key: "render",
    value: function render(renderState, animationProps) {
      var _this = this;

      if (!this.props.enabled) {
        return;
      }

      var gl = this.gl;
      var renderParams = {
        gl: gl,
        outputBuffer: renderState.writeBuffer,
        inputBuffer: renderState.readBuffer,
        animationProps: animationProps,
        swapBuffers: function swapBuffers() {
          return renderState._swapFramebuffers();
        }
      };

      if (this.props.screen) {
        renderParams.inputBuffer = renderParams.outputBuffer;
        renderParams.outputBuffer = _webgl.Framebuffer.getDefaultFramebuffer(gl);
      } else if (this.props.swap) {
        renderParams.inputBuffer = renderState.writeBuffer;
        renderParams.outputBuffer = renderState.readBuffer;
      }

      (0, _webgl.withParameters)(gl, {
        framebuffer: renderParams.outputBuffer
      }, function () {
        return _this._renderPass(renderParams);
      });

      if (this.props.debug) {
        renderParams.outputBuffer.log(1, this.id);
      }

      if (this.props.swap) {
        renderState._swapFramebuffers();
      }
    }
  }, {
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var gl = _ref.gl,
          inputBuffer = _ref.inputBuffer,
          outputBuffer = _ref.outputBuffer,
          animationProps = _ref.animationProps;
    }
  }]);
  return Pass;
}();

exports["default"] = Pass;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/webgl":381}],273:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var RenderPass = function (_Pass) {
  (0, _inherits2["default"])(RenderPass, _Pass);

  function RenderPass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, RenderPass);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(RenderPass).call(this, gl, Object.assign({
      id: 'render-pass'
    }, props)));
  }

  (0, _createClass2["default"])(RenderPass, [{
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var animationProps = _ref.animationProps;
      var _this$props = this.props,
          _this$props$models = _this$props.models,
          models = _this$props$models === void 0 ? [] : _this$props$models,
          drawParams = _this$props.drawParams;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = models[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var model = _step.value;
          model.draw(Object.assign({}, drawParams, {
            animationProps: animationProps
          }));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return RenderPass;
}(_pass["default"]);

exports["default"] = RenderPass;

},{"./pass":272,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],274:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webgl = require("@luma.gl/webgl");

var RenderState = function () {
  function RenderState(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, RenderState);
    this.gl = gl;
    this.framebuffer1 = new _webgl.Framebuffer(gl, {
      id: 'multi-pass-1',
      stencil: true
    });
    this.framebuffer2 = new _webgl.Framebuffer(gl, {
      id: 'multi-pass-2',
      stencil: true
    });
    this.reset();
  }

  (0, _createClass2["default"])(RenderState, [{
    key: "reset",
    value: function reset() {
      this.framebuffer1.resize();
      this.framebuffer2.resize();
      this.writeBuffer = this.framebuffer1;
      this.readBuffer = this.framebuffer2;
      this.maskActive = false;
    }
  }, {
    key: "_swapFramebuffers",
    value: function _swapFramebuffers() {
      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;
    }
  }]);
  return RenderState;
}();

exports["default"] = RenderState;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/webgl":381}],275:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var _compositePass = _interopRequireDefault(require("./composite-pass"));

var _clipSpace = _interopRequireDefault(require("../lib/clip-space"));

var _shadertools = require("@luma.gl/shadertools");

var ShaderModuleSinglePass = function (_Pass) {
  (0, _inherits2["default"])(ShaderModuleSinglePass, _Pass);

  function ShaderModuleSinglePass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, ShaderModuleSinglePass);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ShaderModuleSinglePass).call(this, gl, Object.assign({
      swap: true
    }, props)));
  }

  (0, _createClass2["default"])(ShaderModuleSinglePass, [{
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var inputBuffer = _ref.inputBuffer,
          swapBuffers = _ref.swapBuffers;
      this.props.model.setUniforms(this.props);
      this.props.model.draw({
        uniforms: {
          texture: inputBuffer,
          texSize: [inputBuffer.width, inputBuffer.height]
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return ShaderModuleSinglePass;
}(_pass["default"]);

var ShaderModulePass = function (_CompositePass) {
  (0, _inherits2["default"])(ShaderModulePass, _CompositePass);

  function ShaderModulePass(gl, module) {
    var _this;

    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, ShaderModulePass);
    var id = "".concat(module.name, "-pass");
    (0, _shadertools.normalizeShaderModule)(module);
    var passes = normalizePasses(gl, module, id, props);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ShaderModulePass).call(this, gl, Object.assign({
      id: id,
      passes: passes
    }, props)));
    _this.module = module;
    return _this;
  }

  (0, _createClass2["default"])(ShaderModulePass, [{
    key: "_renderPass",
    value: function _renderPass(_ref2) {
      var inputBuffer = _ref2.inputBuffer,
          swapBuffers = _ref2.swapBuffers;
      var first = true;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.props.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pass = _step.value;

          if (!first) {
            swapBuffers();
          }

          first = false;
          var _pass$props = pass.props,
              uniforms = _pass$props.uniforms,
              model = _pass$props.model;

          if (uniforms) {
            model.setUniforms(uniforms);
          }

          model.draw({
            uniforms: {
              texture: inputBuffer,
              texSize: [inputBuffer.width, inputBuffer.height]
            },
            parameters: {
              depthWrite: false,
              depthTest: false
            }
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ShaderModulePass;
}(_compositePass["default"]);

exports["default"] = ShaderModulePass;

function normalizePasses(gl, module, id, props) {
  if (module.filter || module.sampler) {
    var fs = getFragmentShaderForRenderPass(module);
    var pass = new ShaderModuleSinglePass(gl, {
      id: id,
      model: getModel(gl, module, fs, id, props),
      uniforms: null
    });
    return [pass];
  }

  var passes = module.passes || [];
  return passes.map(function (pass) {
    var fs = getFragmentShaderForRenderPass(module, pass);
    var idn = "".concat(id, "-").concat(passes.length + 1);
    return new ShaderModuleSinglePass(gl, Object.assign({
      id: idn,
      model: getModel(gl, module, fs, idn, props),
      uniforms: pass.uniforms
    }, props));
  });
}

function getModel(gl, module, fs, id, props) {
  var model = new _clipSpace["default"](gl, {
    id: id,
    fs: fs,
    modules: [module]
  });
  var uniforms = Object.assign(module.getUniforms(), module.getUniforms(props));
  model.setUniforms(uniforms);
  return model;
}

var FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
};

var SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
};

function getFragmentShaderForRenderPass(module) {
  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;

  if (pass.filter) {
    var func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }

  if (pass.sampler) {
    var _func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");

    return SAMPLER_FS_TEMPLATE(_func);
  }

  return null;
}

},{"../lib/clip-space":257,"./composite-pass":269,"./pass":272,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@luma.gl/shadertools":282}],276:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _clipSpace = _interopRequireDefault(require("../lib/clip-space"));

var _pass = _interopRequireDefault(require("./pass"));

var fs = "uniform sampler2D uDiffuseSampler;\nuniform float uOpacity;\nvarying vec2 uv;\n\nvoid main() {\n  vec4 texel = texture2D(uDiffuseSampler, uv);\n  gl_FragColor = uOpacity * texel;\n}\n";

var TexturePass = function (_Pass) {
  (0, _inherits2["default"])(TexturePass, _Pass);

  function TexturePass(gl) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, TexturePass);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(TexturePass).call(this, gl, Object.assign({
      id: 'texture-pass'
    }, options)));
    var texture = options.texture,
        _options$opacity = options.opacity,
        opacity = _options$opacity === void 0 ? 1.0 : _options$opacity;
    _this.clipspace = new _clipSpace["default"](gl, {
      id: 'texture-pass',
      fs: fs,
      uniforms: {
        uDiffuseSampler: texture,
        uOpacity: opacity
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(TexturePass, [{
    key: "_renderPass",
    value: function _renderPass() {
      this.clipspace.draw({
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return TexturePass;
}(_pass["default"]);

exports["default"] = TexturePass;

},{"../lib/clip-space":257,"./pass":272,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],277:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _scenegraphNode = _interopRequireDefault(require("./scenegraph-node"));

var CameraNode = function (_ScenegraphNode) {
  (0, _inherits2["default"])(CameraNode, _ScenegraphNode);

  function CameraNode() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, CameraNode);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(CameraNode).call(this, props));
    _this.projectionMatrix = props.projectionMatrix;
    return _this;
  }

  return CameraNode;
}(_scenegraphNode["default"]);

exports["default"] = CameraNode;

},{"./scenegraph-node":280,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],278:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _math = require("math.gl");

var _utils = require("../../utils");

var _scenegraphNode = _interopRequireDefault(require("./scenegraph-node"));

var GroupNode = function (_ScenegraphNode) {
  (0, _inherits2["default"])(GroupNode, _ScenegraphNode);

  function GroupNode() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, GroupNode);
    props = Array.isArray(props) ? {
      children: props
    } : props;
    var _props = props,
        _props$children = _props.children,
        children = _props$children === void 0 ? [] : _props$children;

    _utils.log.assert(children.every(function (child) {
      return child instanceof _scenegraphNode["default"];
    }), 'every child must an instance of ScenegraphNode');

    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(GroupNode).call(this, props));
    _this.children = children;
    return _this;
  }

  (0, _createClass2["default"])(GroupNode, [{
    key: "add",
    value: function add() {
      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
        children[_key] = arguments[_key];
      }

      for (var _i = 0, _children = children; _i < _children.length; _i++) {
        var child = _children[_i];

        if (Array.isArray(child)) {
          this.add.apply(this, (0, _toConsumableArray2["default"])(child));
        } else {
          this.children.push(child);
        }
      }

      return this;
    }
  }, {
    key: "remove",
    value: function remove(child) {
      var children = this.children;
      var indexOf = children.indexOf(child);

      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }

      return this;
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      this.children = [];
      return this;
    }
  }, {
    key: "delete",
    value: function _delete() {
      this.children.forEach(function (child) {
        return child["delete"]();
      });
      this.removeAll();
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(GroupNode.prototype), "delete", this).call(this);
    }
  }, {
    key: "traverse",
    value: function traverse(visitor) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$worldMatrix = _ref.worldMatrix,
          worldMatrix = _ref$worldMatrix === void 0 ? new _math.Matrix4() : _ref$worldMatrix;

      var modelMatrix = new _math.Matrix4(worldMatrix).multiplyRight(this.matrix);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;

          if (child instanceof GroupNode) {
            child.traverse(visitor, {
              worldMatrix: modelMatrix
            });
          } else {
            visitor(child, {
              worldMatrix: modelMatrix
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "traverseReverse",
    value: function traverseReverse(visitor, opts) {
      _utils.log.warn('traverseReverse is not reverse')();

      return this.traverse(visitor, opts);
    }
  }]);
  return GroupNode;
}(_scenegraphNode["default"]);

exports["default"] = GroupNode;

},{"../../utils":281,"./scenegraph-node":280,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/toConsumableArray":39,"math.gl":415}],279:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _model = _interopRequireDefault(require("../../lib/model"));

var _scenegraphNode = _interopRequireDefault(require("./scenegraph-node"));

var ModelNode = function (_ScenegraphNode) {
  (0, _inherits2["default"])(ModelNode, _ScenegraphNode);

  function ModelNode(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, ModelNode);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ModelNode).call(this, props));
    _this.onBeforeRender = null;
    _this.AfterRender = null;

    if (gl instanceof _model["default"]) {
      _this.model = gl;

      _this._setModelNodeProps(props);
    } else {
      _this.model = new _model["default"](gl, props);
    }

    _this.managedResources = props.managedResources || [];
    return _this;
  }

  (0, _createClass2["default"])(ModelNode, [{
    key: "setProps",
    value: function setProps(props) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(ModelNode.prototype), "setProps", this).call(this, props);

      this._setModelNodeProps(props);

      return this;
    }
  }, {
    key: "delete",
    value: function _delete() {
      if (this.model) {
        this.model["delete"]();
        this.model = null;
      }

      this.managedResources.forEach(function (resource) {
        return resource["delete"]();
      });
      this.managedResources = [];
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this$model;

      return (_this$model = this.model).draw.apply(_this$model, arguments);
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var _this$model2;

      (_this$model2 = this.model).setUniforms.apply(_this$model2, arguments);

      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes() {
      var _this$model3;

      (_this$model3 = this.model).setAttributes.apply(_this$model3, arguments);

      return this;
    }
  }, {
    key: "updateModuleSettings",
    value: function updateModuleSettings() {
      var _this$model4;

      (_this$model4 = this.model).updateModuleSettings.apply(_this$model4, arguments);

      return this;
    }
  }, {
    key: "_setModelNodeProps",
    value: function _setModelNodeProps(props) {
      this.model.setProps(props);
    }
  }]);
  return ModelNode;
}(_scenegraphNode["default"]);

exports["default"] = ModelNode;

},{"../../lib/model":259,"./scenegraph-node":280,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],280:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _math = require("math.gl");

var _utils = require("../../utils");

var ScenegraphNode = function () {
  function ScenegraphNode() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, ScenegraphNode);
    var id = props.id;
    this.id = id || (0, _utils.uid)(this.constructor.name);
    this.display = true;
    this.position = new _math.Vector3();
    this.rotation = new _math.Vector3();
    this.scale = new _math.Vector3(1, 1, 1);
    this.matrix = new _math.Matrix4();
    this.userData = {};
    this.props = {};

    this._setScenegraphNodeProps(props);
  }

  (0, _createClass2["default"])(ScenegraphNode, [{
    key: "delete",
    value: function _delete() {}
  }, {
    key: "setProps",
    value: function setProps(props) {
      this._setScenegraphNodeProps(props);

      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
    }
  }, {
    key: "setPosition",
    value: function setPosition(position) {
      (0, _utils.assert)(position.length === 3, 'setPosition requires vector argument');
      this.position = position;
      return this;
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      (0, _utils.assert)(rotation.length === 3, 'setRotation requires vector argument');
      this.rotation = rotation;
      return this;
    }
  }, {
    key: "setScale",
    value: function setScale(scale) {
      (0, _utils.assert)(scale.length === 3, 'setScale requires vector argument');
      this.scale = scale;
      return this;
    }
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix) {
      var copyMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (copyMatrix) {
        this.matrix.copy(matrix);
      } else {
        this.matrix = matrix;
      }
    }
  }, {
    key: "setMatrixComponents",
    value: function setMatrixComponents(_ref) {
      var position = _ref.position,
          rotation = _ref.rotation,
          scale = _ref.scale,
          _ref$update = _ref.update,
          update = _ref$update === void 0 ? true : _ref$update;

      if (position) {
        this.setPosition(position);
      }

      if (rotation) {
        this.setRotation(rotation);
      }

      if (scale) {
        this.setScale(scale);
      }

      if (update) {
        this.updateMatrix();
      }

      return this;
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      var pos = this.position;
      var rot = this.rotation;
      var scale = this.scale;
      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale);
      return this;
    }
  }, {
    key: "update",
    value: function update() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          position = _ref2.position,
          rotation = _ref2.rotation,
          scale = _ref2.scale;

      if (position) {
        this.setPosition(position);
      }

      if (rotation) {
        this.setRotation(rotation);
      }

      if (scale) {
        this.setScale(scale);
      }

      this.updateMatrix();
      return this;
    }
  }, {
    key: "getCoordinateUniforms",
    value: function getCoordinateUniforms(viewMatrix, modelMatrix) {
      (0, _utils.assert)(viewMatrix);
      modelMatrix = modelMatrix || this.matrix;
      var worldMatrix = new _math.Matrix4(viewMatrix).multiplyRight(modelMatrix);
      var worldInverse = worldMatrix.invert();
      var worldInverseTranspose = worldInverse.transpose();
      return {
        viewMatrix: viewMatrix,
        modelMatrix: modelMatrix,
        objectMatrix: modelMatrix,
        worldMatrix: worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }
  }, {
    key: "_setScenegraphNodeProps",
    value: function _setScenegraphNodeProps(props) {
      if ('display' in props) {
        this.display = props.display;
      }

      if ('position' in props) {
        this.setPosition(props.position);
      }

      if ('rotation' in props) {
        this.setRotation(props.rotation);
      }

      if ('scale' in props) {
        this.setScale(props.scale);
      }

      if ('matrix' in props) {
        this.setMatrix(props.matrix);
      }

      Object.assign(this.props, props);
    }
  }]);
  return ScenegraphNode;
}();

exports["default"] = ScenegraphNode;

},{"../../utils":281,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"math.gl":415}],281:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _webgl.assert;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return _webgl.log;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function get() {
    return _webgl.uid;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function get() {
    return _webgl.isObjectEmpty;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _webgl.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _webgl.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _webgl.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _webgl.document;
  }
});

var _webgl = require("@luma.gl/webgl");

},{"@luma.gl/webgl":381}],282:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  MODULAR_SHADERS: true,
  registerShaderModules: true,
  setDefaultShaderModules: true,
  getDefaultShaderModules: true,
  assembleShaders: true,
  createShaderHook: true,
  createModuleInjection: true,
  combineInjects: true,
  normalizeShaderModule: true,
  getQualifierDetails: true,
  getPassthroughFS: true,
  typeToChannelSuffix: true,
  typeToChannelCount: true,
  convertToVec4: true
};
Object.defineProperty(exports, "registerShaderModules", {
  enumerable: true,
  get: function get() {
    return _resolveModules.registerShaderModules;
  }
});
Object.defineProperty(exports, "setDefaultShaderModules", {
  enumerable: true,
  get: function get() {
    return _resolveModules.setDefaultShaderModules;
  }
});
Object.defineProperty(exports, "getDefaultShaderModules", {
  enumerable: true,
  get: function get() {
    return _resolveModules.getDefaultShaderModules;
  }
});
Object.defineProperty(exports, "assembleShaders", {
  enumerable: true,
  get: function get() {
    return _assembleShaders.assembleShaders;
  }
});
Object.defineProperty(exports, "createShaderHook", {
  enumerable: true,
  get: function get() {
    return _assembleShaders.createShaderHook;
  }
});
Object.defineProperty(exports, "createModuleInjection", {
  enumerable: true,
  get: function get() {
    return _assembleShaders.createModuleInjection;
  }
});
Object.defineProperty(exports, "combineInjects", {
  enumerable: true,
  get: function get() {
    return _injectShader.combineInjects;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function get() {
    return _shaderModule.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "getQualifierDetails", {
  enumerable: true,
  get: function get() {
    return _shaderUtils.getQualifierDetails;
  }
});
Object.defineProperty(exports, "getPassthroughFS", {
  enumerable: true,
  get: function get() {
    return _shaderUtils.getPassthroughFS;
  }
});
Object.defineProperty(exports, "typeToChannelSuffix", {
  enumerable: true,
  get: function get() {
    return _shaderUtils.typeToChannelSuffix;
  }
});
Object.defineProperty(exports, "typeToChannelCount", {
  enumerable: true,
  get: function get() {
    return _shaderUtils.typeToChannelCount;
  }
});
Object.defineProperty(exports, "convertToVec4", {
  enumerable: true,
  get: function get() {
    return _shaderUtils.convertToVec4;
  }
});
exports.MODULAR_SHADERS = void 0;

var _modularVertex = _interopRequireDefault(require("./shaders/modular-vertex.glsl"));

var _modularFragment = _interopRequireDefault(require("./shaders/modular-fragment.glsl"));

var _resolveModules = require("./lib/resolve-modules");

var _assembleShaders = require("./lib/assemble-shaders");

var _injectShader = require("./lib/inject-shader");

var _shaderModule = require("./lib/shader-module");

var _shaderUtils = require("./utils/shader-utils");

var _modules = require("./modules");

Object.keys(_modules).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _modules[key];
    }
  });
});
var MODULAR_SHADERS = {
  vs: _modularVertex["default"],
  fs: _modularFragment["default"],
  uniforms: {}
};
exports.MODULAR_SHADERS = MODULAR_SHADERS;

},{"./lib/assemble-shaders":283,"./lib/inject-shader":286,"./lib/resolve-modules":288,"./lib/shader-module":290,"./modules":300,"./shaders/modular-fragment.glsl":314,"./shaders/modular-vertex.glsl":315,"./utils/shader-utils":319,"@babel/runtime/helpers/interopRequireDefault":25}],283:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createShaderHook = createShaderHook;
exports.createModuleInjection = createModuleInjection;
exports.assembleShaders = assembleShaders;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("./constants");

var _resolveModules = require("./resolve-modules");

var _platformDefines = require("./platform-defines");

var _injectShader = _interopRequireWildcard(require("./inject-shader"));

var _utils = require("../utils");

var _SHADER_TYPE, _HOOK_FUNCTIONS;

var INJECT_SHADER_DECLARATIONS = "\n\n".concat(_injectShader.DECLARATION_INJECT_MARKER, "\n\n");
var SHADER_TYPE = (_SHADER_TYPE = {}, (0, _defineProperty2["default"])(_SHADER_TYPE, _constants.VERTEX_SHADER, 'vertex'), (0, _defineProperty2["default"])(_SHADER_TYPE, _constants.FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE);
var HOOK_FUNCTIONS = (_HOOK_FUNCTIONS = {}, (0, _defineProperty2["default"])(_HOOK_FUNCTIONS, _constants.VERTEX_SHADER, {}), (0, _defineProperty2["default"])(_HOOK_FUNCTIONS, _constants.FRAGMENT_SHADER, {}), _HOOK_FUNCTIONS);
var MODULE_INJECTIONS = {};
var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";

function createShaderHook(hook) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  hook = hook.trim();

  var _hook$split = hook.split(':'),
      _hook$split2 = (0, _slicedToArray2["default"])(_hook$split, 2),
      stage = _hook$split2[0],
      signature = _hook$split2[1];

  var name = hook.replace(/\(.+/, '');
  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {
    signature: signature
  });
}

function createModuleInjection(moduleName, opts) {
  var hook = opts.hook,
      injection = opts.injection,
      _opts$order = opts.order,
      order = _opts$order === void 0 ? 0 : _opts$order;
  var shaderStage = hook.slice(0, 2);
  MODULE_INJECTIONS[moduleName] = MODULE_INJECTIONS[moduleName] || {};
  MODULE_INJECTIONS[moduleName][shaderStage] = MODULE_INJECTIONS[moduleName][shaderStage] || {};
  (0, _utils.assert)(!MODULE_INJECTIONS[moduleName][shaderStage][hook], 'Module injection already created');
  MODULE_INJECTIONS[moduleName][shaderStage][hook] = {
    injection: injection,
    order: order
  };
}

function assembleShaders(gl, opts) {
  var vs = opts.vs,
      fs = opts.fs;
  var modules = (0, _resolveModules.resolveModules)(opts.modules || []);
  return {
    gl: gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs,
      type: _constants.VERTEX_SHADER,
      modules: modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs,
      type: _constants.FRAGMENT_SHADER,
      modules: modules
    })),
    getUniforms: assembleGetUniforms(modules),
    modules: assembleModuleMap(modules)
  };
}

function assembleShader(gl, _ref) {
  var id = _ref.id,
      source = _ref.source,
      type = _ref.type,
      modules = _ref.modules,
      _ref$defines = _ref.defines,
      defines = _ref$defines === void 0 ? {} : _ref$defines,
      _ref$inject = _ref.inject,
      inject = _ref$inject === void 0 ? {} : _ref$inject,
      _ref$prologue = _ref.prologue,
      prologue = _ref$prologue === void 0 ? true : _ref$prologue,
      log = _ref.log;
  (0, _utils.assert)(typeof source === 'string', 'shader source must be a string');
  var isVertex = type === _constants.VERTEX_SHADER;
  var sourceLines = source.split('\n');
  var glslVersion = 100;
  var versionLine = '';
  var coreSource = source;

  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  }

  var allDefines = {};
  modules.forEach(function (module) {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  var assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName({
    id: id,
    source: source,
    type: type
  }), "\n").concat(getShaderType({
    type: type
  }), "\n").concat((0, _platformDefines.getPlatformShaderDefines)(gl), "\n").concat((0, _platformDefines.getVersionDefines)(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  var injectStandardStubs = false;
  var hookInjections = {};
  var mainInjections = {};

  for (var key in inject) {
    var injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];

    if (key.match(/^(v|f)s:/)) {
      if (key[3] === '#') {
        mainInjections[key] = [injection];
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var module = _step.value;

      switch (module.name) {
        case 'inject':
          injectStandardStubs = true;
          break;

        default:
          if (log) {
            module.checkDeprecations(coreSource, log);
          }

          var moduleSource = module.getModuleSource(type, glslVersion);
          assembledSource += moduleSource;

          if (MODULE_INJECTIONS[module.name]) {
            var injections = MODULE_INJECTIONS[module.name][type];

            for (var _key in injections) {
              if (_key.match(/^(v|f)s:#/)) {
                mainInjections[_key] = mainInjections[_key] || [];

                mainInjections[_key].push(injections[_key]);
              } else {
                hookInjections[_key] = hookInjections[_key] || [];

                hookInjections[_key].push(injections[_key]);
              }
            }
          }

      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource += getHookFunctions(type, hookInjections);
  assembledSource += coreSource;
  assembledSource = (0, _injectShader["default"])(assembledSource, type, mainInjections, injectStandardStubs);
  return assembledSource;
}

function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    var uniforms = {};
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var module = _step2.value;
        var moduleUniforms = module.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return uniforms;
  };
}

function assembleModuleMap(modules) {
  var result = {};
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var moduleName = _step3.value;
      var shaderModule = (0, _resolveModules.getShaderModule)(moduleName);
      result[moduleName] = shaderModule;
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return result;
}

function getShaderType(_ref2) {
  var type = _ref2.type;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}

function getShaderName(_ref3) {
  var id = _ref3.id,
      source = _ref3.source,
      type = _ref3.type;
  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : '';
}

function getApplicationDefines() {
  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var count = 0;
  var sourceText = '';

  for (var define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }

    count++;
    var value = defines[define];

    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
  }

  if (count === 0) {
    sourceText += '\n';
  }

  return sourceText;
}

function getHookFunctions(shaderStage, hookInjections) {
  var result = '';
  var hookFunctions = HOOK_FUNCTIONS[shaderStage];

  for (var hookName in hookFunctions) {
    var hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");

    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }

    if (hookInjections[hookName]) {
      var injections = hookInjections[hookName];
      injections.sort(function (a, b) {
        return a.order - b.order;
      });
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = injections[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var injection = _step4.value;
          result += "  ".concat(injection.injection, "\n");
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }

    result += '}\n';
  }

  return result;
}

},{"../utils":317,"./constants":284,"./inject-shader":286,"./platform-defines":287,"./resolve-modules":288,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/slicedToArray":37}],284:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FRAGMENT_SHADER = exports.VERTEX_SHADER = void 0;
var VERTEX_SHADER = 'vs';
exports.VERTEX_SHADER = VERTEX_SHADER;
var FRAGMENT_SHADER = 'fs';
exports.FRAGMENT_SHADER = FRAGMENT_SHADER;

},{}],285:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var TYPE_DEFINITIONS = {
  number: {
    validate: function validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  },
  array: {
    validate: function validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};

function parsePropTypes(propDefs) {
  var propTypes = {};

  for (var propName in propDefs) {
    var propDef = propDefs[propName];
    var propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }

  return propTypes;
}

function parsePropType(propDef) {
  var type = getTypeOf(propDef);

  if (type === 'object') {
    if (!propDef) {
      return {
        type: 'object',
        value: null
      };
    }

    if ('type' in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }

    if (!('value' in propDef)) {
      return {
        type: 'object',
        value: propDef
      };
    }

    type = getTypeOf(propDef.value);
    return Object.assign({
      type: type
    }, propDef, TYPE_DEFINITIONS[type]);
  }

  return Object.assign({
    type: type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}

function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }

  return (0, _typeof2["default"])(value);
}

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40}],286:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = injectShader;
exports.combineInjects = combineInjects;
exports.DECLARATION_INJECT_MARKER = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _moduleInjectors = require("../modules/module-injectors");

var _constants = require("./constants");

var _utils = require("../utils");

var _MODULE_INJECTORS;

var MODULE_INJECTORS = (_MODULE_INJECTORS = {}, (0, _defineProperty2["default"])(_MODULE_INJECTORS, _constants.VERTEX_SHADER, _moduleInjectors.MODULE_INJECTORS_VS), (0, _defineProperty2["default"])(_MODULE_INJECTORS, _constants.FRAGMENT_SHADER, _moduleInjectors.MODULE_INJECTORS_FS), _MODULE_INJECTORS);
var DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
exports.DECLARATION_INJECT_MARKER = DECLARATION_INJECT_MARKER;
var REGEX_START_OF_MAIN = /void main\s*\([^)]*\)\s*\{\n?/;
var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
var fragments = [];

function injectShader(source, type, inject, injectStandardStubs) {
  var isVertex = type === _constants.VERTEX_SHADER;

  var _loop = function _loop(key) {
    var fragmentData = inject[key];
    fragmentData.sort(function (a, b) {
      return a.order - b.order;
    });
    fragments.length = fragmentData.length;

    for (var i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }

    var fragmentString = "".concat(fragments.join('\n'), "\n");

    switch (key) {
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }

        break;

      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, function (match) {
            return match + fragmentString;
          });
        }

        break;

      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, function (match) {
            return fragmentString + match;
          });
        }

        break;

      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }

        break;

      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, function (match) {
            return match + fragmentString;
          });
        }

        break;

      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, function (match) {
            return fragmentString + match;
          });
        }

        break;

      default:
        source = source.replace(key, function (match) {
          return match + fragmentString;
        });
    }
  };

  for (var key in inject) {
    _loop(key);
  }

  source = source.replace(DECLARATION_INJECT_MARKER, '');

  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, function (match) {
      return match + MODULE_INJECTORS[type];
    });
  }

  return source;
}

function combineInjects(injects) {
  var result = {};
  (0, _utils.assert)(Array.isArray(injects) && injects.length > 1);
  injects.forEach(function (inject) {
    for (var key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}

},{"../modules/module-injectors":303,"../utils":317,"./constants":284,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],287:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPlatformShaderDefines = getPlatformShaderDefines;
exports.getVersionDefines = getVersionDefines;

var _webglInfo = require("../utils/webgl-info");

function getPlatformShaderDefines(gl) {
  var debugInfo = (0, _webglInfo.getContextInfo)(gl);

  switch (debugInfo.gpuVendor.toLowerCase()) {
    case 'nvidia':
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";

    case 'intel':
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";

    case 'amd':
      return "#define AMD_GPU\n";

    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}

function getVersionDefines(gl, glslVersion, isFragment) {
  var versionDefines = "#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DEPTH)) {
    versionDefines += "// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES)) {
    versionDefines += "// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n";
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA, {
    behavior: 'require'
  })) {
    versionDefines += "// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n";
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n";
  }

  return versionDefines;
}

},{"../utils/webgl-info":320}],288:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setDefaultShaderModules = setDefaultShaderModules;
exports.getDefaultShaderModules = getDefaultShaderModules;
exports.registerShaderModules = registerShaderModules;
exports.resolveModules = resolveModules;
exports.getShaderModule = getShaderModule;
exports.TEST_EXPORTS = void 0;

var _shaderModuleRegistry = _interopRequireDefault(require("./shader-module-registry"));

var shaderModuleRegistry = new _shaderModuleRegistry["default"]();

function setDefaultShaderModules(modules) {
  shaderModuleRegistry.setDefaultShaderModules(modules);
}

function getDefaultShaderModules() {
  return shaderModuleRegistry.getDefaultShaderModules();
}

function registerShaderModules(shaderModuleList) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$ignoreMultipleRe = _ref.ignoreMultipleRegistrations,
      ignoreMultipleRegistrations = _ref$ignoreMultipleRe === void 0 ? false : _ref$ignoreMultipleRe;

  shaderModuleRegistry.registerShaderModules(shaderModuleList, {
    ignoreMultipleRegistrations: ignoreMultipleRegistrations
  });
}

function resolveModules(modules) {
  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);
  modules = shaderModuleRegistry.resolveModules(modules);
  return getShaderDependencies(modules);
}

function getShaderModule(moduleOrName) {
  return shaderModuleRegistry.getShaderModule(moduleOrName);
}

function getShaderDependencies(modules) {
  var moduleMap = {};
  var moduleDepth = {};
  getDependencyGraph({
    modules: modules,
    level: 0,
    moduleMap: moduleMap,
    moduleDepth: moduleDepth
  });
  return Object.keys(moduleDepth).sort(function (a, b) {
    return moduleDepth[b] - moduleDepth[a];
  }).map(function (name) {
    return moduleMap[name];
  });
}

function getDependencyGraph(_ref2) {
  var modules = _ref2.modules,
      level = _ref2.level,
      moduleMap = _ref2.moduleMap,
      moduleDepth = _ref2.moduleDepth;

  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var module = _step.value;
      moduleMap[module.name] = module;

      if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
        moduleDepth[module.name] = level;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _module = _step2.value;

      if (_module.dependencies) {
        getDependencyGraph({
          modules: _module.dependencies,
          level: level + 1,
          moduleMap: moduleMap,
          moduleDepth: moduleDepth
        });
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

var TEST_EXPORTS = {
  getShaderDependencies: getShaderDependencies,
  getDependencyGraph: getDependencyGraph
};
exports.TEST_EXPORTS = TEST_EXPORTS;

},{"./shader-module-registry":289,"@babel/runtime/helpers/interopRequireDefault":25}],289:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _shaderModule = _interopRequireDefault(require("./shader-module"));

var _utils = require("../utils");

var ShaderModuleRegistry = function () {
  function ShaderModuleRegistry() {
    (0, _classCallCheck2["default"])(this, ShaderModuleRegistry);
    this.shaderModules = {};
    this.defaultShaderModules = [];
  }

  (0, _createClass2["default"])(ShaderModuleRegistry, [{
    key: "setDefaultShaderModules",
    value: function setDefaultShaderModules(modules) {
      this.defaultShaderModules = this.resolveModules(modules);
    }
  }, {
    key: "getDefaultShaderModules",
    value: function getDefaultShaderModules() {
      return this.defaultShaderModules;
    }
  }, {
    key: "registerShaderModules",
    value: function registerShaderModules(shaderModuleList) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$ignoreMultipleRe = _ref.ignoreMultipleRegistrations,
          ignoreMultipleRegistrations = _ref$ignoreMultipleRe === void 0 ? false : _ref$ignoreMultipleRe;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = shaderModuleList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var shaderModule = _step.value;

          this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "getShaderModule",
    value: function getShaderModule(moduleOrName) {
      if (moduleOrName instanceof _shaderModule["default"]) {
        return moduleOrName;
      }

      if (typeof moduleOrName !== 'string') {
        return this._registerShaderModule(moduleOrName, true);
      }

      var module = this.shaderModules[moduleOrName];

      if (!module) {
        (0, _utils.assert)(false, "Unknown shader module ".concat(moduleOrName));
      }

      return module;
    }
  }, {
    key: "resolveModules",
    value: function resolveModules(modules) {
      var _this = this;

      return modules.map(function (moduleOrName) {
        return _this.getShaderModule(moduleOrName);
      });
    }
  }, {
    key: "_registerShaderModule",
    value: function _registerShaderModule(module) {
      var ignoreMultipleRegistrations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (module instanceof _shaderModule["default"]) {
        return module;
      }

      (0, _utils.assert)(module.name, 'shader module has no name');

      if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {
        module = new _shaderModule["default"](module);
        module.dependencies = this.resolveModules(module.dependencies);
        this.shaderModules[module.name] = module;
      } else {
        throw new Error("shader module ".concat(module.name, " already registered"));
      }

      return this.shaderModules[module.name];
    }
  }]);
  return ShaderModuleRegistry;
}();

exports["default"] = ShaderModuleRegistry;

},{"../utils":317,"./shader-module":290,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],290:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeShaderModule = normalizeShaderModule;
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _transpileShader = _interopRequireDefault(require("./transpile-shader"));

var _utils = require("../utils");

var _propTypes = require("./filters/prop-types");

var VERTEX_SHADER = 'vs';
var FRAGMENT_SHADER = 'fs';

var ShaderModule = function () {
  function ShaderModule(_ref) {
    var name = _ref.name,
        vs = _ref.vs,
        fs = _ref.fs,
        _ref$dependencies = _ref.dependencies,
        dependencies = _ref$dependencies === void 0 ? [] : _ref$dependencies,
        uniforms = _ref.uniforms,
        getUniforms = _ref.getUniforms,
        _ref$deprecations = _ref.deprecations,
        deprecations = _ref$deprecations === void 0 ? [] : _ref$deprecations,
        _ref$defines = _ref.defines,
        defines = _ref$defines === void 0 ? {} : _ref$defines,
        vertexShader = _ref.vertexShader,
        fragmentShader = _ref.fragmentShader;
    (0, _classCallCheck2["default"])(this, ShaderModule);
    (0, _utils.assert)(typeof name === 'string');
    this.name = name;
    this.vs = vs || vertexShader;
    this.fs = fs || fragmentShader;
    this.getModuleUniforms = getUniforms;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines;

    if (uniforms) {
      this.uniforms = (0, _propTypes.parsePropTypes)(uniforms);
    }
  }

  (0, _createClass2["default"])(ShaderModule, [{
    key: "getModuleSource",
    value: function getModuleSource(type, targetGLSLVersion) {
      var moduleSource;

      switch (type) {
        case VERTEX_SHADER:
          moduleSource = (0, _transpileShader["default"])(this.vs || '', targetGLSLVersion, true);
          break;

        case FRAGMENT_SHADER:
          moduleSource = (0, _transpileShader["default"])(this.fs || '', targetGLSLVersion, false);
          break;

        default:
          (0, _utils.assert)(false);
      }

      return "#define MODULE_".concat(this.name.toUpperCase(), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
  }, {
    key: "getUniforms",
    value: function getUniforms(opts, uniforms) {
      if (this.getModuleUniforms) {
        return this.getModuleUniforms(opts, uniforms);
      }

      if (this.uniforms) {
        return this._defaultGetUniforms(opts);
      }

      return {};
    }
  }, {
    key: "getDefines",
    value: function getDefines() {
      return this.defines;
    }
  }, {
    key: "checkDeprecations",
    value: function checkDeprecations(shaderSource, log) {
      this.deprecations.forEach(function (def) {
        if (def.regex.test(shaderSource)) {
          if (def.deprecated) {
            log.deprecated(def.old, def["new"])();
          } else {
            log.removed(def.old, def["new"])();
          }
        }
      });
    }
  }, {
    key: "_parseDeprecationDefinitions",
    value: function _parseDeprecationDefinitions(deprecations) {
      deprecations.forEach(function (def) {
        switch (def.type) {
          case 'function':
            def.regex = new RegExp("\\b".concat(def.old, "\\("));
            break;

          default:
            def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
        }
      });
      return deprecations;
    }
  }, {
    key: "_defaultGetUniforms",
    value: function _defaultGetUniforms() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var uniforms = {};
      var propTypes = this.uniforms;

      for (var key in propTypes) {
        var propDef = propTypes[key];

        if (key in opts && !propDef["private"]) {
          if (propDef.validate) {
            (0, _utils.assert)(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
          }

          uniforms[key] = opts[key];
        } else {
          uniforms[key] = propDef.value;
        }
      }

      return uniforms;
    }
  }]);
  return ShaderModule;
}();

exports["default"] = ShaderModule;

function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;

    if (module.uniforms && !module.getUniforms) {
      var shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }

  return module;
}

},{"../utils":317,"./filters/prop-types":285,"./transpile-shader":291,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],291:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = transpileShader;

function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);

    case 100:
      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);

    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}

function convertVertexShaderTo300(source) {
  return source.replace(/attribute\s+/g, 'in ').replace(/varying\s+/g, 'out ').replace(/texture2D\(/g, 'texture(').replace(/textureCube\(+/g, 'texture(').replace(/texture2DLodEXT\(/g, 'textureLod(').replace(/textureCubeLodEXT\(/g, 'textureLod(');
}

function convertFragmentShaderTo300(source) {
  return source.replace(/varying\s+/g, 'in ').replace(/texture2D\(/g, 'texture(').replace(/textureCube\(/g, 'texture(').replace(/texture2DLodEXT\(/g, 'textureLod(').replace(/textureCubeLodEXT\(/g, 'textureLod(');
}

function convertVertexShaderTo100(source) {
  return source.replace(/^in\s+/gm, 'attribute ').replace(/^out\s+/gm, 'varying ').replace(/texture\(/g, 'texture2D(');
}

function convertFragmentShaderTo100(source) {
  return source.replace(/^in\s+/gm, 'varying ').replace(/texture\(/g, 'texture2D(');
}

},{}],292:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var DEFAULT_MODULE_OPTIONS = {
  diffuseTexture: null,
  diffuseColor: [0.5, 0.5, 0.5, 1]
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var uniforms = {};

  if (opts.diffuseTexture !== undefined) {
    uniforms.diffuse_uHasTexture = Boolean(opts.diffuseTexture);
    uniforms.diffuse_uTexture = opts.diffuseTexture;
  }

  if (opts.diffuseColor !== undefined) {
    uniforms.diffuse_uColor = opts.diffuseColor;
  }

  return uniforms;
}

var vs = "out vec2 diffuse_vTexCoord;\nvoid diffuse_setTextureCoordinate(vec2 uv) {\n  diffuse_vTexCoord = uv;\n}\n";
var fs = "uniform vec4 diffuse_uColor;\nuniform bool diffuse_uHasTexture;\nuniform sampler2D diffuse_uTexture;\n\nin vec2 diffuse_vTexCoord;\n\n\n\nvec4 diffuse_getColor() {\n  vec2 texCoord = diffuse_vTexCoord;\n  return diffuse_uHasTexture ?\n    texture2D(diffuse_uTexture, vec2(texCoord.s, texCoord.t)) :\n    diffuse_uColor;\n}\n\nvec4 diffuse_filterColor(vec4 color) {\n  return diffuse_getColor();\n}\n";
var _default = {
  name: 'diffuse',
  getUniforms: getUniforms,
  vs: vs,
  fs: fs
};
exports["default"] = _default;

},{}],293:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _project = _interopRequireDefault(require("../project/project"));

var DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
var DEFAULT_MODULE_OPTIONS = {
  lightDirection: DEFAULT_LIGHT_DIRECTION
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var uniforms = {};

  if (opts.lightDirection) {
    uniforms.dirlight_uLightDirection = opts.lightDirection;
  }

  return uniforms;
}

var vs = null;
var fs = "uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
var _default = {
  name: 'dirlight',
  vs: vs,
  fs: fs,
  getUniforms: getUniforms,
  dependencies: [_project["default"]]
};
exports["default"] = _default;

},{"../project/project":312,"@babel/runtime/helpers/interopRequireDefault":25}],294:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function getUniforms() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$fogEnable = _ref.fogEnable,
      fogEnable = _ref$fogEnable === void 0 ? false : _ref$fogEnable,
      _ref$fogColor = _ref.fogColor,
      fogColor = _ref$fogColor === void 0 ? [0.5, 0.5, 0.5] : _ref$fogColor,
      _ref$fogNear = _ref.fogNear,
      fogNear = _ref$fogNear === void 0 ? 1 : _ref$fogNear,
      _ref$fogFar = _ref.fogFar,
      fogFar = _ref$fogFar === void 0 ? 100 : _ref$fogFar;

  return {
    fog_uEnable: fogEnable,
    fog_uColor: fogColor,
    fog_uNear: fogNear,
    fog_uFar: fogFar
  };
}

var fs = "\nuniform bool fog_uEnable;\nuniform vec3 fog_uColor;\nuniform float fog_uNear;\nuniform float fog_uFar;\nvec4 fog_filterColor(vec4 color) {\n  if (fog_uEnable) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = smoothstep(fog_uNear, fog_uFar, depth);\n    return mix(color, vec4(fog_uColor, gl_FragColor.w), fogFactor);\n  } else {\n    return color;\n  }\n}\n\n";
var _default = {
  name: 'fog',
  getUniforms: getUniforms,
  vs: '',
  fs: fs
};
exports["default"] = _default;

},{}],295:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
var _default = {
  name: 'fp32',
  vs: fp32shader,
  fs: null
};
exports["default"] = _default;

},{}],296:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";
exports["default"] = _default;

},{}],297:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
exports["default"] = _default;

},{}],298:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64ify = fp64ify;
exports.fp64LowPart = fp64LowPart;
exports.fp64ifyMatrix4 = fp64ifyMatrix4;

function fp64ify(a) {
  var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}

function fp64LowPart(a) {
  return a - Math.fround(a);
}

function fp64ifyMatrix4(matrix) {
  var matrixFP64 = new Float32Array(32);

  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }

  return matrixFP64;
}

},{}],299:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "fp64ify", {
  enumerable: true,
  get: function get() {
    return _fp64Utils.fp64ify;
  }
});
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function get() {
    return _fp64Utils.fp64LowPart;
  }
});
Object.defineProperty(exports, "fp64ifyMatrix4", {
  enumerable: true,
  get: function get() {
    return _fp64Utils.fp64ifyMatrix4;
  }
});
exports.fp64fs = exports.fp64arithmetic = exports["default"] = void 0;

var _fp64Utils = require("./fp64-utils");

var _fp64Arithmetic = _interopRequireDefault(require("./fp64-arithmetic.glsl"));

var _fp64Functions = _interopRequireDefault(require("./fp64-functions.glsl"));

var fp64shader = "".concat(_fp64Arithmetic["default"], "\n").concat(_fp64Functions["default"]);
var CONST_UNIFORMS = {
  ONE: 1.0
};

function getUniforms() {
  return Object.assign({}, CONST_UNIFORMS);
}

var _default = {
  name: 'fp64',
  vs: fp64shader,
  fs: null,
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4,
  getUniforms: getUniforms
};
exports["default"] = _default;
var fp64arithmetic = {
  name: 'fp64-arithmetic',
  vs: "".concat(_fp64Arithmetic["default"]),
  fs: null
};
exports.fp64arithmetic = fp64arithmetic;
var fp64fs = {
  name: 'fp64-fs',
  vs: null,
  fs: fp64shader
};
exports.fp64fs = fp64fs;

},{"./fp64-arithmetic.glsl":296,"./fp64-functions.glsl":297,"./fp64-utils":298,"@babel/runtime/helpers/interopRequireDefault":25}],300:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function get() {
    return _fp["default"];
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function get() {
    return _fp2["default"];
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function get() {
    return _project["default"];
  }
});
Object.defineProperty(exports, "fog", {
  enumerable: true,
  get: function get() {
    return _fog["default"];
  }
});
Object.defineProperty(exports, "lights", {
  enumerable: true,
  get: function get() {
    return _lights["default"];
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function get() {
    return _dirlight["default"];
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function get() {
    return _picking["default"];
  }
});
Object.defineProperty(exports, "diffuse", {
  enumerable: true,
  get: function get() {
    return _diffuse["default"];
  }
});
Object.defineProperty(exports, "gouraudlighting", {
  enumerable: true,
  get: function get() {
    return _phongLighting.gouraudlighting;
  }
});
Object.defineProperty(exports, "phonglighting", {
  enumerable: true,
  get: function get() {
    return _phongLighting.phonglighting;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function get() {
    return _pbr["default"];
  }
});
Object.defineProperty(exports, "_transform", {
  enumerable: true,
  get: function get() {
    return _transform["default"];
  }
});

var _fp = _interopRequireDefault(require("./fp32/fp32"));

var _fp2 = _interopRequireDefault(require("./fp64/fp64"));

var _project = _interopRequireDefault(require("./project/project"));

var _fog = _interopRequireDefault(require("./fog/fog"));

var _lights = _interopRequireDefault(require("./lights/lights"));

var _dirlight = _interopRequireDefault(require("./dirlight/dirlight"));

var _picking = _interopRequireDefault(require("./picking/picking"));

var _diffuse = _interopRequireDefault(require("./diffuse/diffuse"));

var _phongLighting = require("./phong-lighting/phong-lighting");

var _pbr = _interopRequireDefault(require("./pbr/pbr"));

var _transform = _interopRequireDefault(require("./transform/transform"));

},{"./diffuse/diffuse":292,"./dirlight/dirlight":293,"./fog/fog":294,"./fp32/fp32":295,"./fp64/fp64":299,"./lights/lights":302,"./pbr/pbr":306,"./phong-lighting/phong-lighting":308,"./picking/picking":309,"./project/project":312,"./transform/transform":313,"@babel/runtime/helpers/interopRequireDefault":25}],301:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";
exports["default"] = _default;

},{}],302:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _lights = _interopRequireDefault(require("./lights.glsl"));

var _default = {
  name: 'lights',
  vs: _lights["default"],
  fs: _lights["default"],
  getUniforms: getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};
exports["default"] = _default;
var INITIAL_MODULE_OPTIONS = {};

function convertColor() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? [0, 0, 0] : _ref$color,
      _ref$intensity = _ref.intensity,
      intensity = _ref$intensity === void 0 ? 1.0 : _ref$intensity;

  return color.map(function (component) {
    return component * intensity / 255.0;
  });
}

function getLightSourceUniforms(_ref2) {
  var ambientLight = _ref2.ambientLight,
      _ref2$pointLights = _ref2.pointLights,
      pointLights = _ref2$pointLights === void 0 ? [] : _ref2$pointLights,
      _ref2$directionalLigh = _ref2.directionalLights,
      directionalLights = _ref2$directionalLigh === void 0 ? [] : _ref2$directionalLigh;
  var lightSourceUniforms = {};

  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }

  pointLights.forEach(function (pointLight, index) {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation;
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach(function (directionalLight, index) {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if ('lightSources' in opts) {
    var _ref3 = opts.lightSources || {},
        ambientLight = _ref3.ambientLight,
        pointLights = _ref3.pointLights,
        directionalLights = _ref3.directionalLights;

    var hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;

    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }

    return Object.assign({}, getLightSourceUniforms({
      ambientLight: ambientLight,
      pointLights: pointLights,
      directionalLights: directionalLights
    }), {
      lighting_uEnabled: true
    });
  }

  if ('lights' in opts) {
    var lightSources = {
      pointLights: [],
      directionalLights: []
    };
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (opts.lights || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var light = _step.value;

        switch (light.type) {
          case 'ambient':
            lightSources.ambientLight = light;
            break;

          case 'directional':
            lightSources.directionalLights.push(light);
            break;

          case 'point':
            lightSources.pointLights.push(light);
            break;

          default:
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return getUniforms({
      lightSources: lightSources
    });
  }

  return {};
}

},{"./lights.glsl":301,"@babel/runtime/helpers/interopRequireDefault":25}],303:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MODULE_INJECTORS_FS = exports.MODULE_INJECTORS_VS = void 0;
var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
exports.MODULE_INJECTORS_VS = MODULE_INJECTORS_VS;
var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
exports.MODULE_INJECTORS_FS = MODULE_INJECTORS_FS;

},{}],304:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "#if (__VERSION__ < 300)\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n\n\n  float perceptualRoughness = u_MetallicRoughnessValues.y;\n  float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n  vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n  perceptualRoughness = mrSample.g * perceptualRoughness;\n  metallic = mrSample.b * metallic;\n#endif\n  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n  metallic = clamp(metallic, 0.0, 1.0);\n\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n  diffuseColor *= 1.0 - metallic;\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n  float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n  float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n  vec3 specularEnvironmentR0 = specularColor.rgb;\n  vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n  vec3 n = getNormal();\n  vec3 v = normalize(u_Camera - pbr_vPosition);\n\n  float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n  vec3 reflection = -normalize(reflect(v, n));\n\n  PBRInfo pbrInputs = PBRInfo(\n    0.0,\n    NdotV,\n    0.0,\n    0.0,\n    0.0,\n    perceptualRoughness,\n    metallic,\n    specularEnvironmentR0,\n    specularEnvironmentR90,\n    alphaRoughness,\n    diffuseColor,\n    specularColor,\n    n,\n    v\n  );\n\n  vec3 color = vec3(0, 0, 0);\n\n#ifdef USE_LIGHTS\n  PBRInfo_setAmbientLight(pbrInputs);\n  color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n    if (i < lighting_uDirectionalLightCount) {\n      PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n      color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n    }\n  }\n  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n    if (i < lighting_uPointLightCount) {\n      PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n      float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n      color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n    }\n  }\n#endif\n#ifdef USE_IBL\n  color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n  float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n  color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n  vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n  color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n  color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n  color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n  color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";
exports["default"] = _default;

},{}],305:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "varying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";
exports["default"] = _default;

},{}],306:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _project = _interopRequireDefault(require("../project2/project2"));

var _lights = _interopRequireDefault(require("../lights/lights"));

var _pbrVertex = _interopRequireDefault(require("./pbr-vertex.glsl"));

var _pbrFragment = _interopRequireDefault(require("./pbr-fragment.glsl"));

var _default = {
  name: 'pbr',
  vs: _pbrVertex["default"],
  fs: _pbrFragment["default"],
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [_project["default"], _lights["default"]]
};
exports["default"] = _default;

},{"../lights/lights":302,"../project2/project2":310,"./pbr-fragment.glsl":304,"./pbr-vertex.glsl":305,"@babel/runtime/helpers/interopRequireDefault":25}],307:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";
exports["default"] = _default;

},{}],308:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phonglighting = exports.gouraudlighting = void 0;

var _lights = _interopRequireDefault(require("../lights/lights"));

var _phongLighting = _interopRequireDefault(require("./phong-lighting.glsl"));

var gouraudlighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights["default"]],
  vs: _phongLighting["default"],
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: getUniforms
};
exports.gouraudlighting = gouraudlighting;
var phonglighting = {
  name: 'phong-lighting',
  dependencies: [_lights["default"]],
  fs: _phongLighting["default"],
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: getUniforms
};
exports.phonglighting = phonglighting;
var INITIAL_MODULE_OPTIONS = {};

function getMaterialUniforms(material) {
  var materialUniforms = {};
  materialUniforms.lighting_uAmbient = material.ambient;
  materialUniforms.lighting_uDiffuse = material.diffuse;
  materialUniforms.lighting_uShininess = material.shininess;
  materialUniforms.lighting_uSpecularColor = material.specularColor.map(function (x) {
    return x / 255;
  });
  return materialUniforms;
}

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if (!('material' in opts)) {
    return {};
  }

  var material = opts.material;

  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }

  return getMaterialUniforms(material);
}

},{"../lights/lights":302,"./phong-lighting.glsl":307,"@babel/runtime/helpers/interopRequireDefault":25}],309:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
var DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingThreshold: 1.0,
  pickingActive: false
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var uniforms = {};

  if (opts.pickingSelectedColor !== undefined) {
    if (opts.pickingSelectedColor === null) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      var selectedColor = [opts.pickingSelectedColor[0], opts.pickingSelectedColor[1], opts.pickingSelectedColor[2]];
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }

  if (opts.pickingHighlightColor !== undefined) {
    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;
  }

  if (opts.pickingThreshold !== undefined) {
    uniforms.picking_uThreshold = opts.pickingThreshold;
  }

  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;
  }

  return uniforms;
}

var vs = "uniform vec3 picking_uSelectedColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n";
var fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n\n  if (selected) {\n    vec4 highLightColor = picking_uHighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  if (picking_uActive && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
var _default = {
  name: 'picking',
  vs: vs,
  fs: fs,
  getUniforms: getUniforms
};
exports["default"] = _default;

},{}],310:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _project2Vertex = _interopRequireDefault(require("./project2.vertex.glsl"));

var _default = {
  name: 'project2',
  vs: _project2Vertex["default"],
  fs: _project2Vertex["default"]
};
exports["default"] = _default;

},{"./project2.vertex.glsl":311,"@babel/runtime/helpers/interopRequireDefault":25}],311:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n";
exports["default"] = _default;

},{}],312:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _math = require("math.gl");

var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_MODULE_OPTIONS = {
  modelMatrix: IDENTITY_MATRIX,
  viewMatrix: IDENTITY_MATRIX,
  projectionMatrix: IDENTITY_MATRIX,
  cameraPositionWorld: [0, 0, 0]
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var uniforms = {};

  if (opts.modelMatrix !== undefined) {
    uniforms.modelMatrix = opts.modelMatrix;
  }

  if (opts.viewMatrix !== undefined) {
    uniforms.viewMatrix = opts.viewMatrix;
  }

  if (opts.projectionMatrix !== undefined) {
    uniforms.projectionMatrix = opts.projectionMatrix;
  }

  if (opts.cameraPositionWorld !== undefined) {
    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
  }

  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
    uniforms.viewProjectionMatrix = new _math.Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }

  return uniforms;
}

var common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
var vs = "".concat(common, "\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
var fs = "\n".concat(common);
var _default = {
  name: 'project',
  getUniforms: getUniforms,
  vs: vs,
  fs: fs
};
exports["default"] = _default;

},{"math.gl":415}],313:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
var _default = {
  name: 'transform',
  vs: vs,
  fs: null
};
exports["default"] = _default;

},{}],314:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n";
exports["default"] = _default;

},{}],315:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = "#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n";
exports["default"] = _default;

},{}],316:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'shadertools: assertion failed.');
  }
}

},{}],317:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert["default"];
  }
});

var _assert = _interopRequireDefault(require("./assert"));

},{"./assert":316,"@babel/runtime/helpers/interopRequireDefault":25}],318:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isOldIE;

function isOldIE() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = typeof window !== 'undefined' ? window.navigator || {} : {};
  var userAgent = opts.userAgent || navigator.userAgent || '';
  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}

},{}],319:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQualifierDetails = getQualifierDetails;
exports.getPassthroughFS = getPassthroughFS;
exports.typeToChannelSuffix = typeToChannelSuffix;
exports.typeToChannelCount = typeToChannelCount;
exports.convertToVec4 = convertToVec4;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _utils = require("../utils");

var FS100 = 'void main() {gl_FragColor = vec4(0);}';
var FS300 = "#version 300 es\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";

function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  var words = line.replace(/^\s+/, '').split(/\s+/);

  var _words = (0, _slicedToArray2["default"])(words, 3),
      qualifier = _words[0],
      type = _words[1],
      definition = _words[2];

  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }

  var name = definition.split(';')[0];
  return {
    qualifier: qualifier,
    type: type,
    name: name
  };
}

function getPassthroughFS() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$version = _ref.version,
      version = _ref$version === void 0 ? 100 : _ref$version,
      input = _ref.input,
      inputType = _ref.inputType,
      output = _ref.output;

  if (!input) {
    return version === 300 ? FS300 : FS100;
  }

  var outputValue = convertToVec4(input, inputType);

  if (version === 300) {
    return "#version 300 es\nin ".concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }

  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}

function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';

    case 'vec2':
      return 'xy';

    case 'vec3':
      return 'xyz';

    case 'vec4':
      return 'xyzw';

    default:
      (0, _utils.assert)(false);
      return null;
  }
}

function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;

    case 'vec2':
      return 2;

    case 'vec3':
      return 3;

    case 'vec4':
      return 4;

    default:
      (0, _utils.assert)(false);
      return null;
  }
}

function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");

    case 'vec2':
      return "vec4(".concat(variable, ", 0.0, 1.0)");

    case 'vec3':
      return "vec4(".concat(variable, ", 1.0)");

    case 'vec4':
      return variable;

    default:
      (0, _utils.assert)(false);
      return null;
  }
}

},{"../utils":317,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],320:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextInfo = getContextInfo;
exports.canCompileGLGSExtension = canCompileGLGSExtension;
exports.hasFeatures = hasFeatures;
exports.FEATURES = void 0;

var _isOldIe = _interopRequireDefault(require("./is-old-ie"));

var _assert = _interopRequireDefault(require("./assert"));

var GL_VENDOR = 0x1f00;
var GL_RENDERER = 0x1f01;
var GL_VERSION = 0x1f02;
var GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
var WEBGL_FEATURES = {
  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],
  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
};
var FEATURES = {};
exports.FEATURES = FEATURES;
Object.keys(WEBGL_FEATURES).forEach(function (key) {
  FEATURES[key] = key;
});

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function getContextInfo(gl) {
  var info = gl.getExtension('WEBGL_debug_renderer_info');
  var vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  var renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  var gpuVendor = identifyGPUVendor(vendor, renderer);
  var gpuInfo = {
    gpuVendor: gpuVendor,
    vendor: vendor,
    renderer: renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}

function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return 'NVIDIA';
  }

  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return 'INTEL';
  }

  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return 'AMD';
  }

  return 'UNKNOWN GPU';
}

var compiledGlslExtensions = {};

function canCompileGLGSExtension(gl, cap) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var feature = WEBGL_FEATURES[cap];
  (0, _assert["default"])(feature, cap);

  if (!(0, _isOldIe["default"])(opts)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  var extensionName = feature[0];
  var behavior = opts.behavior || 'enable';
  var source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  var shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}

function getFeature(gl, cap) {
  var feature = WEBGL_FEATURES[cap];
  (0, _assert["default"])(feature, cap);
  var extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  var value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;
  (0, _assert["default"])(value === false || value === true);
  return value;
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(function (feature) {
    return getFeature(gl, feature);
  });
}

},{"./assert":316,"./is-old-ie":318,"@babel/runtime/helpers/interopRequireDefault":25}],321:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function get() {
    return _unifiedParameterApi.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function get() {
    return _unifiedParameterApi.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function get() {
    return _unifiedParameterApi.setParameter;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function get() {
    return _unifiedParameterApi.resetParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function get() {
    return _unifiedParameterApi.getModifiedParameters;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function get() {
    return _setParameters.setParameters;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _trackContextState["default"];
  }
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function get() {
    return _trackContextState["default"];
  }
});
Object.defineProperty(exports, "pushContextState", {
  enumerable: true,
  get: function get() {
    return _trackContextState.pushContextState;
  }
});
Object.defineProperty(exports, "popContextState", {
  enumerable: true,
  get: function get() {
    return _trackContextState.popContextState;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function get() {
    return _withParameters.withParameters;
  }
});

var _unifiedParameterApi = require("./unified-parameter-api/unified-parameter-api");

var _setParameters = require("./unified-parameter-api/set-parameters");

var _trackContextState = _interopRequireWildcard(require("./state-tracking/track-context-state"));

var _withParameters = require("./state-tracking/with-parameters");

},{"./state-tracking/track-context-state":322,"./state-tracking/with-parameters":324,"./unified-parameter-api/set-parameters":325,"./unified-parameter-api/unified-parameter-api":326,"@babel/runtime/helpers/interopRequireWildcard":26}],322:[function(require,module,exports){
(function (global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = trackContextState;
exports.pushContextState = pushContextState;
exports.popContextState = popContextState;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webglFunctionToParametersTable = _interopRequireDefault(require("./webgl-function-to-parameters-table"));

var _webglParameterTables = require("../unified-parameter-api/webgl-parameter-tables");

var _unifiedParameterApi = require("../unified-parameter-api/unified-parameter-api");

var _utils = require("../utils");

function installGetterOverride(gl, functionName) {
  var originalGetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function get() {
    var pname = arguments.length <= 0 ? undefined : arguments[0];

    if (!(pname in gl.state.cache)) {
      gl.state.cache[pname] = originalGetterFunc.apply(void 0, arguments);
    }

    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc.apply(void 0, arguments);
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}

function installSetterSpy(gl, functionName, setter) {
  var originalSetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function set() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }

    var _setter = setter.apply(void 0, [gl.state._updateCache].concat(params)),
        valueChanged = _setter.valueChanged,
        oldValue = _setter.oldValue;

    if (valueChanged) {
      var _gl$state;

      (_gl$state = gl.state).log.apply(_gl$state, ["gl.".concat(functionName)].concat(params));

      originalSetterFunc.apply(void 0, params);
    }

    return oldValue;
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}

var GLState = function () {
  function GLState(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$copyState = _ref.copyState,
        copyState = _ref$copyState === void 0 ? false : _ref$copyState,
        _ref$log = _ref.log,
        log = _ref$log === void 0 ? function () {} : _ref$log;

    (0, _classCallCheck2["default"])(this, GLState);
    this.gl = gl;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? (0, _unifiedParameterApi.getParameters)(gl) : Object.assign({}, _webglParameterTables.GL_PARAMETER_DEFAULTS);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }

  (0, _createClass2["default"])(GLState, [{
    key: "push",
    value: function push() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.stateStack.push({});
    }
  }, {
    key: "pop",
    value: function pop() {
      (0, _utils.assert)(this.stateStack.length > 0);
      var oldValues = this.stateStack[this.stateStack.length - 1];
      (0, _unifiedParameterApi.setParameters)(this.gl, oldValues, this.cache);
      this.stateStack.pop();
    }
  }, {
    key: "_updateCache",
    value: function _updateCache(values) {
      var valueChanged = false;
      var oldValue;
      var oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

      for (var key in values) {
        (0, _utils.assert)(key !== undefined);

        if (!(0, _utils.deepArrayEqual)(values[key], this.cache[key])) {
          valueChanged = true;
          oldValue = this.cache[key];

          if (oldValues && !(key in oldValues)) {
            oldValues[key] = this.cache[key];
          }

          this.cache[key] = values[key];
        }
      }

      return {
        valueChanged: valueChanged,
        oldValue: oldValue
      };
    }
  }]);
  return GLState;
}();

function trackContextState(gl) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$enable = _ref2.enable,
      enable = _ref2$enable === void 0 ? true : _ref2$enable,
      copyState = _ref2.copyState;

  (0, _utils.assert)(copyState !== undefined);

  if (!gl.state) {
    var global_ = typeof global !== 'undefined' ? global : window;

    if (global_.polyfillContext) {
      global_.polyfillContext(gl);
    }

    gl.state = new GLState(gl, {
      copyState: copyState,
      enable: enable
    });

    for (var key in _webglFunctionToParametersTable["default"]) {
      var setter = _webglFunctionToParametersTable["default"][key];
      installSetterSpy(gl, key, setter);
    }

    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }

  gl.state.enable = enable;
  return gl;
}

function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }

  gl.state.push();
}

function popContextState(gl) {
  (0, _utils.assert)(gl.state);
  gl.state.pop();
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../unified-parameter-api/unified-parameter-api":326,"../unified-parameter-api/webgl-parameter-tables":327,"../utils":331,"./webgl-function-to-parameters-table":323,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],323:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _default = {
  enable: function enable(update, capability) {
    return update((0, _defineProperty2["default"])({}, capability, true));
  },
  disable: function disable(update, capability) {
    return update((0, _defineProperty2["default"])({}, capability, false));
  },
  pixelStorei: function pixelStorei(update, pname, value) {
    return update((0, _defineProperty2["default"])({}, pname, value));
  },
  hint: function hint(update, pname, _hint) {
    return update((0, _defineProperty2["default"])({}, pname, _hint));
  },
  bindFramebuffer: function bindFramebuffer(update, target, framebuffer) {
    var _update5;

    switch (target) {
      case 36160:
        return update((_update5 = {}, (0, _defineProperty2["default"])(_update5, 36006, framebuffer), (0, _defineProperty2["default"])(_update5, 36010, framebuffer), _update5));

      case 36009:
        return update((0, _defineProperty2["default"])({}, 36006, framebuffer));

      case 36008:
        return update((0, _defineProperty2["default"])({}, 36010, framebuffer));

      default:
        return null;
    }
  },
  blendColor: function blendColor(update, r, g, b, a) {
    return update((0, _defineProperty2["default"])({}, 32773, new Float32Array([r, g, b, a])));
  },
  blendEquation: function blendEquation(update, mode) {
    var _update9;

    return update((_update9 = {}, (0, _defineProperty2["default"])(_update9, 32777, mode), (0, _defineProperty2["default"])(_update9, 34877, mode), _update9));
  },
  blendEquationSeparate: function blendEquationSeparate(update, modeRGB, modeAlpha) {
    var _update10;

    return update((_update10 = {}, (0, _defineProperty2["default"])(_update10, 32777, modeRGB), (0, _defineProperty2["default"])(_update10, 34877, modeAlpha), _update10));
  },
  blendFunc: function blendFunc(update, src, dst) {
    var _update11;

    return update((_update11 = {}, (0, _defineProperty2["default"])(_update11, 32969, src), (0, _defineProperty2["default"])(_update11, 32968, dst), (0, _defineProperty2["default"])(_update11, 32971, src), (0, _defineProperty2["default"])(_update11, 32970, dst), _update11));
  },
  blendFuncSeparate: function blendFuncSeparate(update, srcRGB, dstRGB, srcAlpha, dstAlpha) {
    var _update12;

    return update((_update12 = {}, (0, _defineProperty2["default"])(_update12, 32969, srcRGB), (0, _defineProperty2["default"])(_update12, 32968, dstRGB), (0, _defineProperty2["default"])(_update12, 32971, srcAlpha), (0, _defineProperty2["default"])(_update12, 32970, dstAlpha), _update12));
  },
  clearColor: function clearColor(update, r, g, b, a) {
    return update((0, _defineProperty2["default"])({}, 3106, new Float32Array([r, g, b, a])));
  },
  clearDepth: function clearDepth(update, depth) {
    return update((0, _defineProperty2["default"])({}, 2931, depth));
  },
  clearStencil: function clearStencil(update, s) {
    return update((0, _defineProperty2["default"])({}, 2961, s));
  },
  colorMask: function colorMask(update, r, g, b, a) {
    return update((0, _defineProperty2["default"])({}, 3107, [r, g, b, a]));
  },
  cullFace: function cullFace(update, mode) {
    return update((0, _defineProperty2["default"])({}, 2885, mode));
  },
  depthFunc: function depthFunc(update, func) {
    return update((0, _defineProperty2["default"])({}, 2932, func));
  },
  depthRange: function depthRange(update, zNear, zFar) {
    return update((0, _defineProperty2["default"])({}, 2928, new Float32Array([zNear, zFar])));
  },
  depthMask: function depthMask(update, mask) {
    return update((0, _defineProperty2["default"])({}, 2930, mask));
  },
  frontFace: function frontFace(update, face) {
    return update((0, _defineProperty2["default"])({}, 2886, face));
  },
  lineWidth: function lineWidth(update, width) {
    return update((0, _defineProperty2["default"])({}, 2849, width));
  },
  polygonOffset: function polygonOffset(update, factor, units) {
    var _update23;

    return update((_update23 = {}, (0, _defineProperty2["default"])(_update23, 32824, factor), (0, _defineProperty2["default"])(_update23, 10752, units), _update23));
  },
  sampleCoverage: function sampleCoverage(update, value, invert) {
    var _update24;

    return update((_update24 = {}, (0, _defineProperty2["default"])(_update24, 32938, value), (0, _defineProperty2["default"])(_update24, 32939, invert), _update24));
  },
  scissor: function scissor(update, x, y, width, height) {
    return update((0, _defineProperty2["default"])({}, 3088, new Int32Array([x, y, width, height])));
  },
  stencilMask: function stencilMask(update, mask) {
    var _update26;

    return update((_update26 = {}, (0, _defineProperty2["default"])(_update26, 2968, mask), (0, _defineProperty2["default"])(_update26, 36005, mask), _update26));
  },
  stencilMaskSeparate: function stencilMaskSeparate(update, face, mask) {
    return update((0, _defineProperty2["default"])({}, face === 1028 ? 2968 : 36005, mask));
  },
  stencilFunc: function stencilFunc(update, func, ref, mask) {
    var _update28;

    return update((_update28 = {}, (0, _defineProperty2["default"])(_update28, 2962, func), (0, _defineProperty2["default"])(_update28, 2967, ref), (0, _defineProperty2["default"])(_update28, 2963, mask), (0, _defineProperty2["default"])(_update28, 34816, func), (0, _defineProperty2["default"])(_update28, 36003, ref), (0, _defineProperty2["default"])(_update28, 36004, mask), _update28));
  },
  stencilFuncSeparate: function stencilFuncSeparate(update, face, func, ref, mask) {
    var _update29;

    return update((_update29 = {}, (0, _defineProperty2["default"])(_update29, face === 1028 ? 2962 : 34816, func), (0, _defineProperty2["default"])(_update29, face === 1028 ? 2967 : 36003, ref), (0, _defineProperty2["default"])(_update29, face === 1028 ? 2963 : 36004, mask), _update29));
  },
  stencilOp: function stencilOp(update, fail, zfail, zpass) {
    var _update30;

    return update((_update30 = {}, (0, _defineProperty2["default"])(_update30, 2964, fail), (0, _defineProperty2["default"])(_update30, 2965, zfail), (0, _defineProperty2["default"])(_update30, 2966, zpass), (0, _defineProperty2["default"])(_update30, 34817, fail), (0, _defineProperty2["default"])(_update30, 34818, zfail), (0, _defineProperty2["default"])(_update30, 34819, zpass), _update30));
  },
  stencilOpSeparate: function stencilOpSeparate(update, face, fail, zfail, zpass) {
    var _update31;

    return update((_update31 = {}, (0, _defineProperty2["default"])(_update31, face === 1028 ? 2964 : 34817, fail), (0, _defineProperty2["default"])(_update31, face === 1028 ? 2965 : 34818, zfail), (0, _defineProperty2["default"])(_update31, face === 1028 ? 2966 : 34819, zpass), _update31));
  },
  viewport: function viewport(update, x, y, width, height) {
    return update((0, _defineProperty2["default"])({}, 2978, new Int32Array([x, y, width, height])));
  }
};
exports["default"] = _default;

},{"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],324:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withParameters = withParameters;

var _trackContextState = require("./track-context-state");

var _setParameters = require("../unified-parameter-api/set-parameters");

var _utils = require("../utils");

function withParameters(gl, parameters, func) {
  if ((0, _utils.isObjectEmpty)(parameters)) {
    return func(gl);
  }

  var _parameters$nocatch = parameters.nocatch,
      nocatch = _parameters$nocatch === void 0 ? true : _parameters$nocatch;
  (0, _utils.assert)(!parameters.frameBuffer);
  (0, _trackContextState.pushContextState)(gl);
  (0, _setParameters.setParameters)(gl, parameters);
  var value;

  if (nocatch) {
    value = func(gl);
    (0, _trackContextState.popContextState)(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      (0, _trackContextState.popContextState)(gl);
    }
  }

  return value;
}

},{"../unified-parameter-api/set-parameters":325,"../utils":331,"./track-context-state":322}],325:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setParameters = setParameters;

var _unifiedParameterApi = require("./unified-parameter-api");

var _webglSetterFunctionTable = _interopRequireDefault(require("./webgl-setter-function-table"));

function setParameters(gl, parameters) {
  (0, _unifiedParameterApi.setParameters)(gl, parameters);

  for (var key in parameters) {
    var setter = _webglSetterFunctionTable["default"][key];

    if (setter) {
      setter(gl, parameters[key], key);
    }
  }
}

},{"./unified-parameter-api":326,"./webgl-setter-function-table":328,"@babel/runtime/helpers/interopRequireDefault":25}],326:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setParameter = setParameter;
exports.setParameters = setParameters;
exports.getParameter = getParameter;
exports.getParameters = getParameters;
exports.getDefaultParameters = getDefaultParameters;
exports.resetParameters = resetParameters;
exports.getModifiedParameters = getModifiedParameters;

var _webglParameterTables = require("./webgl-parameter-tables");

var _deepArrayEqual = _interopRequireDefault(require("../utils/deep-array-equal"));

var _utils = require("../utils");

function setParameter(gl, key, value) {
  var getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
  var prevValue = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  var setter = _webglParameterTables.GL_PARAMETER_SETTERS[key];
  (0, _utils.assert)(typeof setter === 'function');
  setter(gl, value, Number(key));
  return prevValue;
}

function setParameters(gl, values) {
  var compositeSetters = {};

  for (var key in values) {
    var glConstant = Number(key);
    var setter = _webglParameterTables.GL_PARAMETER_SETTERS[key];

    if (setter) {
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }

  var cache = gl.state && gl.state.cache;

  if (cache) {
    var mergedValues = Object.assign({}, cache, values);

    for (var _key in compositeSetters) {
      var compositeSetter = _webglParameterTables.GL_COMPOSITE_PARAMETER_SETTERS[_key];
      compositeSetter(gl, mergedValues);
    }
  }
}

function getParameter(gl, key) {
  var getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
  return getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
}

function getParameters(gl, parameters) {
  parameters = parameters || _webglParameterTables.GL_PARAMETER_DEFAULTS;
  var parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  var state = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = parameterKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      state[key] = getParameter(gl, key);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return state;
}

function getDefaultParameters(gl) {
  return Object.assign({}, _webglParameterTables.GL_PARAMETER_DEFAULTS, {});
}

function resetParameters(gl) {
  setParameters(gl, getDefaultParameters(gl));
}

function getModifiedParameters(gl) {
  var values = getParameters(gl, Object.keys(_webglParameterTables.GL_PARAMETER_DEFAULTS));
  var modified = {};

  for (var key in _webglParameterTables.GL_PARAMETER_DEFAULTS) {
    if (!(0, _deepArrayEqual["default"])(values[key], _webglParameterTables.GL_PARAMETER_DEFAULTS[key])) {
      modified[key] = values[key];
    }
  }

  return modified;
}

},{"../utils":331,"../utils/deep-array-equal":330,"./webgl-parameter-tables":327,"@babel/runtime/helpers/interopRequireDefault":25}],327:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GL_PARAMETER_GETTERS = exports.GL_COMPOSITE_PARAMETER_SETTERS = exports.GL_PARAMETER_SETTERS = exports.GL_PARAMETER_DEFAULTS = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("../utils");

var _GL_PARAMETER_DEFAULT, _GL_PARAMETER_SETTERS, _GL_PARAMETER_GETTERS;

var GL_PARAMETER_DEFAULTS = (_GL_PARAMETER_DEFAULT = {}, (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3042, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32773, new Float32Array([0, 0, 0, 0])), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32777, 32774), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 34877, 32774), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32969, 1), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32968, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32971, 1), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32970, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3106, new Float32Array([0, 0, 0, 0])), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3107, [true, true, true, true]), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2884, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2885, 1029), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2929, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2931, 1), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2932, 513), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2928, new Float32Array([0, 1])), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2930, true), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3024, true), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 36006, null), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2886, 2305), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 33170, 4352), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2849, 1), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32823, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32824, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 10752, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32938, 1.0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32939, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3089, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3088, new Int32Array([0, 0, 1024, 1024])), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2960, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2961, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2968, 0xffffffff), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 36005, 0xffffffff), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2962, 519), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2967, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2963, 0xffffffff), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 34816, 519), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 36003, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 36004, 0xffffffff), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2964, 7680), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2965, 7680), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2966, 7680), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 34817, 7680), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 34818, 7680), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 34819, 7680), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 2978, new Int32Array([0, 0, 1024, 1024])), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3333, 4), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3317, 4), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 37440, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 37441, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 37443, 37444), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 35723, 4352), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 36010, null), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 35977, false), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3330, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3332, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3331, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3314, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32878, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3316, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 3315, 0), (0, _defineProperty2["default"])(_GL_PARAMETER_DEFAULT, 32877, 0), _GL_PARAMETER_DEFAULT);
exports.GL_PARAMETER_DEFAULTS = GL_PARAMETER_DEFAULTS;

var enable = function enable(gl, value, key) {
  return value ? gl.enable(key) : gl.disable(key);
};

var hint = function hint(gl, value, key) {
  return gl.hint(key, value);
};

var pixelStorei = function pixelStorei(gl, value, key) {
  return gl.pixelStorei(key, value);
};

var drawFramebuffer = function drawFramebuffer(gl, value) {
  var target = (0, _utils.isWebGL2)(gl) ? 36009 : 36160;
  return gl.bindFramebuffer(target, value);
};

var readFramebuffer = function readFramebuffer(gl, value) {
  return gl.bindFramebuffer(36008, value);
};

var GL_PARAMETER_SETTERS = (_GL_PARAMETER_SETTERS = {}, (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3042, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32773, function (gl, value) {
  return gl.blendColor.apply(gl, (0, _toConsumableArray2["default"])(value));
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32777, 'blendEquation'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 34877, 'blendEquation'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32969, 'blendFunc'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32968, 'blendFunc'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32971, 'blendFunc'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32970, 'blendFunc'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3106, function (gl, value) {
  return gl.clearColor.apply(gl, (0, _toConsumableArray2["default"])(value));
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3107, function (gl, value) {
  return gl.colorMask.apply(gl, (0, _toConsumableArray2["default"])(value));
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2884, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2885, function (gl, value) {
  return gl.cullFace(value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2929, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2931, function (gl, value) {
  return gl.clearDepth(value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2932, function (gl, value) {
  return gl.depthFunc(value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2928, function (gl, value) {
  return gl.depthRange.apply(gl, (0, _toConsumableArray2["default"])(value));
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2930, function (gl, value) {
  return gl.depthMask(value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3024, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 35723, hint), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 36006, drawFramebuffer), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2886, function (gl, value) {
  return gl.frontFace(value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 33170, hint), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2849, function (gl, value) {
  return gl.lineWidth(value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32823, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32824, 'polygonOffset'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 10752, 'polygonOffset'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 35977, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32938, 'sampleCoverage'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32939, 'sampleCoverage'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3089, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3088, function (gl, value) {
  return gl.scissor.apply(gl, (0, _toConsumableArray2["default"])(value));
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2960, enable), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2961, function (gl, value) {
  return gl.clearStencil(value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2968, function (gl, value) {
  return gl.stencilMaskSeparate(1028, value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 36005, function (gl, value) {
  return gl.stencilMaskSeparate(1029, value);
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2962, 'stencilFuncFront'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2967, 'stencilFuncFront'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2963, 'stencilFuncFront'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 34816, 'stencilFuncBack'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 36003, 'stencilFuncBack'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 36004, 'stencilFuncBack'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2964, 'stencilOpFront'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2965, 'stencilOpFront'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2966, 'stencilOpFront'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 34817, 'stencilOpBack'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 34818, 'stencilOpBack'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 34819, 'stencilOpBack'), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 2978, function (gl, value) {
  return gl.viewport.apply(gl, (0, _toConsumableArray2["default"])(value));
}), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3333, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3317, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 37440, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 37441, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 37443, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3330, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3332, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3331, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 36010, readFramebuffer), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3314, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32878, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3316, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 3315, pixelStorei), (0, _defineProperty2["default"])(_GL_PARAMETER_SETTERS, 32877, pixelStorei), _GL_PARAMETER_SETTERS);
exports.GL_PARAMETER_SETTERS = GL_PARAMETER_SETTERS;
var GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: function blendEquation(gl, values) {
    return gl.blendEquationSeparate(values[32777], values[34877]);
  },
  blendFunc: function blendFunc(gl, values) {
    return gl.blendFuncSeparate(values[32969], values[32968], values[32971], values[32970]);
  },
  polygonOffset: function polygonOffset(gl, values) {
    return gl.polygonOffset(values[32824], values[10752]);
  },
  sampleCoverage: function sampleCoverage(gl, values) {
    return gl.sampleCoverage(values[32938], values[32939]);
  },
  stencilFuncFront: function stencilFuncFront(gl, values) {
    return gl.stencilFuncSeparate(1028, values[2962], values[2967], values[2963]);
  },
  stencilFuncBack: function stencilFuncBack(gl, values) {
    return gl.stencilFuncSeparate(1029, values[34816], values[36003], values[36004]);
  },
  stencilOpFront: function stencilOpFront(gl, values) {
    return gl.stencilOpSeparate(1028, values[2964], values[2965], values[2966]);
  },
  stencilOpBack: function stencilOpBack(gl, values) {
    return gl.stencilOpSeparate(1029, values[34817], values[34818], values[34819]);
  }
};
exports.GL_COMPOSITE_PARAMETER_SETTERS = GL_COMPOSITE_PARAMETER_SETTERS;

var isEnabled = function isEnabled(gl, key) {
  return gl.isEnabled(key);
};

var GL_PARAMETER_GETTERS = (_GL_PARAMETER_GETTERS = {}, (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 3042, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 2884, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 2929, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 3024, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 32823, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 32926, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 32928, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 3089, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 2960, isEnabled), (0, _defineProperty2["default"])(_GL_PARAMETER_GETTERS, 35977, isEnabled), _GL_PARAMETER_GETTERS);
exports.GL_PARAMETER_GETTERS = GL_PARAMETER_GETTERS;

},{"../utils":331,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/toConsumableArray":39}],328:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

var _default = {
  framebuffer: function framebuffer(gl, _framebuffer) {
    var handle = _framebuffer && 'handle' in _framebuffer ? _framebuffer.handle : _framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: function blend(gl, value) {
    return value ? gl.enable(3042) : gl.disable(3042);
  },
  blendColor: function blendColor(gl, value) {
    return gl.blendColor.apply(gl, (0, _toConsumableArray2["default"])(value));
  },
  blendEquation: function blendEquation(gl, args) {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate.apply(gl, (0, _toConsumableArray2["default"])(args));
  },
  blendFunc: function blendFunc(gl, args) {
    args = isArray(args) && args.length === 2 ? [].concat((0, _toConsumableArray2["default"])(args), (0, _toConsumableArray2["default"])(args)) : args;
    gl.blendFuncSeparate.apply(gl, (0, _toConsumableArray2["default"])(args));
  },
  clearColor: function clearColor(gl, value) {
    return gl.clearColor.apply(gl, (0, _toConsumableArray2["default"])(value));
  },
  clearDepth: function clearDepth(gl, value) {
    return gl.clearDepth(value);
  },
  clearStencil: function clearStencil(gl, value) {
    return gl.clearStencil(value);
  },
  colorMask: function colorMask(gl, value) {
    return gl.colorMask.apply(gl, (0, _toConsumableArray2["default"])(value));
  },
  cull: function cull(gl, value) {
    return value ? gl.enable(2884) : gl.disable(2884);
  },
  cullFace: function cullFace(gl, value) {
    return gl.cullFace(value);
  },
  depthTest: function depthTest(gl, value) {
    return value ? gl.enable(2929) : gl.disable(2929);
  },
  depthFunc: function depthFunc(gl, value) {
    return gl.depthFunc(value);
  },
  depthMask: function depthMask(gl, value) {
    return gl.depthMask(value);
  },
  depthRange: function depthRange(gl, value) {
    return gl.depthRange.apply(gl, (0, _toConsumableArray2["default"])(value));
  },
  dither: function dither(gl, value) {
    return value ? gl.enable(3024) : gl.disable(3024);
  },
  derivativeHint: function derivativeHint(gl, value) {
    gl.hint(35723, value);
  },
  frontFace: function frontFace(gl, value) {
    return gl.frontFace(value);
  },
  mipmapHint: function mipmapHint(gl, value) {
    return gl.hint(33170, value);
  },
  lineWidth: function lineWidth(gl, value) {
    return gl.lineWidth(value);
  },
  polygonOffsetFill: function polygonOffsetFill(gl, value) {
    return value ? gl.enable(32823) : gl.disable(32823);
  },
  polygonOffset: function polygonOffset(gl, value) {
    return gl.polygonOffset.apply(gl, (0, _toConsumableArray2["default"])(value));
  },
  sampleCoverage: function sampleCoverage(gl, value) {
    return gl.sampleCoverage.apply(gl, (0, _toConsumableArray2["default"])(value));
  },
  scissorTest: function scissorTest(gl, value) {
    return value ? gl.enable(3089) : gl.disable(3089);
  },
  scissor: function scissor(gl, value) {
    return gl.scissor.apply(gl, (0, _toConsumableArray2["default"])(value));
  },
  stencilTest: function stencilTest(gl, value) {
    return value ? gl.enable(2960) : gl.disable(2960);
  },
  stencilMask: function stencilMask(gl, value) {
    value = isArray(value) ? value : [value, value];

    var _value = value,
        _value2 = (0, _slicedToArray2["default"])(_value, 2),
        mask = _value2[0],
        backMask = _value2[1];

    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: function stencilFunc(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat((0, _toConsumableArray2["default"])(args), (0, _toConsumableArray2["default"])(args)) : args;

    var _args = args,
        _args2 = (0, _slicedToArray2["default"])(_args, 6),
        func = _args2[0],
        ref = _args2[1],
        mask = _args2[2],
        backFunc = _args2[3],
        backRef = _args2[4],
        backMask = _args2[5];

    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: function stencilOp(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat((0, _toConsumableArray2["default"])(args), (0, _toConsumableArray2["default"])(args)) : args;

    var _args3 = args,
        _args4 = (0, _slicedToArray2["default"])(_args3, 6),
        sfail = _args4[0],
        dpfail = _args4[1],
        dppass = _args4[2],
        backSfail = _args4[3],
        backDpfail = _args4[4],
        backDppass = _args4[5];

    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: function viewport(gl, value) {
    return gl.viewport.apply(gl, (0, _toConsumableArray2["default"])(value));
  }
};
exports["default"] = _default;

},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37,"@babel/runtime/helpers/toConsumableArray":39}],329:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}

},{}],330:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = deepArrayEqual;

function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }

  var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

  if (isArrayX && isArrayY && x.length === y.length) {
    for (var i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}

},{}],331:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert["default"];
  }
});
Object.defineProperty(exports, "deepArrayEqual", {
  enumerable: true,
  get: function get() {
    return _deepArrayEqual["default"];
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function get() {
    return _utils.isWebGL2;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function get() {
    return _utils.isObjectEmpty;
  }
});

var _assert = _interopRequireDefault(require("./assert"));

var _deepArrayEqual = _interopRequireDefault(require("./deep-array-equal"));

var _utils = require("./utils");

},{"./assert":329,"./deep-array-equal":330,"./utils":332,"@babel/runtime/helpers/interopRequireDefault":25}],332:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectEmpty = isObjectEmpty;
exports.isWebGL2 = isWebGL2;

function isObjectEmpty(object) {
  for (var key in object) {
    return false;
  }

  return true;
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

},{}],333:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'webgl2-polyfill: assertion failed.');
  }
}

},{}],334:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "polyfillContext", {
  enumerable: true,
  get: function get() {
    return _polyfillContext["default"];
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _polyfillContext["default"];
  }
});

var _polyfillContext = _interopRequireDefault(require("./polyfill-context"));

},{"./polyfill-context":335,"@babel/runtime/helpers/interopRequireDefault":25}],335:[function(require,module,exports){
(function (global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = polyfillContext;

var _assert = _interopRequireDefault(require("./assert"));

var _polyfillTable = require("./polyfill-table");

function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  initializeExtensions(gl);

  if (!gl.luma.polyfilled) {
    installPolyfills(gl, _polyfillTable.WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: gl.luma,
      target2: gl
    });
    gl.luma.polyfilled = true;
  }

  return gl;
}

var global_ = typeof global !== 'undefined' ? global : window;
global_.polyfillContext = polyfillContext;

function initializeExtensions(gl) {
  gl.luma.extensions = {};
  var EXTENSIONS = gl.getSupportedExtensions() || [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = EXTENSIONS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var extension = _step.value;
      gl.luma[extension] = gl.getExtension(extension);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function installOverrides(gl, _ref) {
  var target = _ref.target,
      target2 = _ref.target2;
  Object.keys(_polyfillTable.WEBGL2_CONTEXT_OVERRIDES).forEach(function (key) {
    if (typeof _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key] === 'function') {
      var originalFunc = gl[key] ? gl[key].bind(gl) : function () {};

      var polyfill = _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);

      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}

function installPolyfills(gl, polyfills) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = Object.getOwnPropertyNames(polyfills)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var extension = _step2.value;

      if (extension !== 'overrides') {
        polyfillExtension(gl, {
          extension: extension,
          target: gl.luma,
          target2: gl
        });
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function polyfillExtension(gl, _ref2) {
  var extension = _ref2.extension,
      target = _ref2.target,
      target2 = _ref2.target2;
  var defaults = _polyfillTable.WEBGL2_CONTEXT_POLYFILLS[extension];
  (0, _assert["default"])(defaults);
  var _defaults$meta = defaults.meta,
      meta = _defaults$meta === void 0 ? {} : _defaults$meta;
  var _meta$suffix = meta.suffix,
      suffix = _meta$suffix === void 0 ? '' : _meta$suffix;
  var ext = gl.getExtension(extension);

  var _loop = function _loop() {
    var key = _Object$keys[_i];
    var extKey = "".concat(key).concat(suffix);
    var polyfill = null;

    if (key === 'meta') {} else if (typeof gl[key] === 'function') {} else if (ext && typeof ext[extKey] === 'function') {
      polyfill = function polyfill() {
        return ext[extKey].apply(ext, arguments);
      };
    } else if (typeof defaults[key] === 'function') {
      polyfill = defaults[key].bind(target);
    }

    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  };

  for (var _i = 0, _Object$keys = Object.keys(defaults); _i < _Object$keys.length; _i++) {
    _loop();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./assert":333,"./polyfill-table":336,"@babel/runtime/helpers/interopRequireDefault":25}],336:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBGL2_CONTEXT_OVERRIDES = exports.WEBGL2_CONTEXT_POLYFILLS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = _interopRequireDefault(require("./assert"));

var _getParameterPolyfill = require("./polyfills/get-parameter-polyfill");

var _WEBGL2_CONTEXT_POLYF;

var OES_vertex_array_object = 'OES_vertex_array_object';
var ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
var WEBGL_draw_buffers = 'WEBGL_draw_buffers';
var EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
var EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
var ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function getExtensionData(gl, extension) {
  return {
    webgl2: isWebGL2(gl),
    ext: gl.getExtension(extension)
  };
}

var WEBGL2_CONTEXT_POLYFILLS = (_WEBGL2_CONTEXT_POLYF = {}, (0, _defineProperty2["default"])(_WEBGL2_CONTEXT_POLYF, OES_vertex_array_object, {
  meta: {
    suffix: 'OES'
  },
  createVertexArray: function createVertexArray() {
    (0, _assert["default"])(false, ERR_VAO_NOT_SUPPORTED);
  },
  deleteVertexArray: function deleteVertexArray() {},
  bindVertexArray: function bindVertexArray() {},
  isVertexArray: function isVertexArray() {
    return false;
  }
}), (0, _defineProperty2["default"])(_WEBGL2_CONTEXT_POLYF, ANGLE_instanced_arrays, {
  meta: {
    suffix: 'ANGLE'
  },
  vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
    (0, _assert["default"])(divisor === 0, 'WebGL instanced rendering not supported');
  },
  drawElementsInstanced: function drawElementsInstanced() {},
  drawArraysInstanced: function drawArraysInstanced() {}
}), (0, _defineProperty2["default"])(_WEBGL2_CONTEXT_POLYF, WEBGL_draw_buffers, {
  meta: {
    suffix: 'WEBGL'
  },
  drawBuffers: function drawBuffers() {
    (0, _assert["default"])(false);
  }
}), (0, _defineProperty2["default"])(_WEBGL2_CONTEXT_POLYF, EXT_disjoint_timer_query, {
  meta: {
    suffix: 'EXT'
  },
  createQuery: function createQuery() {
    (0, _assert["default"])(false);
  },
  deleteQuery: function deleteQuery() {
    (0, _assert["default"])(false);
  },
  beginQuery: function beginQuery() {
    (0, _assert["default"])(false);
  },
  endQuery: function endQuery() {},
  getQuery: function getQuery(handle, pname) {
    return this.getQueryObject(handle, pname);
  },
  getQueryParameter: function getQueryParameter(handle, pname) {
    return this.getQueryObject(handle, pname);
  },
  getQueryObject: function getQueryObject() {}
}), _WEBGL2_CONTEXT_POLYF);
exports.WEBGL2_CONTEXT_POLYFILLS = WEBGL2_CONTEXT_POLYFILLS;
var WEBGL2_CONTEXT_OVERRIDES = {
  readBuffer: function readBuffer(gl, originalFunc, attachment) {
    if (isWebGL2(gl)) {
      originalFunc(attachment);
    } else {}
  },
  getVertexAttrib: function getVertexAttrib(gl, originalFunc, location, pname) {
    var _getExtensionData = getExtensionData(gl, ANGLE_instanced_arrays),
        webgl2 = _getExtensionData.webgl2,
        ext = _getExtensionData.ext;

    var result;

    switch (pname) {
      case 35069:
        result = !webgl2 ? false : undefined;
        break;

      case 35070:
        result = !webgl2 && !ext ? 0 : undefined;
        break;

      default:
    }

    return result !== undefined ? result : originalFunc(location, pname);
  },
  getProgramParameter: function getProgramParameter(gl, originalFunc, program, pname) {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case 35967:
          return 35981;

        case 35971:
          return 0;

        case 35382:
          return 0;

        default:
      }
    }

    return originalFunc(program, pname);
  },
  getInternalformatParameter: function getInternalformatParameter(gl, originalFunc, target, format, pname) {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case 32937:
          return new Int32Array([0]);

        default:
      }
    }

    return gl.getInternalformatParameter(target, format, pname);
  },
  getTexParameter: function getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case 34046:
        var extensions = gl.luma.extensions;
        var ext = extensions[EXT_texture_filter_anisotropic];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;

      default:
    }

    return originalFunc(target, pname);
  },
  getParameter: _getParameterPolyfill.getParameterPolyfill,
  hint: function hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }
};
exports.WEBGL2_CONTEXT_OVERRIDES = WEBGL2_CONTEXT_OVERRIDES;

},{"./assert":333,"./polyfills/get-parameter-polyfill":337,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],337:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameterPolyfill = getParameterPolyfill;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _WEBGL_PARAMETERS;

var OES_element_index = 'OES_element_index';
var WEBGL_draw_buffers = 'WEBGL_draw_buffers';
var EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
var EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
var EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
var WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';
var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
var GL_DONT_CARE = 0x1100;
var GL_GPU_DISJOINT_EXT = 0x8fbb;
var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
var GL_UNMASKED_VENDOR_WEBGL = 0x9245;
var GL_UNMASKED_RENDERER_WEBGL = 0x9246;

var getWebGL2ValueOrZero = function getWebGL2ValueOrZero(gl) {
  return !isWebGL2(gl) ? 0 : undefined;
};

var WEBGL_PARAMETERS = (_WEBGL_PARAMETERS = {}, (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 3074, function (gl) {
  return !isWebGL2(gl) ? 36064 : undefined;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, function (gl) {
  return !isWebGL2(gl) ? GL_DONT_CARE : undefined;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35977, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 32937, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, GL_GPU_DISJOINT_EXT, function (gl, getParameter) {
  var ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
  return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, GL_UNMASKED_VENDOR_WEBGL, function (gl, getParameter) {
  var ext = gl.getExtension(WEBGL_debug_renderer_info);
  return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, GL_UNMASKED_RENDERER_WEBGL, function (gl, getParameter) {
  var ext = gl.getExtension(WEBGL_debug_renderer_info);
  return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, function (gl, getParameter) {
  var ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
  return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 32883, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35071, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 37447, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 36063, function (gl, getParameter) {
  if (!isWebGL2(gl)) {
    var ext = gl.getExtension(WEBGL_draw_buffers);
    return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
  }

  return undefined;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35379, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35374, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35377, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 34852, function (gl) {
  if (!isWebGL2(gl)) {
    var ext = gl.getExtension(WEBGL_draw_buffers);
    return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
  }

  return undefined;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 36203, function (gl) {
  return gl.getExtension(OES_element_index) ? 2147483647 : 65535;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 33001, function (gl) {
  return gl.getExtension(OES_element_index) ? 16777216 : 65535;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 33000, function (gl) {
  return 16777216;
}), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 37157, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35373, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35657, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 36183, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 37137, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 34045, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35978, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35979, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35968, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35376, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35375, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35659, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 37154, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35371, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35658, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35076, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35077, getWebGL2ValueOrZero), (0, _defineProperty2["default"])(_WEBGL_PARAMETERS, 35380, getWebGL2ValueOrZero), _WEBGL_PARAMETERS);

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function getParameterPolyfill(gl, originalGetParameter, pname) {
  var limit = WEBGL_PARAMETERS[pname];
  var value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  var result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}

},{"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],338:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ACCESSOR_VALUES = exports["default"] = void 0;

var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
exports.DEFAULT_ACCESSOR_VALUES = DEFAULT_ACCESSOR_VALUES;
var PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};

var Accessor = function () {
  (0, _createClass2["default"])(Accessor, null, [{
    key: "getBytesPerElement",
    value: function getBytesPerElement(accessor) {
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
  }, {
    key: "getBytesPerVertex",
    value: function getBytesPerVertex(accessor) {
      (0, _utils.assert)(accessor.size);
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
  }, {
    key: "resolve",
    value: function resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }

      return (0, _construct2["default"])(Accessor, [DEFAULT_ACCESSOR_VALUES].concat(accessors));
    }
  }]);

  function Accessor() {
    var _this = this;

    (0, _classCallCheck2["default"])(this, Accessor);

    for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      accessors[_key2] = arguments[_key2];
    }

    accessors.forEach(function (accessor) {
      return _this._assign(accessor);
    });
    Object.freeze(this);
  }

  (0, _createClass2["default"])(Accessor, [{
    key: "toString",
    value: function toString() {
      return JSON.stringify(this);
    }
  }, {
    key: "_assign",
    value: function _assign() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      props = (0, _utils.checkProps)('Accessor', props, PROP_CHECKS);

      if (props.type !== undefined) {
        this.type = props.type;

        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }

      if (props.size !== undefined) {
        this.size = props.size;
      }

      if (props.offset !== undefined) {
        this.offset = props.offset;
      }

      if (props.stride !== undefined) {
        this.stride = props.stride;
      }

      if (props.normalized !== undefined) {
        this.normalized = props.normalized;
      }

      if (props.integer !== undefined) {
        this.integer = props.integer;
      }

      if (props.divisor !== undefined) {
        this.divisor = props.divisor;
      }

      if (props.buffer !== undefined) {
        this.buffer = props.buffer;
      }

      if (props.index !== undefined) {
        if (typeof index === 'boolean') {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }

      if (props.instanced !== undefined) {
        this.divisor = props.instanced ? 1 : 0;
      }

      if (props.isInstanced !== undefined) {
        this.divisor = props.isInstanced ? 1 : 0;
      }

      return this;
    }
  }, {
    key: "BYTES_PER_ELEMENT",
    get: function get() {
      return Accessor.getBytesPerElement(this);
    }
  }, {
    key: "BYTES_PER_VERTEX",
    get: function get() {
      return Accessor.getBytesPerVertex(this);
    }
  }]);
  return Accessor;
}();

exports["default"] = Accessor;

},{"../utils":388,"../webgl-utils":399,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/construct":19,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],339:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _accessor = _interopRequireDefault(require("./accessor"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var DEBUG_DATA_LENGTH = 10;
var DEPRECATED_PROPS = {
  offset: 'accessor.offset',
  stride: 'accessor.stride',
  type: 'accessor.type',
  size: 'accessor.size',
  divisor: 'accessor.divisor',
  normalized: 'accessor.normalized',
  integer: 'accessor.integer',
  instanced: 'accessor.divisor',
  isInstanced: 'accessor.divisor'
};
var PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: 'byteLength'
  },
  deprecatedProps: DEPRECATED_PROPS
};
var PROP_CHECKS_SET_PROPS = {
  removedProps: DEPRECATED_PROPS
};

var Buffer = function (_Resource) {
  (0, _inherits2["default"])(Buffer, _Resource);

  function Buffer(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Buffer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Buffer).call(this, gl, props));

    _this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);

    _this.target = props.target || (_this.gl.webgl2 ? 36662 : 34962);

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(Buffer, [{
    key: "getElementCount",
    value: function getElementCount() {
      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / _accessor["default"].getBytesPerElement(accessor));
    }
  }, {
    key: "getVertexCount",
    value: function getVertexCount() {
      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / _accessor["default"].getBytesPerVertex(accessor));
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }

      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }

      props = (0, _utils.checkProps)('Buffer', props, PROP_CHECKS_INITIALIZE);
      this.usage = props.usage || 35044;
      this.debugData = null;
      this.setAccessor(Object.assign({}, props, props.accessor));

      if (props.data) {
        this._setData(props.data);
      } else {
        this._setByteLength(props.byteLength || 0);
      }

      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      props = (0, _utils.checkProps)('Buffer', props, PROP_CHECKS_SET_PROPS);

      if ('accessor' in props) {
        this.setAccessor(props.accessor);
      }

      return this;
    }
  }, {
    key: "setAccessor",
    value: function setAccessor(accessor) {
      accessor = Object.assign({}, accessor);
      delete accessor.buffer;
      this.accessor = new _accessor["default"](accessor);
      return this;
    }
  }, {
    key: "reallocate",
    value: function reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);

        return true;
      }

      this.bytesUsed = byteLength;
      return false;
    }
  }, {
    key: "setData",
    value: function setData(props) {
      return this.initialize(props);
    }
  }, {
    key: "subData",
    value: function subData(props) {
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }

      var _props = props,
          data = _props.data,
          _props$offset = _props.offset,
          offset = _props$offset === void 0 ? 0 : _props$offset,
          _props$srcOffset = _props.srcOffset,
          srcOffset = _props$srcOffset === void 0 ? 0 : _props$srcOffset;
      var byteLength = props.byteLength || props.length;
      (0, _utils.assert)(data);
      var target = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target, this.handle);

      if (srcOffset !== 0 || byteLength !== undefined) {
        (0, _webglUtils.assertWebGL2Context)(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target, offset, data);
      }

      this.gl.bindBuffer(target, null);
      this.debugData = null;

      this._inferType(data);

      return this;
    }
  }, {
    key: "copyData",
    value: function copyData(_ref) {
      var sourceBuffer = _ref.sourceBuffer,
          _ref$readOffset = _ref.readOffset,
          readOffset = _ref$readOffset === void 0 ? 0 : _ref$readOffset,
          _ref$writeOffset = _ref.writeOffset,
          writeOffset = _ref$writeOffset === void 0 ? 0 : _ref$writeOffset,
          size = _ref.size;
      var gl = this.gl;
      (0, _webglUtils.assertWebGL2Context)(gl);
      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null);
      this.debugData = null;
      return this;
    }
  }, {
    key: "getData",
    value: function getData() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$dstData = _ref2.dstData,
          dstData = _ref2$dstData === void 0 ? null : _ref2$dstData,
          _ref2$srcByteOffset = _ref2.srcByteOffset,
          srcByteOffset = _ref2$srcByteOffset === void 0 ? 0 : _ref2$srcByteOffset,
          _ref2$dstOffset = _ref2.dstOffset,
          dstOffset = _ref2$dstOffset === void 0 ? 0 : _ref2$dstOffset,
          _ref2$length = _ref2.length,
          length = _ref2$length === void 0 ? 0 : _ref2$length;

      (0, _webglUtils.assertWebGL2Context)(this.gl);
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
        clamped: false
      });

      var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);

      var dstElementOffset = dstOffset;
      var dstAvailableElementCount;
      var dstElementCount;

      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }

      var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length = length || copyElementCount;
      (0, _utils.assert)(length <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount);
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
      this.gl.bindBuffer(36662, null);
      return dstData;
    }
  }, {
    key: "bind",
    value: function bind() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$target = _ref3.target,
          target = _ref3$target === void 0 ? this.target : _ref3$target,
          _ref3$index = _ref3.index,
          index = _ref3$index === void 0 ? this.accessor && this.accessor.index : _ref3$index,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
          size = _ref3.size;

      if (target === 35345 || target === 35982) {
        if (size !== undefined) {
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
        } else {
          (0, _utils.assert)(offset === 0);
          this.gl.bindBufferBase(target, index, this.handle);
        }
      } else {
        this.gl.bindBuffer(target, this.handle);
      }

      return this;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$target = _ref4.target,
          target = _ref4$target === void 0 ? this.target : _ref4$target,
          _ref4$index = _ref4.index,
          index = _ref4$index === void 0 ? this.accessor && this.accessor.index : _ref4$index;

      var isIndexedBuffer = target === 35345 || target === 35982;

      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }

      return this;
    }
  }, {
    key: "getDebugData",
    value: function getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: DEBUG_DATA_LENGTH
        });
        return {
          data: this.debugData,
          changed: true
        };
      }

      return {
        data: this.debugData,
        changed: false
      };
    }
  }, {
    key: "invalidateDebugData",
    value: function invalidateDebugData() {
      this.debugData = null;
    }
  }, {
    key: "_setData",
    value: function _setData(data) {
      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
      (0, _utils.assert)(ArrayBuffer.isView(data));

      this._trackDeallocatedMemory();

      var target = this._getTarget();

      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.bytesUsed = data.byteLength;

      this._trackAllocatedMemory(data.byteLength);

      var type = (0, _webglUtils.getGLTypeFromTypedArray)(data);
      (0, _utils.assert)(type);
      this.setAccessor(new _accessor["default"](this.accessor, {
        type: type
      }));
      return this;
    }
  }, {
    key: "_setByteLength",
    value: function _setByteLength(byteLength) {
      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
      (0, _utils.assert)(byteLength >= 0);

      this._trackDeallocatedMemory();

      var data = byteLength;

      if (byteLength === 0) {
        data = new Float32Array(0);
      }

      var target = this._getTarget();

      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = null;
      this.bytesUsed = byteLength;

      this._trackAllocatedMemory(byteLength);

      return this;
    }
  }, {
    key: "_getTarget",
    value: function _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
  }, {
    key: "_getAvailableElementCount",
    value: function _getAvailableElementCount(srcByteOffset) {
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
        clamped: false
      });
      var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    }
  }, {
    key: "_inferType",
    value: function _inferType(data) {
      if (!this.accessor.type) {
        this.setAccessor(new _accessor["default"](this.accessor, {
          type: (0, _webglUtils.getGLTypeFromTypedArray)(data)
        }));
      }
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createBuffer();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteBuffer(this.handle);

      this._trackDeallocatedMemory();
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      var value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    }
  }, {
    key: "setByteLength",
    value: function setByteLength(byteLength) {
      _utils.log.deprecated('setByteLength', 'reallocate')();

      return this.reallocate(byteLength);
    }
  }, {
    key: "updateAccessor",
    value: function updateAccessor(opts) {
      _utils.log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();

      this.accessor = new _accessor["default"](this.accessor, opts);
      return this;
    }
  }, {
    key: "type",
    get: function get() {
      _utils.log.deprecated('Buffer.type', 'Buffer.accessor.type')();

      return this.accessor.type;
    }
  }, {
    key: "bytes",
    get: function get() {
      _utils.log.deprecated('Buffer.bytes', 'Buffer.byteLength')();

      return this.byteLength;
    }
  }]);
  return Buffer;
}(_resource["default"]);

exports["default"] = Buffer;

},{"../utils":388,"../webgl-utils":399,"./accessor":338,"./resource":348,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],340:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.clearBuffer = clearBuffer;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var GL_DEPTH_BUFFER_BIT = 0x00000100;
var GL_STENCIL_BUFFER_BIT = 0x00000400;
var GL_COLOR_BUFFER_BIT = 0x00004000;
var GL_COLOR = 0x1800;
var GL_DEPTH = 0x1801;
var GL_STENCIL = 0x1802;
var GL_DEPTH_STENCIL = 0x84f9;
var ERR_ARGUMENTS = 'clear: bad arguments';

function clear(gl) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$framebuffer = _ref.framebuffer,
      framebuffer = _ref$framebuffer === void 0 ? null : _ref$framebuffer,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? null : _ref$color,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? null : _ref$depth,
      _ref$stencil = _ref.stencil,
      stencil = _ref$stencil === void 0 ? null : _ref$stencil;

  var parameters = {};

  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }

  var clearFlags = 0;

  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;

    if (color !== true) {
      parameters.clearColor = color;
    }
  }

  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }

  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }

  (0, _utils.assert)(clearFlags !== 0, ERR_ARGUMENTS);
  (0, _context.withParameters)(gl, parameters, function () {
    gl.clear(clearFlags);
  });
}

function clearBuffer(gl) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$framebuffer = _ref2.framebuffer,
      framebuffer = _ref2$framebuffer === void 0 ? null : _ref2$framebuffer,
      _ref2$buffer = _ref2.buffer,
      buffer = _ref2$buffer === void 0 ? GL_COLOR : _ref2$buffer,
      _ref2$drawBuffer = _ref2.drawBuffer,
      drawBuffer = _ref2$drawBuffer === void 0 ? 0 : _ref2$drawBuffer,
      _ref2$value = _ref2.value,
      value = _ref2$value === void 0 ? [0, 0, 0, 0] : _ref2$value;

  (0, _webglUtils.assertWebGL2Context)(gl);
  (0, _context.withParameters)(gl, {
    framebuffer: framebuffer
  }, function () {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;

          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;

          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }

        break;

      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;

      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;

      case GL_DEPTH_STENCIL:
        var _value = (0, _slicedToArray2["default"])(value, 2),
            depth = _value[0],
            stencil = _value[1];

        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;

      default:
        (0, _utils.assert)(false, ERR_ARGUMENTS);
    }
  });
}

},{"../context":364,"../utils":388,"../webgl-utils":399,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],341:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readPixelsToArray = readPixelsToArray;
exports.readPixelsToBuffer = readPixelsToBuffer;
exports.copyToDataUrl = copyToDataUrl;
exports.copyToImage = copyToImage;
exports.copyToTexture = copyToTexture;
exports.blit = blit;

var _buffer = _interopRequireDefault(require("./buffer"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _texture = _interopRequireDefault(require("./texture"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _typedArrayUtils = require("../webgl-utils/typed-array-utils");

var _formatUtils = require("../webgl-utils/format-utils");

var _textureUtils = require("../webgl-utils/texture-utils");

var _utils = require("../utils");

function readPixelsToArray(source) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$sourceX = _ref.sourceX,
      sourceX = _ref$sourceX === void 0 ? 0 : _ref$sourceX,
      _ref$sourceY = _ref.sourceY,
      sourceY = _ref$sourceY === void 0 ? 0 : _ref$sourceY,
      _ref$sourceFormat = _ref.sourceFormat,
      sourceFormat = _ref$sourceFormat === void 0 ? 6408 : _ref$sourceFormat,
      _ref$sourceAttachment = _ref.sourceAttachment,
      sourceAttachment = _ref$sourceAttachment === void 0 ? 36064 : _ref$sourceAttachment,
      _ref$target = _ref.target,
      target = _ref$target === void 0 ? null : _ref$target,
      sourceWidth = _ref.sourceWidth,
      sourceHeight = _ref.sourceHeight,
      sourceType = _ref.sourceType;

  var _getFramebuffer = getFramebuffer(source),
      framebuffer = _getFramebuffer.framebuffer,
      deleteFramebuffer = _getFramebuffer.deleteFramebuffer;

  (0, _utils.assert)(framebuffer);
  var gl = framebuffer.gl,
      handle = framebuffer.handle,
      attachments = framebuffer.attachments;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;

  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }

  (0, _utils.assert)(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || (0, _typedArrayUtils.getGLTypeFromTypedArray)(target);
  var prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer["delete"]();
  }

  return target;
}

function readPixelsToBuffer(source, _ref2) {
  var _ref2$sourceX = _ref2.sourceX,
      sourceX = _ref2$sourceX === void 0 ? 0 : _ref2$sourceX,
      _ref2$sourceY = _ref2.sourceY,
      sourceY = _ref2$sourceY === void 0 ? 0 : _ref2$sourceY,
      _ref2$sourceFormat = _ref2.sourceFormat,
      sourceFormat = _ref2$sourceFormat === void 0 ? 6408 : _ref2$sourceFormat,
      _ref2$target = _ref2.target,
      target = _ref2$target === void 0 ? null : _ref2$target,
      _ref2$targetByteOffse = _ref2.targetByteOffset,
      targetByteOffset = _ref2$targetByteOffse === void 0 ? 0 : _ref2$targetByteOffse,
      sourceWidth = _ref2.sourceWidth,
      sourceHeight = _ref2.sourceHeight,
      sourceType = _ref2.sourceType;

  var _getFramebuffer2 = getFramebuffer(source),
      framebuffer = _getFramebuffer2.framebuffer,
      deleteFramebuffer = _getFramebuffer2.deleteFramebuffer;

  (0, _utils.assert)(framebuffer);
  var gl = framebuffer.gl;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  (0, _webglUtils.assertWebGL2Context)(gl);
  sourceType = sourceType || (target ? target.type : 5121);

  if (!target) {
    var components = (0, _formatUtils.glFormatToComponents)(sourceFormat);
    var byteCount = (0, _formatUtils.glTypeToBytes)(sourceType);
    var byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new _buffer["default"](gl, {
      byteLength: byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }

  target.bind({
    target: 35051
  });
  (0, _context.withParameters)(gl, {
    framebuffer: framebuffer
  }, function () {
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });

  if (deleteFramebuffer) {
    framebuffer["delete"]();
  }

  return target;
}

function copyToDataUrl(source) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$sourceAttachmen = _ref3.sourceAttachment,
      sourceAttachment = _ref3$sourceAttachmen === void 0 ? 36064 : _ref3$sourceAttachmen,
      _ref3$targetMaxHeight = _ref3.targetMaxHeight,
      targetMaxHeight = _ref3$targetMaxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref3$targetMaxHeight;

  var data = readPixelsToArray(source, {
    sourceAttachment: sourceAttachment
  });
  var width = source.width,
      height = source.height;

  while (height > targetMaxHeight) {
    var _scalePixels = (0, _webglUtils.scalePixels)({
      data: data,
      width: width,
      height: height
    });

    data = _scalePixels.data;
    width = _scalePixels.width;
    height = _scalePixels.height;
  }

  (0, _webglUtils.flipRows)({
    data: data,
    width: width,
    height: height
  });
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var context = canvas.getContext('2d');
  var imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}

function copyToImage(source) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$sourceAttachmen = _ref4.sourceAttachment,
      sourceAttachment = _ref4$sourceAttachmen === void 0 ? 36064 : _ref4$sourceAttachmen,
      _ref4$targetImage = _ref4.targetImage,
      targetImage = _ref4$targetImage === void 0 ? null : _ref4$targetImage;

  var dataUrl = copyToDataUrl(source, {
    sourceAttachment: sourceAttachment
  });
  targetImage = targetImage || new Image();
  targetImage.src = dataUrl;
  return targetImage;
}

function copyToTexture(source, target) {
  var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref5$sourceX = _ref5.sourceX,
      sourceX = _ref5$sourceX === void 0 ? 0 : _ref5$sourceX,
      _ref5$sourceY = _ref5.sourceY,
      sourceY = _ref5$sourceY === void 0 ? 0 : _ref5$sourceY,
      targetX = _ref5.targetX,
      targetY = _ref5.targetY,
      targetZ = _ref5.targetZ,
      _ref5$targetMipmaplev = _ref5.targetMipmaplevel,
      targetMipmaplevel = _ref5$targetMipmaplev === void 0 ? 0 : _ref5$targetMipmaplev,
      _ref5$targetInternalF = _ref5.targetInternalFormat,
      targetInternalFormat = _ref5$targetInternalF === void 0 ? 6408 : _ref5$targetInternalF,
      width = _ref5.width,
      height = _ref5.height;

  var _getFramebuffer3 = getFramebuffer(source),
      framebuffer = _getFramebuffer3.framebuffer,
      deleteFramebuffer = _getFramebuffer3.deleteFramebuffer;

  (0, _utils.assert)(framebuffer);
  var gl = framebuffer.gl,
      handle = framebuffer.handle;
  var isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  var prevHandle = gl.bindFramebuffer(36160, handle);
  (0, _utils.assert)(target);
  var texture = null;

  if (target instanceof _texture["default"]) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }

  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;

      case 35866:
      case 32879:
        gl.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;

      default:
    }
  }

  if (texture) {
    texture.unbind();
  }

  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer["delete"]();
  }

  return texture;
}

function blit(source, target) {
  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref6$sourceAttachmen = _ref6.sourceAttachment,
      sourceAttachment = _ref6$sourceAttachmen === void 0 ? 36064 : _ref6$sourceAttachmen,
      _ref6$sourceX = _ref6.sourceX0,
      sourceX0 = _ref6$sourceX === void 0 ? 0 : _ref6$sourceX,
      _ref6$sourceY = _ref6.sourceY0,
      sourceY0 = _ref6$sourceY === void 0 ? 0 : _ref6$sourceY,
      sourceX1 = _ref6.sourceX1,
      sourceY1 = _ref6.sourceY1,
      _ref6$targetX = _ref6.targetX0,
      targetX0 = _ref6$targetX === void 0 ? 0 : _ref6$targetX,
      _ref6$targetY = _ref6.targetY0,
      targetY0 = _ref6$targetY === void 0 ? 0 : _ref6$targetY,
      targetX1 = _ref6.targetX1,
      targetY1 = _ref6.targetY1,
      _ref6$color = _ref6.color,
      color = _ref6$color === void 0 ? true : _ref6$color,
      _ref6$depth = _ref6.depth,
      depth = _ref6$depth === void 0 ? false : _ref6$depth,
      _ref6$stencil = _ref6.stencil,
      stencil = _ref6$stencil === void 0 ? false : _ref6$stencil,
      _ref6$mask = _ref6.mask,
      mask = _ref6$mask === void 0 ? 0 : _ref6$mask,
      _ref6$filter = _ref6.filter,
      filter = _ref6$filter === void 0 ? 9728 : _ref6$filter;

  var _getFramebuffer4 = getFramebuffer(source),
      srcFramebuffer = _getFramebuffer4.framebuffer,
      deleteSrcFramebuffer = _getFramebuffer4.deleteFramebuffer;

  var _getFramebuffer5 = getFramebuffer(target),
      dstFramebuffer = _getFramebuffer5.framebuffer,
      deleteDstFramebuffer = _getFramebuffer5.deleteFramebuffer;

  (0, _utils.assert)(srcFramebuffer);
  (0, _utils.assert)(dstFramebuffer);
  var gl = dstFramebuffer.gl,
      handle = dstFramebuffer.handle,
      width = dstFramebuffer.width,
      height = dstFramebuffer.height,
      readBuffer = dstFramebuffer.readBuffer;
  (0, _webglUtils.assertWebGL2Context)(gl);

  if (!srcFramebuffer.handle && sourceAttachment === 36064) {
    sourceAttachment = 1028;
  }

  if (color) {
    mask |= 16384;
  }

  if (depth) {
    mask |= 256;
  }

  if (stencil) {
    mask |= 1024;
  }

  if (deleteSrcFramebuffer || deleteDstFramebuffer) {
    if (mask & (256 | 1024)) {
      mask = 16384;

      _utils.log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();
    }
  }

  (0, _utils.assert)(mask);
  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
  targetX1 = targetX1 === undefined ? width : targetX1;
  targetY1 = targetY1 === undefined ? height : targetY1;
  var prevDrawHandle = gl.bindFramebuffer(36009, handle);
  var prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
  gl.readBuffer(sourceAttachment);
  gl.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
  gl.readBuffer(readBuffer);
  gl.bindFramebuffer(36008, prevReadHandle || null);
  gl.bindFramebuffer(36009, prevDrawHandle || null);

  if (deleteSrcFramebuffer) {
    srcFramebuffer["delete"]();
  }

  if (deleteDstFramebuffer) {
    dstFramebuffer["delete"]();
  }

  return dstFramebuffer;
}

function getFramebuffer(source) {
  if (!(source instanceof _framebuffer["default"])) {
    return {
      framebuffer: (0, _textureUtils.toFramebuffer)(source),
      deleteFramebuffer: true
    };
  }

  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}

function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }

  type = type || 5121;
  var ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(type, {
    clamped: false
  });
  var components = (0, _formatUtils.glFormatToComponents)(format);
  return new ArrayType(width * height * components);
}

},{"../context":364,"../utils":388,"../webgl-utils":399,"../webgl-utils/format-utils":398,"../webgl-utils/texture-utils":401,"../webgl-utils/typed-array-utils":402,"./buffer":339,"./framebuffer":342,"./texture":354,"@babel/runtime/helpers/interopRequireDefault":25}],342:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _texture2d = _interopRequireDefault(require("./texture-2d"));

var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));

var _clear2 = require("./clear");

var _copyAndBlit = require("./copy-and-blit.js");

var _features = require("../features");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';

var Framebuffer = function (_Resource) {
  (0, _inherits2["default"])(Framebuffer, _Resource);
  (0, _createClass2["default"])(Framebuffer, [{
    key: "MAX_COLOR_ATTACHMENTS",
    get: function get() {
      return this.gl.getParameter(this.gl.MAX_COLOR_ATTACHMENTS);
    }
  }, {
    key: "MAX_DRAW_BUFFERS",
    get: function get() {
      return this.gl.getParameter(this.gl.MAX_DRAW_BUFFERS);
    }
  }], [{
    key: "isSupported",
    value: function isSupported(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          colorBufferFloat = _ref.colorBufferFloat,
          colorBufferHalfFloat = _ref.colorBufferHalfFloat;

      var supported = true;
      supported = colorBufferFloat && gl.getExtension((0, _webglUtils.isWebGL2)(gl) ? 'EXT_color_buffer_float' : 'WEBGL.color_buffer_float');
      supported = colorBufferHalfFloat && gl.getExtension((0, _webglUtils.isWebGL2)(gl) ? 'EXT_color_buffer_float' : 'EXT_color_buffer_half_float');
      return supported;
    }
  }, {
    key: "getDefaultFramebuffer",
    value: function getDefaultFramebuffer(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
        id: 'default-framebuffer',
        handle: null,
        attachments: {}
      });
      return gl.luma.defaultFramebuffer;
    }
  }]);

  function Framebuffer(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Framebuffer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Framebuffer).call(this, gl, opts));
    _this.width = null;
    _this.height = null;
    _this.attachments = {};
    _this.readBuffer = 36064;
    _this.drawBuffers = [36064];

    _this.initialize(opts);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(Framebuffer, [{
    key: "initialize",
    value: function initialize(_ref2) {
      var _ref2$width = _ref2.width,
          width = _ref2$width === void 0 ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === void 0 ? 1 : _ref2$height,
          _ref2$attachments = _ref2.attachments,
          attachments = _ref2$attachments === void 0 ? null : _ref2$attachments,
          _ref2$color = _ref2.color,
          color = _ref2$color === void 0 ? true : _ref2$color,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? true : _ref2$depth,
          _ref2$stencil = _ref2.stencil,
          stencil = _ref2$stencil === void 0 ? false : _ref2$stencil,
          _ref2$check = _ref2.check,
          check = _ref2$check === void 0 ? true : _ref2$check,
          readBuffer = _ref2.readBuffer,
          drawBuffers = _ref2.drawBuffers;
      (0, _utils.assert)(width >= 0 && height >= 0, 'Width and height need to be integers');
      this.width = width;
      this.height = height;

      if (attachments) {
        for (var attachment in attachments) {
          var target = attachments[attachment];
          var object = Array.isArray(target) ? target[0] : target;
          object.resize({
            width: width,
            height: height
          });
        }
      } else {
        attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
      }

      this.update({
        clearAttachments: true,
        attachments: attachments,
        readBuffer: readBuffer,
        drawBuffers: drawBuffers
      });

      if (attachments && check) {
        this.checkStatus();
      }
    }
  }, {
    key: "update",
    value: function update(_ref3) {
      var _ref3$attachments = _ref3.attachments,
          attachments = _ref3$attachments === void 0 ? {} : _ref3$attachments,
          readBuffer = _ref3.readBuffer,
          drawBuffers = _ref3.drawBuffers,
          _ref3$clearAttachment = _ref3.clearAttachments,
          clearAttachments = _ref3$clearAttachment === void 0 ? false : _ref3$clearAttachment,
          _ref3$resizeAttachmen = _ref3.resizeAttachments,
          resizeAttachments = _ref3$resizeAttachmen === void 0 ? true : _ref3$resizeAttachmen;
      this.attach(attachments, {
        clearAttachments: clearAttachments,
        resizeAttachments: resizeAttachments
      });
      var gl = this.gl;
      var prevHandle = gl.bindFramebuffer(36160, this.handle);

      if (readBuffer) {
        this._setReadBuffer(readBuffer);
      }

      if (drawBuffers) {
        this._setDrawBuffers(drawBuffers);
      }

      gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
  }, {
    key: "resize",
    value: function resize() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          width = _ref4.width,
          height = _ref4.height;

      if (this.handle === null) {
        (0, _utils.assert)(width === undefined && height === undefined);
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }

      if (width === undefined) {
        width = this.gl.drawingBufferWidth;
      }

      if (height === undefined) {
        height = this.gl.drawingBufferHeight;
      }

      if (width !== this.width && height !== this.height) {
        _utils.log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
      }

      for (var attachmentPoint in this.attachments) {
        this.attachments[attachmentPoint].resize({
          width: width,
          height: height
        });
      }

      this.width = width;
      this.height = height;
      return this;
    }
  }, {
    key: "attach",
    value: function attach(attachments) {
      var _this2 = this;

      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$clearAttachment = _ref5.clearAttachments,
          clearAttachments = _ref5$clearAttachment === void 0 ? false : _ref5$clearAttachment,
          _ref5$resizeAttachmen = _ref5.resizeAttachments,
          resizeAttachments = _ref5$resizeAttachmen === void 0 ? true : _ref5$resizeAttachmen;

      var newAttachments = {};

      if (clearAttachments) {
        Object.keys(this.attachments).forEach(function (key) {
          newAttachments[key] = null;
        });
      }

      Object.assign(newAttachments, attachments);
      var prevHandle = this.gl.bindFramebuffer(36160, this.handle);

      for (var key in newAttachments) {
        (0, _utils.assert)(key !== undefined, 'Misspelled framebuffer binding point?');
        var attachment = Number(key);
        var descriptor = newAttachments[attachment];
        var object = descriptor;

        if (!object) {
          this._unattach(attachment);
        } else if (object instanceof _renderbuffer["default"]) {
          this._attachRenderbuffer({
            attachment: attachment,
            renderbuffer: object
          });
        } else if (Array.isArray(descriptor)) {
          var _descriptor = (0, _slicedToArray2["default"])(descriptor, 3),
              texture = _descriptor[0],
              _descriptor$ = _descriptor[1],
              layer = _descriptor$ === void 0 ? 0 : _descriptor$,
              _descriptor$2 = _descriptor[2],
              level = _descriptor$2 === void 0 ? 0 : _descriptor$2;

          object = texture;

          this._attachTexture({
            attachment: attachment,
            texture: texture,
            layer: layer,
            level: level
          });
        } else {
          this._attachTexture({
            attachment: attachment,
            texture: object,
            layer: 0,
            level: 0
          });
        }

        if (resizeAttachments && object) {
          object.resize({
            width: this.width,
            height: this.height
          });
        }
      }

      this.gl.bindFramebuffer(36160, prevHandle || null);
      Object.assign(this.attachments, attachments);
      Object.keys(this.attachments).filter(function (key) {
        return !_this2.attachments[key];
      }).forEach(function (key) {
        delete _this2.attachments[key];
      });
    }
  }, {
    key: "checkStatus",
    value: function checkStatus() {
      var gl = this.gl;
      var prevHandle = gl.bindFramebuffer(36160, this.handle);
      var status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);

      if (status !== 36053) {
        throw new Error(_getFrameBufferStatus(status));
      }

      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          color = _ref6.color,
          depth = _ref6.depth,
          stencil = _ref6.stencil,
          _ref6$drawBuffers = _ref6.drawBuffers,
          drawBuffers = _ref6$drawBuffers === void 0 ? [] : _ref6$drawBuffers;

      var prevHandle = this.gl.bindFramebuffer(36160, this.handle);

      if (color || depth || stencil) {
        (0, _clear2.clear)(this.gl, {
          color: color,
          depth: depth,
          stencil: stencil
        });
      }

      drawBuffers.forEach(function (value, drawBuffer) {
        (0, _clear2.clearBuffer)({
          drawBuffer: drawBuffer,
          value: value
        });
      });
      this.gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
  }, {
    key: "readPixels",
    value: function readPixels() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();

      return null;
    }
  }, {
    key: "readPixelsToBuffer",
    value: function readPixelsToBuffer() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();

      return null;
    }
  }, {
    key: "copyToDataUrl",
    value: function copyToDataUrl() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();

      return null;
    }
  }, {
    key: "copyToImage",
    value: function copyToImage() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();

      return null;
    }
  }, {
    key: "copyToTexture",
    value: function copyToTexture() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();

      return null;
    }
  }, {
    key: "blit",
    value: function blit() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();

      return null;
    }
  }, {
    key: "invalidate",
    value: function invalidate(_ref7) {
      var _ref7$attachments = _ref7.attachments,
          attachments = _ref7$attachments === void 0 ? [] : _ref7$attachments,
          _ref7$x = _ref7.x,
          x = _ref7$x === void 0 ? 0 : _ref7$x,
          _ref7$y = _ref7.y,
          y = _ref7$y === void 0 ? 0 : _ref7$y,
          width = _ref7.width,
          height = _ref7.height;
      var gl = this.gl;
      (0, _webglUtils.assertWebGL2Context)(gl);
      var prevHandle = gl.bindFramebuffer(36008, this.handle);
      var invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;

      if (invalidateAll) {
        gl.invalidateFramebuffer(36008, attachments);
      } else {
        gl.invalidateFramebuffer(36008, attachments, x, y, width, height);
      }

      gl.bindFramebuffer(36008, prevHandle);
      return this;
    }
  }, {
    key: "getAttachmentParameter",
    value: function getAttachmentParameter(attachment, pname, keys) {
      var value = this._getAttachmentParameterFallback(pname);

      if (value === null) {
        this.gl.bindFramebuffer(36160, this.handle);
        value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
        this.gl.bindFramebuffer(36160, null);
      }

      if (keys && value > 1000) {
        value = (0, _webglUtils.getKey)(this.gl, value);
      }

      return value;
    }
  }, {
    key: "getAttachmentParameters",
    value: function getAttachmentParameters() {
      var attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36064;
      var keys = arguments.length > 1 ? arguments[1] : undefined;
      var parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
      var values = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = parameters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pname = _step.value;
          var key = keys ? (0, _webglUtils.getKey)(this.gl, pname) : pname;
          values[key] = this.getAttachmentParameter(attachment, pname, keys);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return values;
    }
  }, {
    key: "getParameters",
    value: function getParameters() {
      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var attachments = Object.keys(this.attachments);
      var parameters = {};

      for (var _i = 0, _attachments = attachments; _i < _attachments.length; _i++) {
        var attachmentName = _attachments[_i];
        var attachment = Number(attachmentName);
        var key = keys ? (0, _webglUtils.getKey)(this.gl, attachment) : attachment;
        parameters[key] = this.getAttachmentParameters(attachment, keys);
      }

      return parameters;
    }
  }, {
    key: "show",
    value: function show() {
      if (typeof window !== 'undefined') {
        window.open((0, _copyAndBlit.copyToDataUrl)(this), 'luma-debug-texture');
      }

      return this;
    }
  }, {
    key: "log",
    value: function log() {
      var priority = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      if (priority > _utils.log.priority || typeof window === 'undefined') {
        return this;
      }

      message = message || "Framebuffer ".concat(this.id);
      var image = (0, _copyAndBlit.copyToDataUrl)(this, {
        maxHeight: 100
      });

      _utils.log.image({
        priority: priority,
        message: message,
        image: image
      }, message)();

      return this;
    }
  }, {
    key: "bind",
    value: function bind() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$target = _ref8.target,
          target = _ref8$target === void 0 ? 36160 : _ref8$target;

      this.gl.bindFramebuffer(target, this.handle);
      return this;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$target = _ref9.target,
          target = _ref9$target === void 0 ? 36160 : _ref9$target;

      this.gl.bindFramebuffer(target, null);
      return this;
    }
  }, {
    key: "_createDefaultAttachments",
    value: function _createDefaultAttachments(color, depth, stencil, width, height) {
      var defaultAttachments = null;

      if (color) {
        var _parameters;

        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36064] = new _texture2d["default"](this.gl, {
          id: "".concat(this.id, "-color0"),
          pixels: null,
          format: 6408,
          type: 5121,
          width: width,
          height: height,
          mipmaps: false,
          parameters: (_parameters = {}, (0, _defineProperty2["default"])(_parameters, 10241, 9729), (0, _defineProperty2["default"])(_parameters, 10240, 9729), (0, _defineProperty2["default"])(_parameters, 10242, 33071), (0, _defineProperty2["default"])(_parameters, 10243, 33071), _parameters)
        });
      }

      if (depth && stencil) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[33306] = new _renderbuffer["default"](this.gl, {
          id: "".concat(this.id, "-depth-stencil"),
          format: 35056,
          width: width,
          height: 111
        });
      } else if (depth) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36096] = new _renderbuffer["default"](this.gl, {
          id: "".concat(this.id, "-depth"),
          format: 33189,
          width: width,
          height: height
        });
      } else if (stencil) {
        (0, _utils.assert)(false);
      }

      return defaultAttachments;
    }
  }, {
    key: "_unattach",
    value: function _unattach(attachment) {
      var oldAttachment = this.attachments[attachment];

      if (!oldAttachment) {
        return;
      }

      if (oldAttachment instanceof _renderbuffer["default"]) {
        this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
      } else {
        this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
      }

      delete this.attachments[attachment];
    }
  }, {
    key: "_attachRenderbuffer",
    value: function _attachRenderbuffer(_ref10) {
      var _ref10$attachment = _ref10.attachment,
          attachment = _ref10$attachment === void 0 ? 36064 : _ref10$attachment,
          renderbuffer = _ref10.renderbuffer;
      var gl = this.gl;
      gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
      this.attachments[attachment] = renderbuffer;
    }
  }, {
    key: "_attachTexture",
    value: function _attachTexture(_ref11) {
      var _ref11$attachment = _ref11.attachment,
          attachment = _ref11$attachment === void 0 ? 36064 : _ref11$attachment,
          texture = _ref11.texture,
          layer = _ref11.layer,
          level = _ref11.level;
      var gl = this.gl;
      gl.bindTexture(texture.target, texture.handle);

      switch (texture.target) {
        case 35866:
        case 32879:
          gl.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;

        case 34067:
          var face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;

        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;

        default:
          (0, _utils.assert)(false, 'Illegal texture type');
      }

      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }
  }, {
    key: "_setReadBuffer",
    value: function _setReadBuffer(readBuffer) {
      var gl = this.gl;

      if ((0, _webglUtils.isWebGL2)(gl)) {
        gl.readBuffer(readBuffer);
      } else {
        (0, _utils.assert)(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
      }

      this.readBuffer = readBuffer;
    }
  }, {
    key: "_setDrawBuffers",
    value: function _setDrawBuffers(drawBuffers) {
      var gl = this.gl;

      if ((0, _webglUtils.isWebGL2)(gl)) {
        gl.drawBuffers(drawBuffers);
      } else {
        var ext = gl.getExtension('WEBGL.draw_buffers');

        if (ext) {
          ext.drawBuffersWEBGL(drawBuffers);
        } else {
          (0, _utils.assert)(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
        }
      }

      this.drawBuffers = drawBuffers;
    }
  }, {
    key: "_getAttachmentParameterFallback",
    value: function _getAttachmentParameterFallback(pname) {
      var caps = (0, _features.getFeatures)(this.gl);

      switch (pname) {
        case 36052:
          return !caps.webgl2 ? 0 : null;

        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return !caps.webgl2 ? 8 : null;

        case 33297:
          return !caps.webgl2 ? 5125 : null;

        case 33296:
          return !caps.webgl2 && !caps.EXT_sRGB ? 9729 : null;

        default:
          return null;
      }
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createFramebuffer();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      return this.gl.bindFramebuffer(36160, handle);
    }
  }, {
    key: "color",
    get: function get() {
      return this.attachments[36064] || null;
    }
  }, {
    key: "texture",
    get: function get() {
      return this.attachments[36064] || null;
    }
  }, {
    key: "depth",
    get: function get() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
  }, {
    key: "stencil",
    get: function get() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
  }]);
  return Framebuffer;
}(_resource["default"]);

exports["default"] = Framebuffer;

function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}

function _getFrameBufferStatus(status) {
  var STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}

var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

},{"../features":372,"../utils":388,"../webgl-utils":399,"./clear":340,"./copy-and-blit.js":341,"./renderbuffer":347,"./resource":348,"./texture-2d":350,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37}],343:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _accessor = _interopRequireDefault(require("./accessor"));

var _webglUtils = require("../webgl-utils");

var _attributeUtils = require("../webgl-utils/attribute-utils");

var ProgramConfiguration = function () {
  function ProgramConfiguration(program) {
    (0, _classCallCheck2["default"])(this, ProgramConfiguration);
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);

    this._readAttributesFromProgram(program);

    this._readVaryingsFromProgram(program);
  }

  (0, _createClass2["default"])(ProgramConfiguration, [{
    key: "getAttributeInfo",
    value: function getAttributeInfo(locationOrName) {
      var location = Number(locationOrName);

      if (Number.isFinite(location)) {
        return this.attributeInfosByLocation[location];
      }

      return this.attributeInfosByName[locationOrName] || null;
    }
  }, {
    key: "getAttributeLocation",
    value: function getAttributeLocation(locationOrName) {
      var attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.location : -1;
    }
  }, {
    key: "getAttributeAccessor",
    value: function getAttributeAccessor(locationOrName) {
      var attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.accessor : null;
    }
  }, {
    key: "getVaryingInfo",
    value: function getVaryingInfo(locationOrName) {
      var location = Number(locationOrName);

      if (Number.isFinite(location)) {
        return this.varyingInfos[location];
      }

      return this.varyingInfosByName[locationOrName] || null;
    }
  }, {
    key: "getVaryingIndex",
    value: function getVaryingIndex(locationOrName) {
      var varying = this.getVaryingInfo();
      return varying ? varying.location : -1;
    }
  }, {
    key: "getVaryingAccessor",
    value: function getVaryingAccessor(locationOrName) {
      var varying = this.getVaryingInfo();
      return varying ? varying.accessor : null;
    }
  }, {
    key: "_readAttributesFromProgram",
    value: function _readAttributesFromProgram(program) {
      var gl = program.gl;
      var count = gl.getProgramParameter(program.handle, 35721);

      for (var index = 0; index < count; index++) {
        var _gl$getActiveAttrib = gl.getActiveAttrib(program.handle, index),
            name = _gl$getActiveAttrib.name,
            type = _gl$getActiveAttrib.type,
            size = _gl$getActiveAttrib.size;

        var location = gl.getAttribLocation(program.handle, name);

        if (location >= 0) {
          this._addAttribute(location, name, type, size);
        }
      }

      this.attributeInfos.sort(function (a, b) {
        return a.location - b.location;
      });
    }
  }, {
    key: "_readVaryingsFromProgram",
    value: function _readVaryingsFromProgram(program) {
      var gl = program.gl;

      if (!(0, _webglUtils.isWebGL2)(gl)) {
        return;
      }

      var count = gl.getProgramParameter(program.handle, 35971);

      for (var location = 0; location < count; location++) {
        var _gl$getTransformFeedb = gl.getTransformFeedbackVarying(program.handle, location),
            name = _gl$getTransformFeedb.name,
            type = _gl$getTransformFeedb.type,
            size = _gl$getTransformFeedb.size;

        this._addVarying(location, name, type, size);
      }

      this.varyingInfos.sort(function (a, b) {
        return a.location - b.location;
      });
    }
  }, {
    key: "_addAttribute",
    value: function _addAttribute(location, name, compositeType, size) {
      var _decomposeCompositeGL = (0, _attributeUtils.decomposeCompositeGLType)(compositeType),
          type = _decomposeCompositeGL.type,
          components = _decomposeCompositeGL.components;

      var accessor = {
        type: type,
        size: size * components
      };

      this._inferProperties(location, name, accessor);

      var attributeInfo = {
        location: location,
        name: name,
        accessor: new _accessor["default"](accessor)
      };
      this.attributeInfos.push(attributeInfo);
      this.attributeInfosByLocation[location] = attributeInfo;
      this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
  }, {
    key: "_inferProperties",
    value: function _inferProperties(location, name, accessor) {
      if (/instance/i.test(name)) {
        accessor.divisor = 1;
      }
    }
  }, {
    key: "_addVarying",
    value: function _addVarying(location, name, compositeType, size) {
      var _decomposeCompositeGL2 = (0, _attributeUtils.decomposeCompositeGLType)(compositeType),
          type = _decomposeCompositeGL2.type,
          components = _decomposeCompositeGL2.components;

      var accessor = new _accessor["default"]({
        type: type,
        size: size * components
      });
      var varying = {
        location: location,
        name: name,
        accessor: accessor
      };
      this.varyingInfos.push(varying);
      this.varyingInfosByName[varying.name] = varying;
    }
  }]);
  return ProgramConfiguration;
}();

exports["default"] = ProgramConfiguration;

},{"../webgl-utils":399,"../webgl-utils/attribute-utils":396,"./accessor":338,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],344:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _texture = _interopRequireDefault(require("./texture"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _uniforms = require("./uniforms");

var _shader = require("./shader");

var _programConfiguration = _interopRequireDefault(require("./program-configuration"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _utils = require("../utils");

var LOG_PROGRAM_PERF_PRIORITY = 4;
var GL_SEPARATE_ATTRIBS = 0x8c8d;
var V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];

var Program = function (_Resource) {
  (0, _inherits2["default"])(Program, _Resource);

  function Program(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Program);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Program).call(this, gl, props));

    _this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);

    _this._isCached = false;

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2["default"])(_this));

    _this._setId(props.id);

    return _this;
  }

  (0, _createClass2["default"])(Program, [{
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var vs = props.vs,
          fs = props.fs,
          varyings = props.varyings,
          _props$bufferMode = props.bufferMode,
          bufferMode = _props$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _props$bufferMode;
      this.vs = typeof vs === 'string' ? new _shader.VertexShader(this.gl, {
        id: "".concat(props.id, "-vs"),
        source: vs
      }) : vs;
      this.fs = typeof fs === 'string' ? new _shader.FragmentShader(this.gl, {
        id: "".concat(props.id, "-fs"),
        source: fs
      }) : fs;
      (0, _utils.assert)(this.vs instanceof _shader.VertexShader);
      (0, _utils.assert)(this.fs instanceof _shader.FragmentShader);
      this.uniforms = {};

      if (varyings) {
        (0, _webglUtils.assertWebGL2Context)(this.gl);
        this.varyings = varyings;
        this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }

      this._compileAndLink();

      this._readUniformLocationsFromLinkedProgram();

      this.configuration = new _programConfiguration["default"](this);
      return this.setProps(props);
    }
  }, {
    key: "delete",
    value: function _delete() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._isCached) {
        return this;
      }

      return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Program.prototype), "delete", this).call(this, options);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('uniforms' in props) {
        this.setUniforms(props.uniforms);
      }

      return this;
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var _this2 = this;

      var logPriority = _ref.logPriority,
          _ref$drawMode = _ref.drawMode,
          drawMode = _ref$drawMode === void 0 ? 4 : _ref$drawMode,
          vertexCount = _ref.vertexCount,
          _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? 0 : _ref$offset,
          start = _ref.start,
          end = _ref.end,
          _ref$isIndexed = _ref.isIndexed,
          isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed,
          _ref$indexType = _ref.indexType,
          indexType = _ref$indexType === void 0 ? 5123 : _ref$indexType,
          _ref$isInstanced = _ref.isInstanced,
          isInstanced = _ref$isInstanced === void 0 ? false : _ref$isInstanced,
          _ref$instanceCount = _ref.instanceCount,
          instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount,
          _ref$vertexArray = _ref.vertexArray,
          vertexArray = _ref$vertexArray === void 0 ? null : _ref$vertexArray,
          transformFeedback = _ref.transformFeedback,
          framebuffer = _ref.framebuffer,
          _ref$parameters = _ref.parameters,
          parameters = _ref$parameters === void 0 ? {} : _ref$parameters,
          uniforms = _ref.uniforms,
          samplers = _ref.samplers;

      if (uniforms || samplers) {
        _utils.log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();

        this.setUniforms(uniforms || {});
      }

      if (logPriority !== undefined) {
        var fb = framebuffer ? framebuffer.id : 'default';
        var message = "mode=".concat((0, _webglUtils.getKey)(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat((0, _webglUtils.getKey)(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);

        _utils.log.log(logPriority, message)();
      }

      (0, _utils.assert)(vertexArray);
      this.gl.useProgram(this.handle);

      if (!this._areTexturesRenderable()) {
        return false;
      }

      vertexArray.bindForDraw(vertexCount, instanceCount, function () {
        if (framebuffer !== undefined) {
          parameters = Object.assign({}, parameters, {
            framebuffer: framebuffer
          });
        }

        if (transformFeedback) {
          var primitiveMode = (0, _attributeUtils.getPrimitiveDrawMode)(drawMode);
          transformFeedback.begin(primitiveMode);
        }

        _this2._bindTextures();

        (0, _context.withParameters)(_this2.gl, parameters, function () {
          if (isIndexed && isInstanced) {
            _this2.gl.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
          } else if (isIndexed && (0, _webglUtils.isWebGL2)(_this2.gl) && !isNaN(start) && !isNaN(end)) {
            _this2.gl.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
          } else if (isIndexed) {
            _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);
          } else if (isInstanced) {
            _this2.gl.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
          } else {
            _this2.gl.drawArrays(drawMode, offset, vertexCount);
          }
        });

        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      return true;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _onChangeCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      var somethingChanged = false;
      var changedUniforms = {};

      for (var key in uniforms) {
        if (!(0, _uniforms.areUniformsEqual)(this.uniforms[key], uniforms[key])) {
          somethingChanged = true;
          changedUniforms[key] = uniforms[key];
          this.uniforms[key] = (0, _uniforms.getUniformCopy)(uniforms[key]);
        }
      }

      if (somethingChanged) {
        _onChangeCallback();

        (0, _uniforms.checkUniformValues)(changedUniforms, this.id, this._uniformSetters);

        this._setUniforms(changedUniforms);
      }

      return this;
    }
  }, {
    key: "reset",
    value: function reset() {}
  }, {
    key: "_areTexturesRenderable",
    value: function _areTexturesRenderable() {
      var texturesRenderable = true;

      for (var uniformName in this.uniforms) {
        var uniformSetter = this._uniformSetters[uniformName];

        if (uniformSetter && uniformSetter.textureIndex !== undefined) {
          var uniform = this.uniforms[uniformName];

          if (uniform instanceof _framebuffer["default"]) {
            var framebuffer = uniform;
            uniform = framebuffer.texture;
          }

          if (uniform instanceof _texture["default"]) {
            var texture = uniform;
            texturesRenderable = texturesRenderable && texture.loaded;
          }
        }
      }

      return texturesRenderable;
    }
  }, {
    key: "_bindTextures",
    value: function _bindTextures() {
      for (var uniformName in this.uniforms) {
        var uniformSetter = this._uniformSetters[uniformName];

        if (uniformSetter && uniformSetter.textureIndex !== undefined) {
          var uniform = this.uniforms[uniformName];

          if (uniform instanceof _framebuffer["default"]) {
            uniform = uniform.texture;
          }

          if (uniform instanceof _texture["default"]) {
            var texture = uniform;
            texture.bind(uniformSetter.textureIndex);
          }
        }
      }
    }
  }, {
    key: "_setUniforms",
    value: function _setUniforms(uniforms) {
      this.gl.useProgram(this.handle);

      for (var uniformName in uniforms) {
        var uniform = uniforms[uniformName];
        var uniformSetter = this._uniformSetters[uniformName];

        if (uniformSetter) {
          if (uniform instanceof _framebuffer["default"]) {
            uniform = uniform.texture;
          }

          if (uniform instanceof _texture["default"]) {
            if (uniformSetter.textureIndex === undefined) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }

            var texture = uniform;
            var textureIndex = uniformSetter.textureIndex;
            texture.bind(textureIndex);
            uniformSetter(textureIndex);
          } else {
            uniformSetter(uniform);
          }
        }
      }

      return this;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createProgram();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
  }, {
    key: "_getOptionsFromHandle",
    value: function _getOptionsFromHandle(handle) {
      var shaderHandles = this.gl.getAttachedShaders(handle);
      var opts = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = shaderHandles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var shaderHandle = _step.value;
          var type = this.gl.getShaderParameter(this.handle, 35663);

          switch (type) {
            case 35633:
              opts.vs = new _shader.VertexShader({
                handle: shaderHandle
              });
              break;

            case 35632:
              opts.fs = new _shader.FragmentShader({
                handle: shaderHandle
              });
              break;

            default:
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return opts;
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      return this.gl.getProgramParameter(this.handle, pname);
    }
  }, {
    key: "_setId",
    value: function _setId(id) {
      if (!id) {
        var programName = this._getName();

        this.id = (0, _utils.uid)(programName);
      }
    }
  }, {
    key: "_getName",
    value: function _getName() {
      var programName = this.vs.getName() || this.fs.getName();
      programName = programName.replace(/shader/i, '');
      programName = programName ? "".concat(programName, "-program") : 'program';
      return programName;
    }
  }, {
    key: "_compileAndLink",
    value: function _compileAndLink() {
      var gl = this.gl;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);

      _utils.log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();

      gl.linkProgram(this.handle);

      _utils.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();

      if (gl.debug || _utils.log.priority > 0) {
        gl.validateProgram(this.handle);
        var linked = gl.getProgramParameter(this.handle, 35714);

        if (!linked) {
          throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
        }
      }
    }
  }, {
    key: "_readUniformLocationsFromLinkedProgram",
    value: function _readUniformLocationsFromLinkedProgram() {
      var gl = this.gl;
      this._uniformSetters = {};
      this._uniformCount = this._getParameter(35718);

      for (var i = 0; i < this._uniformCount; i++) {
        var info = this.gl.getActiveUniform(this.handle, i);

        var _parseUniformName = (0, _uniforms.parseUniformName)(info.name),
            name = _parseUniformName.name,
            isArray = _parseUniformName.isArray;

        var location = gl.getUniformLocation(this.handle, name);
        this._uniformSetters[name] = (0, _uniforms.getUniformSetter)(gl, location, info, isArray);

        if (info.size > 1) {
          for (var l = 0; l < info.size; l++) {
            location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
            this._uniformSetters["".concat(name, "[").concat(l, "]")] = (0, _uniforms.getUniformSetter)(gl, location, info, isArray);
          }
        }
      }

      this._textureIndexCounter = 0;
    }
  }, {
    key: "getActiveUniforms",
    value: function getActiveUniforms(uniformIndices, pname) {
      return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);
    }
  }, {
    key: "getUniformBlockIndex",
    value: function getUniformBlockIndex(blockName) {
      return this.gl.getUniformBlockIndex(this.handle, blockName);
    }
  }, {
    key: "getActiveUniformBlockParameter",
    value: function getActiveUniformBlockParameter(blockIndex, pname) {
      return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
  }, {
    key: "uniformBlockBinding",
    value: function uniformBlockBinding(blockIndex, blockBinding) {
      this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
  }]);
  return Program;
}(_resource["default"]);

exports["default"] = Program;

},{"../context":364,"../utils":388,"../webgl-utils":399,"../webgl-utils/attribute-utils":396,"./framebuffer":342,"./program-configuration":343,"./resource":348,"./shader":349,"./texture":354,"./uniforms":357,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],345:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _features = require("../features");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var GL_QUERY_RESULT = 0x8866;
var GL_QUERY_RESULT_AVAILABLE = 0x8867;
var GL_TIME_ELAPSED_EXT = 0x88bf;
var GL_GPU_DISJOINT_EXT = 0x8fbb;
var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
var GL_ANY_SAMPLES_PASSED = 0x8c2f;
var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;

var Query = function (_Resource) {
  (0, _inherits2["default"])(Query, _Resource);
  (0, _createClass2["default"])(Query, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var webgl2 = (0, _webglUtils.isWebGL2)(gl);
      var hasTimerQuery = (0, _features.hasFeatures)(gl, _features.FEATURES.TIMER_QUERY);
      var supported = webgl2 || hasTimerQuery;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = opts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          switch (key) {
            case 'queries':
              supported = supported && webgl2;
              break;

            case 'timers':
              supported = supported && hasTimerQuery;
              break;

            default:
              (0, _utils.assert)(false);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return supported;
    }
  }]);

  function Query(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Query);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Query).call(this, gl, opts));
    _this.target = null;
    _this._queryPending = false;
    _this._pollingPromise = null;
    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(Query, [{
    key: "beginTimeElapsedQuery",
    value: function beginTimeElapsedQuery() {
      return this.begin(GL_TIME_ELAPSED_EXT);
    }
  }, {
    key: "beginOcclusionQuery",
    value: function beginOcclusionQuery() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$conservative = _ref.conservative,
          conservative = _ref$conservative === void 0 ? false : _ref$conservative;

      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
    }
  }, {
    key: "beginTransformFeedbackQuery",
    value: function beginTransformFeedbackQuery() {
      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }
  }, {
    key: "begin",
    value: function begin(target) {
      if (this._queryPending) {
        return this;
      }

      this.target = target;
      this.gl.beginQuery(this.target, this.handle);
      return this;
    }
  }, {
    key: "end",
    value: function end() {
      if (this._queryPending) {
        return this;
      }

      if (this.target) {
        this.gl.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }

      return this;
    }
  }, {
    key: "isResultAvailable",
    value: function isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }

      var resultAvailable = this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);

      if (resultAvailable) {
        this._queryPending = false;
      }

      return resultAvailable;
    }
  }, {
    key: "isTimerDisjoint",
    value: function isTimerDisjoint() {
      return this.gl.getParameter(GL_GPU_DISJOINT_EXT);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT);
    }
  }, {
    key: "getTimerMilliseconds",
    value: function getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
  }, {
    key: "createPoll",
    value: function createPoll() {
      var _this2 = this;

      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;

      if (this._pollingPromise) {
        return this._pollingPromise;
      }

      var counter = 0;
      this._pollingPromise = new Promise(function (resolve, reject) {
        var poll = function poll() {
          if (_this2.isResultAvailable()) {
            resolve(_this2.getResult());
            _this2._pollingPromise = null;
          } else if (counter++ > limit) {
            reject('Timed out');
            _this2._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };

        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return Query.isSupported(this.gl) ? this.gl.createQuery() : null;
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteQuery(this.handle);
    }
  }]);
  return Query;
}(_resource["default"]);

exports["default"] = Query;

},{"../features":372,"../utils":388,"../webgl-utils":399,"./resource":348,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],346:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _$33190$36012$;

var EXT_FLOAT_WEBGL2 = 'EXT_color_buffer_float';

var _default = (_$33190$36012$ = {}, (0, _defineProperty2["default"])(_$33190$36012$, 33189, {
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33190, {
  gl2: true,
  bpp: 3
}), (0, _defineProperty2["default"])(_$33190$36012$, 36012, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 36168, {
  bpp: 1
}), (0, _defineProperty2["default"])(_$33190$36012$, 34041, {
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 35056, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 36013, {
  gl2: true,
  bpp: 5
}), (0, _defineProperty2["default"])(_$33190$36012$, 32854, {
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 36194, {
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 32855, {
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33321, {
  gl2: true,
  bpp: 1
}), (0, _defineProperty2["default"])(_$33190$36012$, 33330, {
  gl2: true,
  bpp: 1
}), (0, _defineProperty2["default"])(_$33190$36012$, 33329, {
  gl2: true,
  bpp: 1
}), (0, _defineProperty2["default"])(_$33190$36012$, 33332, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33331, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33334, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 33333, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 33323, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33336, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33335, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33338, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 33337, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 33340, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2["default"])(_$33190$36012$, 33339, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2["default"])(_$33190$36012$, 32849, {
  gl2: true,
  bpp: 3
}), (0, _defineProperty2["default"])(_$33190$36012$, 32856, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 32857, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 36220, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 36238, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 36975, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 36214, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2["default"])(_$33190$36012$, 36232, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2["default"])(_$33190$36012$, 36226, {
  gl2: true,
  bpp: 16
}), (0, _defineProperty2["default"])(_$33190$36012$, 36208, {
  gl2: true,
  bpp: 16
}), (0, _defineProperty2["default"])(_$33190$36012$, 33325, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 2
}), (0, _defineProperty2["default"])(_$33190$36012$, 33327, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 34842, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 8
}), (0, _defineProperty2["default"])(_$33190$36012$, 33326, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 4
}), (0, _defineProperty2["default"])(_$33190$36012$, 33328, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 8
}), (0, _defineProperty2["default"])(_$33190$36012$, 34836, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 16
}), (0, _defineProperty2["default"])(_$33190$36012$, 35898, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 4
}), _$33190$36012$);

exports["default"] = _default;

},{"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],347:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _renderbufferFormats = _interopRequireDefault(require("./renderbuffer-formats"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function isFormatSupported(gl, format, formats) {
  var info = formats[format];

  if (!info) {
    return false;
  }

  var value = (0, _webglUtils.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;

  if (typeof value === 'string') {
    return gl.getExtension(value);
  }

  return value;
}

var Renderbuffer = function (_Resource) {
  (0, _inherits2["default"])(Renderbuffer, _Resource);
  (0, _createClass2["default"])(Renderbuffer, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          format = _ref.format;

      return !format || isFormatSupported(gl, format, _renderbufferFormats["default"]);
    }
  }, {
    key: "getSamplesForFormat",
    value: function getSamplesForFormat(gl, _ref2) {
      var format = _ref2.format;
      return gl.getInternalformatParameter(36161, format, 32937);
    }
  }]);

  function Renderbuffer(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Renderbuffer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Renderbuffer).call(this, gl, opts));

    _this.initialize(opts);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(Renderbuffer, [{
    key: "initialize",
    value: function initialize(_ref3) {
      var format = _ref3.format,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? 1 : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? 1 : _ref3$height,
          _ref3$samples = _ref3.samples,
          samples = _ref3$samples === void 0 ? 0 : _ref3$samples;
      (0, _utils.assert)(format, 'Needs format');

      this._trackDeallocatedMemory();

      this.gl.bindRenderbuffer(36161, this.handle);

      if (samples !== 0 && (0, _webglUtils.isWebGL2)(this.gl)) {
        this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
      } else {
        this.gl.renderbufferStorage(36161, format, width, height);
      }

      this.format = format;
      this.width = width;
      this.height = height;
      this.samples = samples;

      this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * _renderbufferFormats["default"][this.format].bpp);

      return this;
    }
  }, {
    key: "resize",
    value: function resize(_ref4) {
      var width = _ref4.width,
          height = _ref4.height;

      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width: width,
          height: height,
          format: this.format,
          samples: this.samples
        });
      }

      return this;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createRenderbuffer();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);

      this._trackDeallocatedMemory();
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
  }, {
    key: "_syncHandle",
    value: function _syncHandle(handle) {
      this.format = this.getParameter(36164);
      this.width = this.getParameter(36162);
      this.height = this.getParameter(36163);
      this.samples = this.getParameter(36011);
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      this.gl.bindRenderbuffer(36161, this.handle);
      var value = this.gl.getRenderbufferParameter(36161, pname);
      return value;
    }
  }]);
  return Renderbuffer;
}(_resource["default"]);

exports["default"] = Renderbuffer;

},{"../utils":388,"../webgl-utils":399,"./renderbuffer-formats":346,"./resource":348,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],348:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _init = require("../init");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';

var Resource = function () {
  function Resource(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Resource);
    (0, _webglUtils.assertWebGLContext)(gl);
    var id = opts.id,
        _opts$userData = opts.userData,
        userData = _opts$userData === void 0 ? {} : _opts$userData;
    this.gl = gl;
    this.id = id || (0, _utils.uid)(this.constructor.name);
    this.userData = userData;
    this._bound = false;
    this._handle = opts.handle;

    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }

    this.byteLength = 0;

    this._addStats();
  }

  (0, _createClass2["default"])(Resource, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.constructor.name, "(").concat(this.id, ")");
    }
  }, {
    key: "delete",
    value: function _delete() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$deleteChildren = _ref.deleteChildren,
          deleteChildren = _ref$deleteChildren === void 0 ? false : _ref$deleteChildren;

      var children = this._handle && this._deleteHandle(this._handle);

      if (this._handle) {
        this._removeStats();
      }

      this._handle = null;

      if (children && deleteChildren) {
        children.filter(Boolean).forEach(function (child) {
          child["delete"]();
        });
      }

      return this;
    }
  }, {
    key: "bind",
    value: function bind() {
      var funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;

      if (typeof funcOrHandle !== 'function') {
        this._bindHandle(funcOrHandle);

        return this;
      }

      var value;

      if (!this._bound) {
        this._bindHandle(this.handle);

        this._bound = true;
        value = funcOrHandle();
        this._bound = false;

        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }

      return value;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      this.bind(null);
    }
  }, {
    key: "getParameter",
    value: function getParameter(pname) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      pname = (0, _webglUtils.getKeyValue)(this.gl, pname);
      (0, _utils.assert)(pname);
      var parameters = this.constructor.PARAMETERS || {};
      var parameter = parameters[pname];

      if (parameter) {
        var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl);
        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

        if (!parameterAvailable) {
          var webgl1Default = parameter.webgl1;
          var webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
          var defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue;
        }
      }

      return this._getParameter(pname, opts);
    }
  }, {
    key: "getParameters",
    value: function getParameters() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref2 = {},
          parameters = _ref2.parameters,
          keys = _ref2.keys;
      var PARAMETERS = this.constructor.PARAMETERS || {};
      var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl);
      var values = {};
      var parameterKeys = parameters || Object.keys(PARAMETERS);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = parameterKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pname = _step.value;
          var parameter = PARAMETERS[pname];
          var parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

          if (parameterAvailable) {
            var key = keys ? (0, _webglUtils.getKey)(this.gl, pname) : pname;
            values[key] = this.getParameter(pname, opts);

            if (keys && parameter.type === 'GLenum') {
              values[key] = (0, _webglUtils.getKey)(this.gl, values[key]);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return values;
    }
  }, {
    key: "setParameter",
    value: function setParameter(pname, value) {
      pname = (0, _webglUtils.getKeyValue)(this.gl, pname);
      (0, _utils.assert)(pname);
      var parameters = this.constructor.PARAMETERS || {};
      var parameter = parameters[pname];

      if (parameter) {
        var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl);
        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

        if (!parameterAvailable) {
          throw new Error('Parameter not available on this platform');
        }

        if (parameter.type === 'GLenum') {
          value = (0, _webglUtils.getKeyValue)(value);
        }
      }

      this._setParameter(pname, value);

      return this;
    }
  }, {
    key: "setParameters",
    value: function setParameters(parameters) {
      for (var pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }

      return this;
    }
  }, {
    key: "stubRemovedMethods",
    value: function stubRemovedMethods(className, version, methodNames) {
      return (0, _utils.stubRemovedMethods)(this, className, version, methodNames);
    }
  }, {
    key: "initialize",
    value: function initialize(opts) {}
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_getOptsFromHandle",
    value: function _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname, opts) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_setParameter",
    value: function _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_context",
    value: function _context() {
      this.gl.luma = this.gl.luma || {};
      return this.gl.luma;
    }
  }, {
    key: "_addStats",
    value: function _addStats() {
      var name = this.constructor.name;

      var stats = _init.lumaStats.get('Resource Counts');

      stats.get('Resources Created').incrementCount();
      stats.get("".concat(name, "s Created")).incrementCount();
      stats.get("".concat(name, "s Active")).incrementCount();
    }
  }, {
    key: "_removeStats",
    value: function _removeStats() {
      var name = this.constructor.name;

      var stats = _init.lumaStats.get('Resource Counts');

      stats.get("".concat(name, "s Active")).decrementCount();
    }
  }, {
    key: "_trackAllocatedMemory",
    value: function _trackAllocatedMemory(bytes) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.name;

      var stats = _init.lumaStats.get('Memory Usage');

      stats.get('GPU Memory').addCount(bytes);
      stats.get("".concat(name, " Memory")).addCount(bytes);
      this.byteLength = bytes;
    }
  }, {
    key: "_trackDeallocatedMemory",
    value: function _trackDeallocatedMemory() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.constructor.name;

      var stats = _init.lumaStats.get('Memory Usage');

      stats.get('GPU Memory').subtractCount(this.byteLength);
      stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
      this.byteLength = 0;
    }
  }, {
    key: "handle",
    get: function get() {
      return this._handle;
    }
  }]);
  return Resource;
}();

exports["default"] = Resource;

},{"../init":382,"../utils":388,"../webgl-utils":399,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],349:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FragmentShader = exports.VertexShader = exports.Shader = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _glslUtils = require("../glsl-utils");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var _resource = _interopRequireDefault(require("./resource"));

var ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';

var Shader = function (_Resource) {
  (0, _inherits2["default"])(Shader, _Resource);
  (0, _createClass2["default"])(Shader, null, [{
    key: "getTypeName",
    value: function getTypeName(shaderType) {
      switch (shaderType) {
        case 35633:
          return 'vertex-shader';

        case 35632:
          return 'fragment-shader';

        default:
          (0, _utils.assert)(false);
          return 'unknown';
      }
    }
  }]);

  function Shader(gl, props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Shader);
    (0, _webglUtils.assertWebGLContext)(gl);
    (0, _utils.assert)(typeof props.source === 'string', ERR_SOURCE);
    var id = (0, _glslUtils.getShaderName)(props.source, null) || props.id || (0, _utils.uid)("unnamed ".concat(Shader.getTypeName(props.shaderType)));
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Shader).call(this, gl, {
      id: id
    }));
    _this.shaderType = props.shaderType;
    _this.source = props.source;

    _this.initialize(props);

    return _this;
  }

  (0, _createClass2["default"])(Shader, [{
    key: "initialize",
    value: function initialize(_ref) {
      var source = _ref.source;
      var shaderName = (0, _glslUtils.getShaderName)(source, null);

      if (shaderName) {
        this.id = (0, _utils.uid)(shaderName);
      }

      this._compile(source);
    }
  }, {
    key: "getParameter",
    value: function getParameter(pname) {
      return this.gl.getShaderParameter(this.handle, pname);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
    }
  }, {
    key: "getName",
    value: function getName() {
      return (0, _glslUtils.getShaderName)(this.source) || 'unnamed-shader';
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return this.gl.getShaderSource(this.handle);
    }
  }, {
    key: "getTranslatedSource",
    value: function getTranslatedSource() {
      var extension = this.gl.getExtension('WEBGL.debug_shaders');
      return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL.debug_shaders not implemented';
    }
  }, {
    key: "_compile",
    value: function _compile() {
      this.gl.shaderSource(this.handle, this.source);
      this.gl.compileShader(this.handle);
      var compileStatus = this.getParameter(35713);

      if (!compileStatus) {
        var infoLog = this.gl.getShaderInfoLog(this.handle);

        var _parseGLSLCompilerErr = (0, _glslUtils.parseGLSLCompilerError)(infoLog, this.source, this.shaderType, this.id),
            shaderName = _parseGLSLCompilerErr.shaderName,
            errors = _parseGLSLCompilerErr.errors,
            warnings = _parseGLSLCompilerErr.warnings;

        _utils.log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();

        _utils.log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();

        throw new Error("GLSL compilation errors in ".concat(shaderName));
      }
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
  }, {
    key: "_getOptsFromHandle",
    value: function _getOptsFromHandle() {
      return {
        type: this.getParameter(35663),
        source: this.getSource()
      };
    }
  }]);
  return Shader;
}(_resource["default"]);

exports.Shader = Shader;

var VertexShader = function (_Shader) {
  (0, _inherits2["default"])(VertexShader, _Shader);

  function VertexShader(gl, props) {
    (0, _classCallCheck2["default"])(this, VertexShader);

    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(VertexShader).call(this, gl, Object.assign({}, props, {
      shaderType: 35633
    })));
  }

  (0, _createClass2["default"])(VertexShader, [{
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createShader(35633);
    }
  }]);
  return VertexShader;
}(Shader);

exports.VertexShader = VertexShader;

var FragmentShader = function (_Shader2) {
  (0, _inherits2["default"])(FragmentShader, _Shader2);

  function FragmentShader(gl, props) {
    (0, _classCallCheck2["default"])(this, FragmentShader);

    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(FragmentShader).call(this, gl, Object.assign({}, props, {
      shaderType: 35632
    })));
  }

  (0, _createClass2["default"])(FragmentShader, [{
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createShader(35632);
    }
  }]);
  return FragmentShader;
}(Shader);

exports.FragmentShader = FragmentShader;

},{"../glsl-utils":380,"../utils":388,"../webgl-utils":399,"./resource":348,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],350:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _texture = _interopRequireDefault(require("./texture"));

var _webglUtils = require("../webgl-utils");

var _loadFile = require("../utils/load-file");

var Texture2D = function (_Texture) {
  (0, _inherits2["default"])(Texture2D, _Texture);
  (0, _createClass2["default"])(Texture2D, null, [{
    key: "isSupported",
    value: function isSupported(gl, opts) {
      return _texture["default"].isSupported(gl, opts);
    }
  }]);

  function Texture2D(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Texture2D);
    (0, _webglUtils.assertWebGLContext)(gl);

    if (props instanceof Promise || typeof props === 'string') {
      props = {
        data: props
      };
    }

    if (typeof props.data === 'string') {
      props = Object.assign({}, props, {
        data: (0, _loadFile.loadImage)(props.data)
      });
    }

    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Texture2D).call(this, gl, Object.assign({}, props, {
      target: 3553
    })));

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  return Texture2D;
}(_texture["default"]);

exports["default"] = Texture2D;

},{"../utils/load-file":392,"../webgl-utils":399,"./texture":354,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],351:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _texture = _interopRequireDefault(require("./texture"));

var _textureFormats = require("./texture-formats");

var _buffer = _interopRequireDefault(require("./buffer"));

var Texture3D = function (_Texture) {
  (0, _inherits2["default"])(Texture3D, _Texture);
  (0, _createClass2["default"])(Texture3D, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      return (0, _webglUtils.isWebGL2)(gl);
    }
  }]);

  function Texture3D(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Texture3D);
    (0, _webglUtils.assertWebGL2Context)(gl);
    props = Object.assign({
      depth: 1
    }, props, {
      target: 32879,
      unpackFlipY: false
    });
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Texture3D).call(this, gl, props));

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(Texture3D, [{
    key: "setImageData",
    value: function setImageData(_ref) {
      var _this2 = this;

      var _ref$level = _ref.level,
          level = _ref$level === void 0 ? 0 : _ref$level,
          _ref$dataFormat = _ref.dataFormat,
          dataFormat = _ref$dataFormat === void 0 ? 6408 : _ref$dataFormat,
          width = _ref.width,
          height = _ref.height,
          _ref$depth = _ref.depth,
          depth = _ref$depth === void 0 ? 1 : _ref$depth,
          _ref$border = _ref.border,
          border = _ref$border === void 0 ? 0 : _ref$border,
          format = _ref.format,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? 5121 : _ref$type,
          _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? 0 : _ref$offset,
          data = _ref.data,
          _ref$parameters = _ref.parameters,
          parameters = _ref$parameters === void 0 ? {} : _ref$parameters;

      this._trackDeallocatedMemory('Texture');

      this.gl.bindTexture(this.target, this.handle);
      (0, _context.withParameters)(this.gl, parameters, function () {
        if (ArrayBuffer.isView(data)) {
          _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, data);
        }

        if (data instanceof _buffer["default"]) {
          _this2.gl.bindBuffer(35052, data.handle);

          _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, offset);
        }
      });

      if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, 'Texture');
      } else {
        var channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        var channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;

        this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');
      }

      this.loaded = true;
      return this;
    }
  }]);
  return Texture3D;
}(_texture["default"]);

exports["default"] = Texture3D;

},{"../context":364,"../webgl-utils":399,"./buffer":339,"./texture":354,"./texture-formats":353,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],352:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _texture = _interopRequireDefault(require("./texture"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var FACES = [34069, 34070, 34071, 34072, 34073, 34074];

var TextureCube = function (_Texture) {
  (0, _inherits2["default"])(TextureCube, _Texture);

  function TextureCube(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, TextureCube);
    (0, _webglUtils.assertWebGLContext)(gl);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(TextureCube).call(this, gl, Object.assign({}, props, {
      target: 34067
    })));

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(TextureCube, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _props$mipmaps = props.mipmaps,
          mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps,
          _props$parameters = props.parameters,
          parameters = _props$parameters === void 0 ? {} : _props$parameters;
      this.opts = props;
      this.setCubeMapImageData(props).then(function () {
        _this2.loaded = true;

        if (mipmaps) {
          _this2.generateMipmap(props);
        }

        _this2.setParameters(parameters);
      });
    }
  }, {
    key: "subImage",
    value: function subImage(_ref) {
      var face = _ref.face,
          data = _ref.data,
          _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y,
          _ref$mipmapLevel = _ref.mipmapLevel,
          mipmapLevel = _ref$mipmapLevel === void 0 ? 0 : _ref$mipmapLevel;
      return this._subImage({
        target: face,
        data: data,
        x: x,
        y: y,
        mipmapLevel: mipmapLevel
      });
    }
  }, {
    key: "setCubeMapImageData",
    value: function () {
      var _setCubeMapImageData = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(_ref2) {
        var _this3 = this;

        var width, height, pixels, data, _ref2$border, border, _ref2$format, format, _ref2$type, type, gl, imageDataMap, resolvedFaces;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                width = _ref2.width, height = _ref2.height, pixels = _ref2.pixels, data = _ref2.data, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? 0 : _ref2$border, _ref2$format = _ref2.format, format = _ref2$format === void 0 ? 6408 : _ref2$format, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? 5121 : _ref2$type;
                gl = this.gl;
                imageDataMap = pixels || data;
                _context.next = 5;
                return Promise.all(FACES.map(function (face) {
                  var facePixels = imageDataMap[face];
                  return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
                }));

              case 5:
                resolvedFaces = _context.sent;
                this.bind();
                FACES.forEach(function (face, index) {
                  if (resolvedFaces[index].length > 1 && _this3.opts.mipmaps !== false) {
                    _utils.log.warn("".concat(_this3.id, " has mipmap and multiple LODs."))();
                  }

                  resolvedFaces[index].forEach(function (image, lodLevel) {
                    if (width && height) {
                      gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
                    } else {
                      gl.texImage2D(face, lodLevel, format, format, type, image);
                    }
                  });
                });
                this.unbind();

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setCubeMapImageData(_x) {
        return _setCubeMapImageData.apply(this, arguments);
      }

      return setCubeMapImageData;
    }()
  }, {
    key: "setImageDataForFace",
    value: function setImageDataForFace(options) {
      var _this4 = this;

      var face = options.face,
          width = options.width,
          height = options.height,
          pixels = options.pixels,
          data = options.data,
          _options$border = options.border,
          border = _options$border === void 0 ? 0 : _options$border,
          _options$format = options.format,
          format = _options$format === void 0 ? 6408 : _options$format,
          _options$type = options.type,
          type = _options$type === void 0 ? 5121 : _options$type;
      var gl = this.gl;
      var imageData = pixels || data;
      this.bind();

      if (imageData instanceof Promise) {
        imageData.then(function (resolvedImageData) {
          return _this4.setImageDataForFace(Object.assign({}, options, {
            face: face,
            data: resolvedImageData,
            pixels: resolvedImageData
          }));
        });
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }

      return this;
    }
  }]);
  return TextureCube;
}(_texture["default"]);

exports["default"] = TextureCube;
TextureCube.FACES = FACES;

},{"../utils":388,"../webgl-utils":399,"./texture":354,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/asyncToGenerator":16,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/regenerator":43}],353:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFormatSupported = isFormatSupported;
exports.isLinearFilteringSupported = isLinearFilteringSupported;
exports.TYPE_SIZES = exports.DATA_FORMAT_CHANNELS = exports.TEXTURE_FORMATS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _webglUtils = require("../webgl-utils");

var _TEXTURE_FORMATS, _DATA_FORMAT_CHANNELS, _TYPE_SIZES;

var TEXTURE_FORMATS = (_TEXTURE_FORMATS = {}, (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 6407, {
  dataFormat: 6407,
  types: [5121, 33635]
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 6408, {
  dataFormat: 6408,
  types: [5121, 32819, 32820]
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 6406, {
  dataFormat: 6406,
  types: [5121]
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 6409, {
  dataFormat: 6409,
  types: [5121]
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 6410, {
  dataFormat: 6410,
  types: [5121]
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 33326, {
  dataFormat: 6403,
  types: [5126],
  gl2: true
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 33328, {
  dataFormat: 33319,
  types: [5126],
  gl2: true
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 34837, {
  dataFormat: 6407,
  types: [5126],
  gl2: true
}), (0, _defineProperty2["default"])(_TEXTURE_FORMATS, 34836, {
  dataFormat: 6408,
  types: [5126],
  gl2: true
}), _TEXTURE_FORMATS);
exports.TEXTURE_FORMATS = TEXTURE_FORMATS;
var DATA_FORMAT_CHANNELS = (_DATA_FORMAT_CHANNELS = {}, (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 6403, 1), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 36244, 1), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 33319, 2), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 33320, 2), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 6407, 3), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 36248, 3), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 6408, 4), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 36249, 4), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 6402, 1), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 34041, 1), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 6406, 1), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 6409, 1), (0, _defineProperty2["default"])(_DATA_FORMAT_CHANNELS, 6410, 2), _DATA_FORMAT_CHANNELS);
exports.DATA_FORMAT_CHANNELS = DATA_FORMAT_CHANNELS;
var TYPE_SIZES = (_TYPE_SIZES = {}, (0, _defineProperty2["default"])(_TYPE_SIZES, 5126, 4), (0, _defineProperty2["default"])(_TYPE_SIZES, 5125, 4), (0, _defineProperty2["default"])(_TYPE_SIZES, 5124, 4), (0, _defineProperty2["default"])(_TYPE_SIZES, 5123, 2), (0, _defineProperty2["default"])(_TYPE_SIZES, 5122, 2), (0, _defineProperty2["default"])(_TYPE_SIZES, 5131, 2), (0, _defineProperty2["default"])(_TYPE_SIZES, 5120, 1), (0, _defineProperty2["default"])(_TYPE_SIZES, 5121, 1), _TYPE_SIZES);
exports.TYPE_SIZES = TYPE_SIZES;

function isFormatSupported(gl, format) {
  var info = TEXTURE_FORMATS[format];

  if (!info) {
    return false;
  }

  if (info.gl1 === undefined && info.gl2 === undefined) {
    return true;
  }

  var value = (0, _webglUtils.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === 'string' ? gl.getExtension(value) : value;
}

function isLinearFilteringSupported(gl, format) {
  var info = TEXTURE_FORMATS[format];

  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension('OES_texture_float_linear');

    case 5131:
      return gl.getExtension('OES_texture_half_float_linear');

    default:
      return true;
  }
}

},{"../webgl-utils":399,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],354:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _textureFormats = require("./texture-formats");

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var NPOT_MIN_FILTERS = [9729, 9728];

var Texture = function (_Resource) {
  (0, _inherits2["default"])(Texture, _Resource);
  (0, _createClass2["default"])(Texture, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          format = _ref.format,
          linearFiltering = _ref.linearFiltering;

      var supported = true;

      if (format) {
        supported = supported && (0, _textureFormats.isFormatSupported)(gl, format);
        supported = supported && (!linearFiltering || (0, _textureFormats.isLinearFilteringSupported)(gl, format));
      }

      return supported;
    }
  }]);

  function Texture(gl, props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Texture);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('texture') : _props$id,
        handle = props.handle,
        target = props.target;
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Texture).call(this, gl, {
      id: id,
      handle: handle
    }));
    _this.target = target;
    _this.textureUnit = undefined;
    _this.loaded = false;
    _this.width = undefined;
    _this.height = undefined;
    _this.depth = undefined;
    _this.format = undefined;
    _this.type = undefined;
    _this.dataFormat = undefined;
    _this.border = undefined;
    _this.textureUnit = undefined;
    _this.mipmaps = undefined;
    return _this;
  }

  (0, _createClass2["default"])(Texture, [{
    key: "toString",
    value: function toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var data = props.data;

      if (data instanceof Promise) {
        data.then(function (resolvedImageData) {
          return _this2.initialize(Object.assign({}, props, {
            pixels: resolvedImageData,
            data: resolvedImageData
          }));
        });
        return this;
      }

      var _props$pixels = props.pixels,
          pixels = _props$pixels === void 0 ? null : _props$pixels,
          _props$format = props.format,
          format = _props$format === void 0 ? 6408 : _props$format,
          _props$border = props.border,
          border = _props$border === void 0 ? 0 : _props$border,
          _props$recreate = props.recreate,
          recreate = _props$recreate === void 0 ? false : _props$recreate,
          _props$parameters = props.parameters,
          parameters = _props$parameters === void 0 ? {} : _props$parameters,
          _props$pixelStore = props.pixelStore,
          pixelStore = _props$pixelStore === void 0 ? {} : _props$pixelStore,
          _props$textureUnit = props.textureUnit,
          textureUnit = _props$textureUnit === void 0 ? undefined : _props$textureUnit,
          _props$unpackFlipY = props.unpackFlipY,
          unpackFlipY = _props$unpackFlipY === void 0 ? true : _props$unpackFlipY;
      var _props$mipmaps = props.mipmaps,
          mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps;

      if (!data) {
        data = pixels;
      }

      var width = props.width,
          height = props.height,
          dataFormat = props.dataFormat,
          type = props.type;
      var _props$depth = props.depth,
          depth = _props$depth === void 0 ? 0 : _props$depth;

      var _this$_deduceParamete = this._deduceParameters({
        format: format,
        type: type,
        dataFormat: dataFormat,
        compressed: false,
        data: data,
        width: width,
        height: height
      });

      width = _this$_deduceParamete.width;
      height = _this$_deduceParamete.height;
      dataFormat = _this$_deduceParamete.dataFormat;
      type = _this$_deduceParamete.type;
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.format = format;
      this.type = type;
      this.dataFormat = dataFormat;
      this.border = border;
      this.textureUnit = textureUnit;

      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }

      var DEFAULT_TEXTURE_SETTINGS = (0, _defineProperty2["default"])({}, 37440, unpackFlipY);
      var glSettings = Object.assign({}, DEFAULT_TEXTURE_SETTINGS, pixelStore);

      if (mipmaps && this._isNPOT()) {
        _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();

        mipmaps = false;

        this._updateForNPOT(parameters);
      }

      this.mipmaps = mipmaps;
      this.setImageData({
        data: data,
        width: width,
        height: height,
        depth: depth,
        format: format,
        type: type,
        dataFormat: dataFormat,
        border: border,
        mipmaps: mipmaps,
        parameters: glSettings
      });

      if (mipmaps) {
        this.generateMipmap();
      }

      this.setParameters(parameters);

      if (recreate) {
        this.data = data;
      }

      return this;
    }
  }, {
    key: "resize",
    value: function resize(_ref2) {
      var height = _ref2.height,
          width = _ref2.width,
          _ref2$mipmaps = _ref2.mipmaps,
          mipmaps = _ref2$mipmaps === void 0 ? false : _ref2$mipmaps;

      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width: width,
          height: height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          border: this.border,
          mipmaps: mipmaps
        });
      }

      return this;
    }
  }, {
    key: "generateMipmap",
    value: function generateMipmap() {
      var _this3 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._isNPOT()) {
        _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();

        return this;
      }

      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      (0, _context.withParameters)(this.gl, params, function () {
        _this3.gl.generateMipmap(_this3.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
  }, {
    key: "setImageData",
    value: function setImageData(options) {
      this._trackDeallocatedMemory('Texture');

      var _options$target = options.target,
          target = _options$target === void 0 ? this.target : _options$target,
          _options$pixels = options.pixels,
          pixels = _options$pixels === void 0 ? null : _options$pixels,
          _options$level = options.level,
          level = _options$level === void 0 ? 0 : _options$level,
          _options$format = options.format,
          format = _options$format === void 0 ? this.format : _options$format,
          _options$border = options.border,
          border = _options$border === void 0 ? this.border : _options$border,
          _options$offset = options.offset,
          offset = _options$offset === void 0 ? 0 : _options$offset,
          _options$parameters = options.parameters,
          parameters = _options$parameters === void 0 ? {} : _options$parameters;
      var _options$data = options.data,
          data = _options$data === void 0 ? null : _options$data,
          _options$type = options.type,
          type = _options$type === void 0 ? this.type : _options$type,
          _options$width = options.width,
          width = _options$width === void 0 ? this.width : _options$width,
          _options$height = options.height,
          height = _options$height === void 0 ? this.height : _options$height,
          _options$dataFormat = options.dataFormat,
          dataFormat = _options$dataFormat === void 0 ? this.dataFormat : _options$dataFormat,
          _options$compressed = options.compressed,
          compressed = _options$compressed === void 0 ? false : _options$compressed;

      if (!data) {
        data = pixels;
      }

      var _this$_deduceParamete2 = this._deduceParameters({
        format: format,
        type: type,
        dataFormat: dataFormat,
        compressed: compressed,
        data: data,
        width: width,
        height: height
      });

      type = _this$_deduceParamete2.type;
      dataFormat = _this$_deduceParamete2.dataFormat;
      compressed = _this$_deduceParamete2.compressed;
      width = _this$_deduceParamete2.width;
      height = _this$_deduceParamete2.height;
      var gl = this.gl;
      gl.bindTexture(this.target, this.handle);
      var dataType = null;

      var _this$_getDataType = this._getDataType({
        data: data,
        compressed: compressed
      });

      data = _this$_getDataType.data;
      dataType = _this$_getDataType.dataType;
      (0, _context.withParameters)(this.gl, parameters, function () {
        switch (dataType) {
          case 'null':
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            break;

          case 'typed-array':
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
            break;

          case 'buffer':
            (0, _webglUtils.assertWebGL2Context)(gl);
            gl.bindBuffer(35052, data.handle || data);
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
            gl.bindBuffer(35052, null);
            break;

          case 'browser-object':
            if ((0, _webglUtils.isWebGL2)(gl)) {
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            } else {
              gl.texImage2D(target, level, format, dataFormat, type, data);
            }

            break;

          case 'compressed':
            gl.compressedTexImage2D(target, level, format, width, height, border, data);
            break;

          default:
            (0, _utils.assert)(false, 'Unknown image data type');
        }
      });

      if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, 'Texture');
      } else {
        var channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        var channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;

        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');
      }

      this.loaded = true;
      return this;
    }
  }, {
    key: "setSubImageData",
    value: function setSubImageData(_ref3) {
      var _this4 = this;

      var _ref3$target = _ref3.target,
          target = _ref3$target === void 0 ? this.target : _ref3$target,
          _ref3$pixels = _ref3.pixels,
          pixels = _ref3$pixels === void 0 ? null : _ref3$pixels,
          _ref3$data = _ref3.data,
          data = _ref3$data === void 0 ? null : _ref3$data,
          _ref3$x = _ref3.x,
          x = _ref3$x === void 0 ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === void 0 ? 0 : _ref3$y,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? this.width : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? this.height : _ref3$height,
          _ref3$level = _ref3.level,
          level = _ref3$level === void 0 ? 0 : _ref3$level,
          _ref3$format = _ref3.format,
          format = _ref3$format === void 0 ? this.format : _ref3$format,
          _ref3$type = _ref3.type,
          type = _ref3$type === void 0 ? this.type : _ref3$type,
          _ref3$dataFormat = _ref3.dataFormat,
          dataFormat = _ref3$dataFormat === void 0 ? this.dataFormat : _ref3$dataFormat,
          _ref3$compressed = _ref3.compressed,
          compressed = _ref3$compressed === void 0 ? false : _ref3$compressed,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
          _ref3$border = _ref3.border,
          border = _ref3$border === void 0 ? this.border : _ref3$border,
          _ref3$parameters = _ref3.parameters,
          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters;

      var _this$_deduceParamete3 = this._deduceParameters({
        format: format,
        type: type,
        dataFormat: dataFormat,
        compressed: compressed,
        data: data,
        width: width,
        height: height
      });

      type = _this$_deduceParamete3.type;
      dataFormat = _this$_deduceParamete3.dataFormat;
      compressed = _this$_deduceParamete3.compressed;
      width = _this$_deduceParamete3.width;
      height = _this$_deduceParamete3.height;
      (0, _utils.assert)(this.depth === 0, 'texSubImage not supported for 3D textures');

      if (!data) {
        data = pixels;
      }

      if (data && data.data) {
        var ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }

      if (data instanceof _buffer["default"]) {
        data = data.handle;
      }

      this.gl.bindTexture(this.target, this.handle);
      (0, _context.withParameters)(this.gl, parameters, function () {
        if (compressed) {
          _this4.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
        } else if (data === null) {
          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
        } else if (data instanceof _webglUtils.WebGLBuffer) {
          (0, _webglUtils.assertWebGL2Context)(_this4.gl);

          _this4.gl.bindBuffer(35052, data);

          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);

          _this4.gl.bindBuffer(35052, null);
        } else if ((0, _webglUtils.isWebGL2)(_this4.gl)) {
          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
        } else {
          _this4.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
  }, {
    key: "copyFramebuffer",
    value: function copyFramebuffer() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();

      return null;
    }
  }, {
    key: "getActiveUnit",
    value: function getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
  }, {
    key: "bind",
    value: function bind() {
      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
      var gl = this.gl;

      if (textureUnit !== undefined) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }

      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
      var gl = this.gl;

      if (textureUnit !== undefined) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }

      gl.bindTexture(this.target, null);
      return textureUnit;
    }
  }, {
    key: "_getDataType",
    value: function _getDataType(_ref4) {
      var data = _ref4.data,
          _ref4$compressed = _ref4.compressed,
          compressed = _ref4$compressed === void 0 ? false : _ref4$compressed;

      if (compressed) {
        return {
          data: data,
          dataType: 'compressed'
        };
      }

      if (data === null) {
        return {
          data: data,
          dataType: 'null'
        };
      }

      if (ArrayBuffer.isView(data)) {
        return {
          data: data,
          dataType: 'typed-array'
        };
      }

      if (data instanceof _buffer["default"]) {
        return {
          data: data.handle,
          dataType: 'buffer'
        };
      }

      if (data instanceof _webglUtils.WebGLBuffer) {
        return {
          data: data,
          dataType: 'buffer'
        };
      }

      return {
        data: data,
        dataType: 'browser-object'
      };
    }
  }, {
    key: "_deduceParameters",
    value: function _deduceParameters(opts) {
      var format = opts.format,
          data = opts.data;
      var width = opts.width,
          height = opts.height,
          dataFormat = opts.dataFormat,
          type = opts.type,
          compressed = opts.compressed;
      var textureFormat = _textureFormats.TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];
      compressed = compressed || textureFormat && textureFormat.compressed;

      var _this$_deduceImageSiz = this._deduceImageSize(data, width, height);

      width = _this$_deduceImageSiz.width;
      height = _this$_deduceImageSiz.height;
      return {
        dataFormat: dataFormat,
        type: type,
        compressed: compressed,
        width: width,
        height: height,
        format: format,
        data: data
      };
    }
  }, {
    key: "_deduceImageSize",
    value: function _deduceImageSize(data, width, height) {
      var size;

      if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
        size = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
        size = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size = {
          width: width >= 0 ? width : 1,
          height: height >= 0 ? height : 1
        };
      } else {
        size = {
          width: width,
          height: height
        };
      }

      (0, _utils.assert)(size, 'Could not deduced texture size');
      (0, _utils.assert)(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
      (0, _utils.assert)(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');
      return size;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createTexture();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteTexture(this.handle);

      this._trackDeallocatedMemory('Texture');
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      switch (pname) {
        case 4096:
          return this.width;

        case 4097:
          return this.height;

        default:
          this.gl.bindTexture(this.target, this.handle);
          var value = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value;
      }
    }
  }, {
    key: "_setParameter",
    value: function _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);
      param = this._getNPOTParam(pname, param);

      switch (pname) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, pname, param);
          break;

        case 4096:
        case 4097:
          (0, _utils.assert)(false);
          break;

        default:
          this.gl.texParameteri(this.target, pname, param);
          break;
      }

      this.gl.bindTexture(this.target, null);
      return this;
    }
  }, {
    key: "_isNPOT",
    value: function _isNPOT() {
      if ((0, _webglUtils.isWebGL2)(this.gl)) {
        return false;
      }

      if (!this.width || !this.height) {
        return false;
      }

      return !(0, _utils.isPowerOfTwo)(this.width) || !(0, _utils.isPowerOfTwo)(this.height);
    }
  }, {
    key: "_updateForNPOT",
    value: function _updateForNPOT(parameters) {
      if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
      }

      if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
      }

      if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
      }
    }
  }, {
    key: "_getNPOTParam",
    value: function _getNPOTParam(pname, param) {
      if (this._isNPOT()) {
        switch (pname) {
          case 10241:
            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
              param = 9729;
            }

            break;

          case 10242:
          case 10243:
            if (param !== 33071) {
              param = 33071;
            }

            break;

          default:
            break;
        }
      }

      return param;
    }
  }]);
  return Texture;
}(_resource["default"]);

exports["default"] = Texture;

},{"../context":364,"../utils":388,"../webgl-utils":399,"./buffer":339,"./resource":348,"./texture-formats":353,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],355:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var TransformFeedback = function (_Resource) {
  (0, _inherits2["default"])(TransformFeedback, _Resource);
  (0, _createClass2["default"])(TransformFeedback, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      return (0, _webglUtils.isWebGL2)(gl);
    }
  }]);

  function TransformFeedback(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, TransformFeedback);
    (0, _webglUtils.assertWebGL2Context)(gl);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(TransformFeedback).call(this, gl, props));

    _this.initialize(props);

    _this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(TransformFeedback, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.buffers = {};
      this.unused = {};
      this.configuration = null;
      this.bindOnUse = true;

      if (!(0, _utils.isObjectEmpty)(this.buffers)) {
        this.bind(function () {
          return _this2._unbindBuffers();
        });
      }

      this.setProps(props);
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('program' in props) {
        this.configuration = props.program && props.program.configuration;
      }

      if ('configuration' in props) {
        this.configuration = props.configuration;
      }

      if ('bindOnUse' in props) {
        props = props.bindOnUse;
      }

      if ('buffers' in props) {
        this.setBuffers(props.buffers);
      }
    }
  }, {
    key: "setBuffers",
    value: function setBuffers() {
      var _this3 = this;

      var buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.bind(function () {
        for (var bufferName in buffers) {
          _this3.setBuffer(bufferName, buffers[bufferName]);
        }
      });
      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(locationOrName, bufferOrParams) {
      var _this4 = this;

      var location = this._getVaryingIndex(locationOrName);

      var _this$_getBufferParam = this._getBufferParams(bufferOrParams),
          buffer = _this$_getBufferParam.buffer,
          byteSize = _this$_getBufferParam.byteSize,
          byteOffset = _this$_getBufferParam.byteOffset;

      if (location < 0) {
        this.unused[locationOrName] = buffer;

        _utils.log.warn(function () {
          return "".concat(_this4.id, " unused varying buffer ").concat(locationOrName);
        })();

        return this;
      }

      this.buffers[location] = bufferOrParams;

      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteSize);
      }

      return this;
    }
  }, {
    key: "begin",
    value: function begin() {
      var primitiveMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.gl.bindTransformFeedback(36386, this.handle);

      this._bindBuffers();

      this.gl.beginTransformFeedback(primitiveMode);
      return this;
    }
  }, {
    key: "end",
    value: function end() {
      this.gl.endTransformFeedback();

      this._unbindBuffers();

      this.gl.bindTransformFeedback(36386, null);
      return this;
    }
  }, {
    key: "_getBufferParams",
    value: function _getBufferParams(bufferOrParams) {
      var byteOffset;
      var byteSize;
      var buffer;

      if (bufferOrParams instanceof _buffer["default"] === false) {
        buffer = bufferOrParams.buffer;
        byteSize = bufferOrParams.byteSize;
        byteOffset = bufferOrParams.byteOffset;
      } else {
        buffer = bufferOrParams;
      }

      if (byteOffset !== undefined || byteSize !== undefined) {
        byteOffset = byteOffset || 0;
        byteSize = byteSize || buffer.byteLength - byteOffset;
      }

      return {
        buffer: buffer,
        byteOffset: byteOffset,
        byteSize: byteSize
      };
    }
  }, {
    key: "_getVaryingInfo",
    value: function _getVaryingInfo(locationOrName) {
      return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
  }, {
    key: "_getVaryingIndex",
    value: function _getVaryingIndex(locationOrName) {
      if (this.configuration) {
        return this.configuration.getVaryingInfo(locationOrName).location;
      }

      var location = Number(locationOrName);
      return Number.isFinite(location) ? location : -1;
    }
  }, {
    key: "_bindBuffers",
    value: function _bindBuffers() {
      if (this.bindOnUse) {
        for (var bufferIndex in this.buffers) {
          var _this$_getBufferParam2 = this._getBufferParams(this.buffers[bufferIndex]),
              buffer = _this$_getBufferParam2.buffer,
              byteSize = _this$_getBufferParam2.byteSize,
              byteOffset = _this$_getBufferParam2.byteOffset;

          this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
      }
    }
  }, {
    key: "_unbindBuffers",
    value: function _unbindBuffers() {
      if (this.bindOnUse) {
        for (var bufferIndex in this.buffers) {
          this._bindBuffer(bufferIndex, null);
        }
      }
    }
  }, {
    key: "_bindBuffer",
    value: function _bindBuffer(index, buffer) {
      var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var byteSize = arguments.length > 3 ? arguments[3] : undefined;
      var handle = buffer && buffer.handle;

      if (!handle || byteSize === undefined) {
        this.gl.bindBufferBase(35982, index, handle);
      } else {
        this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
      }

      return this;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createTransformFeedback();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      this.gl.bindTransformFeedback(36386, this.handle);
    }
  }]);
  return TransformFeedback;
}(_resource["default"]);

exports["default"] = TransformFeedback;

},{"../utils":388,"../webgl-utils":399,"./buffer":339,"./resource":348,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],356:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _utils = require("../utils");

var ERR_ARGUMENT = 'UniformBufferLayout illegal argument';
var GL_FLOAT = 0x1406;
var GL_INT = 0x1404;
var GL_UNSIGNED_INT = 0x1405;

var UniformBufferLayout = function () {
  function UniformBufferLayout(layout) {
    var _this$typedArray;

    (0, _classCallCheck2["default"])(this, UniformBufferLayout);
    this.layout = {};
    this.size = 0;

    for (var key in layout) {
      this._addUniform(key, layout[key]);
    }

    this.size += (4 - this.size % 4) % 4;
    var data = new Float32Array(this.size);
    this.typedArray = (_this$typedArray = {}, (0, _defineProperty2["default"])(_this$typedArray, GL_FLOAT, data), (0, _defineProperty2["default"])(_this$typedArray, GL_INT, new Int32Array(data.buffer)), (0, _defineProperty2["default"])(_this$typedArray, GL_UNSIGNED_INT, new Uint32Array(data.buffer)), _this$typedArray);
  }

  (0, _createClass2["default"])(UniformBufferLayout, [{
    key: "getBytes",
    value: function getBytes() {
      return this.size * 4;
    }
  }, {
    key: "getData",
    value: function getData() {
      return this.typedArray[GL_FLOAT];
    }
  }, {
    key: "getSubData",
    value: function getSubData(index) {
      var data;
      var offset;

      if (index === undefined) {
        data = this.data;
        offset = 0;
      } else {
        var begin = this.offsets[index];
        var end = begin + this.sizes[index];
        data = this.data.subarray(begin, end);
        offset = begin * 4;
      }

      return {
        data: data,
        offset: offset
      };
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(values) {
      for (var key in values) {
        this._setValue(key, values[key]);
      }

      return this;
    }
  }, {
    key: "_setValue",
    value: function _setValue(key, value) {
      var layout = this.layout[key];
      (0, _utils.assert)(layout, 'UniformLayoutStd140 illegal argument');
      var typedArray = this.typedArray[layout.type];

      if (layout.size === 1) {
        typedArray[layout.offset] = value;
      } else {
        typedArray.set(value, layout.offset);
      }
    }
  }, {
    key: "_addUniform",
    value: function _addUniform(key, uniformType) {
      var typeAndComponents = (0, _attributeUtils.decomposeCompositeGLType)(uniformType);
      (0, _utils.assert)(typeAndComponents, ERR_ARGUMENT);
      var type = typeAndComponents.type,
          count = typeAndComponents.components;
      this.size = this._alignTo(this.size, count);
      var offset = this.size;
      this.size += count;
      this.layout[key] = {
        type: type,
        size: count,
        offset: offset
      };
    }
  }, {
    key: "_alignTo",
    value: function _alignTo(size, count) {
      switch (count) {
        case 1:
          return size;

        case 2:
          return size + size % 2;

        default:
          return size + (4 - size % 4) % 4;
      }
    }
  }]);
  return UniformBufferLayout;
}();

exports["default"] = UniformBufferLayout;

},{"../utils":388,"../webgl-utils/attribute-utils":396,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],357:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseUniformName = parseUniformName;
exports.getUniformSetter = getUniformSetter;
exports.checkUniformValues = checkUniformValues;
exports.areUniformsEqual = areUniformsEqual;
exports.getUniformCopy = getUniformCopy;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));

var _texture = _interopRequireDefault(require("./texture"));

var _utils = require("../utils");

var _UNIFORM_SETTERS;

var UNIFORM_SETTERS = (_UNIFORM_SETTERS = {}, (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 5126, function (gl, location, value) {
  return gl.uniform1fv(location, toFloatArray(value, 1));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35664, function (gl, location, value) {
  return gl.uniform2fv(location, toFloatArray(value, 2));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35665, function (gl, location, value) {
  return gl.uniform3fv(location, toFloatArray(value, 3));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35666, function (gl, location, value) {
  return gl.uniform4fv(location, toFloatArray(value, 4));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 5124, function (gl, location, value) {
  return gl.uniform1iv(location, toIntArray(value, 1));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35667, function (gl, location, value) {
  return gl.uniform2iv(location, toIntArray(value, 2));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35668, function (gl, location, value) {
  return gl.uniform3iv(location, toIntArray(value, 3));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35669, function (gl, location, value) {
  return gl.uniform4iv(location, toIntArray(value, 4));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35670, function (gl, location, value) {
  return gl.uniform1iv(location, toIntArray(value, 1));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35671, function (gl, location, value) {
  return gl.uniform2iv(location, toIntArray(value, 2));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35672, function (gl, location, value) {
  return gl.uniform3iv(location, toIntArray(value, 3));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35673, function (gl, location, value) {
  return gl.uniform4iv(location, toIntArray(value, 4));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35674, function (gl, location, value) {
  return gl.uniformMatrix2fv(location, false, toFloatArray(value, 4));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35675, function (gl, location, value) {
  return gl.uniformMatrix3fv(location, false, toFloatArray(value, 9));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35676, function (gl, location, value) {
  return gl.uniformMatrix4fv(location, false, toFloatArray(value, 16));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35678, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35680, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 5125, function (gl, location, value) {
  return gl.uniform1uiv(location, toUIntArray(value, 1));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36294, function (gl, location, value) {
  return gl.uniform2uiv(location, toUIntArray(value, 2));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36295, function (gl, location, value) {
  return gl.uniform3uiv(location, toUIntArray(value, 3));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36296, function (gl, location, value) {
  return gl.uniform4uiv(location, toUIntArray(value, 4));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35685, function (gl, location, value) {
  return gl.uniformMatrix2x3fv(location, false, toFloatArray(value, 6));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35686, function (gl, location, value) {
  return gl.uniformMatrix2x4fv(location, false, toFloatArray(value, 8));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35687, function (gl, location, value) {
  return gl.uniformMatrix3x2fv(location, false, toFloatArray(value, 6));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35688, function (gl, location, value) {
  return gl.uniformMatrix3x4fv(location, false, toFloatArray(value, 12));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35689, function (gl, location, value) {
  return gl.uniformMatrix4x2fv(location, false, toFloatArray(value, 8));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35690, function (gl, location, value) {
  return gl.uniformMatrix4x3fv(location, false, toFloatArray(value, 12));
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35679, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 35682, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36289, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36292, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36293, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36298, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36299, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36300, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36303, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36306, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36307, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36308, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2["default"])(_UNIFORM_SETTERS, 36311, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), _UNIFORM_SETTERS);
var FLOAT_ARRAY = {};
var INT_ARRAY = {};
var UINT_ARRAY = {};
var array1 = [0];

function toTypedArray(value, uniformLength, Type, cache) {
  if (uniformLength === 1 && typeof value === 'boolean') {
    value = value ? 1 : 0;
  }

  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }

  var length = value.length;

  if (length % uniformLength) {
    _utils.log.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
  }

  if (value instanceof Type) {
    return value;
  }

  var result = cache[length];

  if (!result) {
    result = new Type(length);
    cache[length] = result;
  }

  for (var i = 0; i < length; i++) {
    result[i] = value[i];
  }

  return result;
}

function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}

function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}

function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}

function parseUniformName(name) {
  if (name[name.length - 1] !== ']') {
    return {
      name: name,
      length: 1,
      isArray: false
    };
  }

  var UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  var matches = name.match(UNIFORM_NAME_REGEXP);

  if (!matches || matches.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }

  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}

function getUniformSetter(gl, location, info) {
  var setter = UNIFORM_SETTERS[info.type];

  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }

  return setter.bind(null, gl, location);
}

function checkUniformValues(uniforms, source, uniformMap) {
  for (var uniformName in uniforms) {
    var value = uniforms[uniformName];
    var shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);

    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? "".concat(source, " ") : '';
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }

  return true;
}

function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }

  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof _texture["default"]) {
    return true;
  } else if (value instanceof _renderbuffer["default"]) {
    return true;
  } else if (value instanceof _framebuffer["default"]) {
    return Boolean(value.texture);
  }

  return false;
}

function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }

  var checkLength = Math.min(value.length, 16);

  for (var i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }

  return true;
}

function areUniformsEqual(uniform1, uniform2) {
  if (Array.isArray(uniform1) || ArrayBuffer.isView(uniform1)) {
    if (!uniform2) {
      return false;
    }

    var len = uniform1.length;

    if (uniform2.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      if (uniform1[i] !== uniform2[i]) {
        return false;
      }
    }

    return true;
  }

  return uniform1 === uniform2;
}

function getUniformCopy(uniform) {
  if (Array.isArray(uniform) || ArrayBuffer.isView(uniform)) {
    return uniform.slice();
  }

  return uniform;
}

},{"../utils":388,"./framebuffer":342,"./renderbuffer":347,"./texture":354,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],358:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _webglUtils = require("../webgl-utils");

var _arrayUtilsFlat = require("../utils/array-utils-flat");

var _utils = require("../utils");

var _probe = require("probe.gl");

var OES_vertex_array_object = 'OES_vertex_array_object';
var ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';

var VertexArrayObject = function (_Resource) {
  (0, _inherits2["default"])(VertexArrayObject, _Resource);
  (0, _createClass2["default"])(VertexArrayObject, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.constantAttributeZero) {
        return (0, _webglUtils.isWebGL2)(gl) || (0, _probe.getBrowser)() === 'Chrome';
      }

      return (0, _webglUtils.isWebGL2)(gl) || gl.getExtension(OES_vertex_array_object);
    }
  }, {
    key: "getDefaultArray",
    value: function getDefaultArray(gl) {
      gl.luma = gl.luma || {};

      if (!gl.luma.defaultVertexArray) {
        gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
          handle: null
        });
      }

      return gl.luma.defaultVertexArray;
    }
  }, {
    key: "getMaxAttributes",
    value: function getMaxAttributes(gl) {
      VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
      return VertexArrayObject.MAX_ATTRIBUTES;
    }
  }, {
    key: "setConstant",
    value: function setConstant(gl, location, array) {
      switch (array.constructor) {
        case Float32Array:
          VertexArrayObject._setConstantFloatArray(gl, location, array);

          break;

        case Int32Array:
          VertexArrayObject._setConstantIntArray(gl, location, array);

          break;

        case Uint32Array:
          VertexArrayObject._setConstantUintArray(gl, location, array);

          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }]);

  function VertexArrayObject(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, VertexArrayObject);
    var id = opts.id || opts.program && opts.program.id;
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(VertexArrayObject).call(this, gl, Object.assign({}, opts, {
      id: id
    })));
    _this.hasVertexArrays = VertexArrayObject.isSupported(gl);
    _this.buffer = null;
    _this.bufferValue = null;

    _this.initialize(opts);

    Object.seal((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }

  (0, _createClass2["default"])(VertexArrayObject, [{
    key: "delete",
    value: function _delete() {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(VertexArrayObject.prototype), "delete", this).call(this);

      if (this.buffer) {
        this.buffer["delete"]();
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setProps(props);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      return this;
    }
  }, {
    key: "setElementBuffer",
    value: function setElementBuffer() {
      var _this2 = this;

      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _utils.assert)(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
      this.bind(function () {
        _this2.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
      });
      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(location, buffer, accessor) {
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, accessor);
      }

      var size = accessor.size,
          type = accessor.type,
          stride = accessor.stride,
          offset = accessor.offset,
          normalized = accessor.normalized,
          integer = accessor.integer,
          divisor = accessor.divisor;
      var gl = this.gl;
      location = Number(location);
      this.bind(function () {
        gl.bindBuffer(34962, buffer.handle);

        if (integer) {
          (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));
          gl.vertexAttribIPointer(location, size, type, stride, offset);
        } else {
          gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        }

        gl.enableVertexAttribArray(location);
        gl.vertexAttribDivisor(location, divisor || 0);
      });
      return this;
    }
  }, {
    key: "enable",
    value: function enable(location) {
      var _this3 = this;

      var _enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var disablingAttributeZero = !_enable && location === 0 && !VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      });

      if (!disablingAttributeZero) {
        location = Number(location);
        this.bind(function () {
          return _enable ? _this3.gl.enableVertexAttribArray(location) : _this3.gl.disableVertexAttribArray(location);
        });
      }

      return this;
    }
  }, {
    key: "getConstantBuffer",
    value: function getConstantBuffer(elementCount, value, accessor) {
      var constantValue = this._normalizeConstantArrayValue(value, accessor);

      var byteLength = constantValue.byteLength * elementCount;
      var length = constantValue.length * elementCount;
      var updateNeeded = !this.buffer;
      this.buffer = this.buffer || new _buffer["default"](this.gl, byteLength);
      updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
      updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);

      if (updateNeeded) {
        var typedArray = (0, _arrayUtilsFlat.getScratchArray)(value.constructor, length);
        (0, _arrayUtilsFlat.fillArray)({
          target: typedArray,
          source: constantValue,
          start: 0,
          count: length
        });
        this.buffer.subData(typedArray);
        this.bufferValue = value;
      }

      return this.buffer;
    }
  }, {
    key: "_normalizeConstantArrayValue",
    value: function _normalizeConstantArrayValue(arrayValue, accessor) {
      if (Array.isArray(arrayValue)) {
        return new Float32Array(arrayValue);
      }

      return arrayValue;
    }
  }, {
    key: "_compareConstantArrayValues",
    value: function _compareConstantArrayValues(v1, v2) {
      if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
      }

      for (var i = 0; i < v1.length; ++i) {
        if (v1[i] !== v2[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      this.hasVertexArrays = VertexArrayObject.isSupported(this.gl);

      if (this.hasVertexArrays) {
        return this.gl.createVertexArray();
      }

      return null;
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle(handle) {
      if (this.hasVertexArrays) {
        this.gl.deleteVertexArray(handle);
      }

      return [this.elements];
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      if (this.hasVertexArrays) {
        this.gl.bindVertexArray(handle);
      }
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname, _ref) {
      var _this4 = this;

      var location = _ref.location;
      (0, _utils.assert)(Number.isFinite(location));
      return this.bind(function () {
        switch (pname) {
          case 34373:
            return _this4.gl.getVertexAttribOffset(location, pname);

          default:
            return _this4.gl.getVertexAttrib(location, pname);
        }
      });
    }
  }, {
    key: "MAX_ATTRIBUTES",
    get: function get() {
      return VertexArrayObject.getMaxAttributes(this.gl);
    }
  }], [{
    key: "_setConstantFloatArray",
    value: function _setConstantFloatArray(gl, location, array) {
      switch (array.length) {
        case 1:
          gl.vertexAttrib1fv(location, array);
          break;

        case 2:
          gl.vertexAttrib2fv(location, array);
          break;

        case 3:
          gl.vertexAttrib3fv(location, array);
          break;

        case 4:
          gl.vertexAttrib4fv(location, array);
          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }, {
    key: "_setConstantIntArray",
    value: function _setConstantIntArray(gl, location, array) {
      (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));

      switch (array.length) {
        case 1:
          gl.vertexAttribI1iv(location, array);
          break;

        case 2:
          gl.vertexAttribI2iv(location, array);
          break;

        case 3:
          gl.vertexAttribI3iv(location, array);
          break;

        case 4:
          gl.vertexAttribI4iv(location, array);
          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }, {
    key: "_setConstantUintArray",
    value: function _setConstantUintArray(gl, location, array) {
      (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));

      switch (array.length) {
        case 1:
          gl.vertexAttribI1uiv(location, array);
          break;

        case 2:
          gl.vertexAttribI2uiv(location, array);
          break;

        case 3:
          gl.vertexAttribI3uiv(location, array);
          break;

        case 4:
          gl.vertexAttribI4uiv(location, array);
          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }]);
  return VertexArrayObject;
}(_resource["default"]);

exports["default"] = VertexArrayObject;

},{"../utils":388,"../utils/array-utils-flat":383,"../webgl-utils":399,"./buffer":339,"./resource":348,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/get":22,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"probe.gl":444}],359:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _accessor2 = _interopRequireDefault(require("./accessor"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _vertexArrayObject = _interopRequireDefault(require("./vertex-array-object"));

var _utils = require("../utils");

var ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';
var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
var DEPRECATIONS_V6 = ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable'];

var VertexArray = function () {
  function VertexArray(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, VertexArray);
    var id = opts.id || opts.program && opts.program.id;
    this.id = id;
    this.gl = gl;
    this.configuration = null;
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null;
    this.vertexArrayObject = _vertexArrayObject["default"].isSupported(gl) ? new _vertexArrayObject["default"](gl) : _vertexArrayObject["default"].getDefaultArray(gl);
    (0, _utils.stubRemovedMethods)(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);
    this.initialize(opts);
    Object.seal(this);
  }

  (0, _createClass2["default"])(VertexArray, [{
    key: "delete",
    value: function _delete() {
      if (this.buffer) {
        this.buffer["delete"]();
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.reset();
      this.configuration = null;
      this.bindOnUse = false;
      return this.setProps(props);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.elements = null;
      this.elementsAccessor = null;
      var MAX_ATTRIBUTES = this.vertexArrayObject.MAX_ATTRIBUTES;
      this.values = new Array(MAX_ATTRIBUTES).fill(null);
      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
      this.unused = {};
      this.drawParams = null;
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('program' in props) {
        this.configuration = props.program && props.program.configuration;
      }

      if ('configuration' in props) {
        this.configuration = props.configuration;
      }

      if ('attributes' in props) {
        this.setAttributes(props.attributes);
      }

      if ('elements' in props) {
        this.setElementBuffer(props.elements);
      }

      if ('bindOnUse' in props) {
        props = props.bindOnUse;
      }

      return this;
    }
  }, {
    key: "clearDrawParams",
    value: function clearDrawParams() {
      this.drawParams = null;
    }
  }, {
    key: "getDrawParams",
    value: function getDrawParams(appParameters) {
      this.drawParams = this.drawParams || this._updateDrawParams();
      return Object.assign({}, this.drawParams, appParameters);
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      var _this = this;

      this.vertexArrayObject.bind(function () {
        for (var locationOrName in attributes) {
          var value = attributes[locationOrName];

          _this._setAttribute(locationOrName, value);
        }

        _this.gl.bindBuffer(34962, null);
      });
      return this;
    }
  }, {
    key: "setElementBuffer",
    value: function setElementBuffer() {
      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.elements = elementBuffer;
      this.elementsAccessor = accessor;
      this.clearDrawParams();

      if (!this.vertexArrayObject.isDefaultArray) {
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
      }

      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(locationOrName, buffer) {
      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, appAccessor);
      }

      var _this$_resolveLocatio = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor),
          location = _this$_resolveLocatio.location,
          accessor = _this$_resolveLocatio.accessor;

      if (location >= 0) {
        this.values[location] = buffer;
        this.accessors[location] = accessor;
        this.clearDrawParams();

        if (!this.vertexArrayObject.isDefaultArray) {
          this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
      }

      return this;
    }
  }, {
    key: "setConstant",
    value: function setConstant(locationOrName, arrayValue) {
      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _this$_resolveLocatio2 = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
        size: arrayValue.length
      }, appAccessor)),
          location = _this$_resolveLocatio2.location,
          accessor = _this$_resolveLocatio2.accessor;

      if (location >= 0) {
        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue, accessor);
        this.values[location] = arrayValue;
        this.accessors[location] = accessor;
        this.clearDrawParams();

        if (!this.vertexArrayObject.isDefaultArray) {
          this.vertexArrayObject.enable(location, false);
        }
      }

      return this;
    }
  }, {
    key: "unbindBuffers",
    value: function unbindBuffers() {
      var _this2 = this;

      this.vertexArrayObject.bind(function () {
        if (_this2.elements) {
          _this2.setElementBuffer(null);
        }

        _this2.buffer = _this2.buffer || new _buffer["default"](_this2.gl, {
          accessor: {
            size: 4
          }
        });

        for (var location = 0; location < _this2.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          if (_this2.values[location] instanceof _buffer["default"]) {
            _this2.gl.disableVertexAttribArray(location);

            _this2.gl.bindBuffer(34962, _this2.buffer.handle);

            _this2.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
          }
        }
      });
      return this;
    }
  }, {
    key: "bindBuffers",
    value: function bindBuffers() {
      var _this3 = this;

      this.vertexArrayObject.bind(function () {
        if (_this3.elements) {
          _this3.setElementBuffer(_this3.elements);
        }

        for (var location = 0; location < _this3.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          var buffer = _this3.values[location];

          if (buffer instanceof _buffer["default"]) {
            _this3.setBuffer(location, buffer);
          }
        }
      });
      return this;
    }
  }, {
    key: "bindForDraw",
    value: function bindForDraw(vertexCount, instanceCount, func) {
      var _this4 = this;

      var value;
      this.vertexArrayObject.bind(function () {
        _this4._setConstantAttributes(vertexCount, instanceCount);

        if (!_this4.vertexArrayObject.hasVertexArrays) {
          _this4.bindBuffers();
        }

        value = func();

        if (!_this4.vertexArrayObject.hasVertexArrays) {
          _this4.unbindBuffers();
        }
      });
      return value;
    }
  }, {
    key: "_resolveLocationAndAccessor",
    value: function _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
      var _this5 = this;

      var _this$_getAttributeIn = this._getAttributeIndex(locationOrName),
          location = _this$_getAttributeIn.location,
          name = _this$_getAttributeIn.name;

      if (!Number.isFinite(location) || location < 0) {
        this.unused[locationOrName] = value;

        _utils.log.once(3, function () {
          return "unused value ".concat(locationOrName, " in ").concat(_this5.id);
        })();

        return this;
      }

      var accessInfo = this._getAttributeInfo(name || location);

      if (!accessInfo) {
        return {
          location: -1,
          accessor: null
        };
      }

      var accessor = _accessor2["default"].resolve(accessInfo.accessor, valueAccessor, appAccessor);

      var size = accessor.size,
          type = accessor.type;
      (0, _utils.assert)(Number.isFinite(size) && Number.isFinite(type));
      return {
        location: location,
        accessor: accessor
      };
    }
  }, {
    key: "_getAttributeInfo",
    value: function _getAttributeInfo(attributeName) {
      return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
  }, {
    key: "_getAttributeIndex",
    value: function _getAttributeIndex(locationOrName) {
      var location = Number(locationOrName);

      if (Number.isFinite(location)) {
        return {
          location: location
        };
      }

      var multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
      var name = multiLocation ? multiLocation[1] : locationOrName;
      var locationOffset = multiLocation ? Number(multiLocation[2]) : 0;

      if (this.configuration) {
        return {
          location: this.configuration.getAttributeLocation(name) + locationOffset,
          name: name
        };
      }

      return {
        location: -1
      };
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(locationOrName, value) {
      if (value instanceof _buffer["default"]) {
        this.setBuffer(locationOrName, value);
      } else if (Array.isArray(value) && value.length && value[0] instanceof _buffer["default"]) {
        var buffer = value[0];
        var accessor = value[1];
        this.setBuffer(locationOrName, buffer, accessor);
      } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
        var constant = value;
        this.setConstant(locationOrName, constant);
      } else if (value.buffer instanceof _buffer["default"]) {
        var _accessor = value;
        this.setBuffer(locationOrName, _accessor.buffer, _accessor);
      } else {
        throw new Error(ERR_ATTRIBUTE_TYPE);
      }
    }
  }, {
    key: "_setConstantAttributes",
    value: function _setConstantAttributes(vertexCount, instanceCount) {
      var elementCount = Math.max(vertexCount | 0, instanceCount | 0);
      var constant = this.values[0];

      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttributeZero(constant, elementCount);
      }

      for (var location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        constant = this.values[location];

        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttribute(location, constant);
        }
      }
    }
  }, {
    key: "_setConstantAttributeZero",
    value: function _setConstantAttributeZero(constant, elementCount) {
      if (_vertexArrayObject["default"].isSupported(this.gl, {
        constantAttributeZero: true
      })) {
        this._setConstantAttribute(0, constant);

        return;
      }

      var buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
  }, {
    key: "_setConstantAttribute",
    value: function _setConstantAttribute(location, constant) {
      _vertexArrayObject["default"].setConstant(this.gl, location, constant);

      if (this.vertexArrayObject.isDefault) {
        this.vertexArrayObject.enable(location, false);
      }
    }
  }, {
    key: "_updateDrawParams",
    value: function _updateDrawParams() {
      var drawParams = {
        isIndexed: false,
        isInstanced: false,
        indexCount: Infinity,
        vertexCount: Infinity,
        instanceCount: Infinity
      };

      for (var location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        this._updateDrawParamsForLocation(drawParams, location);
      }

      if (this.elements) {
        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
        drawParams.isIndexed = true;
        drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
        drawParams.indexOffset = this.elementsAccessor.offset || 0;
      }

      if (drawParams.indexCount === Infinity) {
        drawParams.indexCount = 0;
      }

      if (drawParams.vertexCount === Infinity) {
        drawParams.vertexCount = 0;
      }

      if (drawParams.instanceCount === Infinity) {
        drawParams.instanceCount = 0;
      }

      return drawParams;
    }
  }, {
    key: "_updateDrawParamsForLocation",
    value: function _updateDrawParamsForLocation(drawParams, location) {
      var value = this.values[location];
      var accessor = this.accessors[location];

      if (!value) {
        return;
      }

      var divisor = accessor.divisor;
      var isInstanced = divisor > 0;
      drawParams.isInstanced = drawParams.isInstanced || isInstanced;

      if (value instanceof _buffer["default"]) {
        var buffer = value;

        if (isInstanced) {
          var instanceCount = buffer.getVertexCount(accessor);
          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
        } else {
          var vertexCount = buffer.getVertexCount(accessor);
          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
        }
      }
    }
  }, {
    key: "setElements",
    value: function setElements() {
      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _utils.log.deprecated('setElements', 'setElementBuffer')();

      return this.setElementBuffer(elementBuffer, accessor);
    }
  }]);
  return VertexArray;
}();

exports["default"] = VertexArray;

},{"../utils":388,"./accessor":338,"./buffer":339,"./vertex-array-object":358,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],360:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWebGL = isWebGL;
exports.isWebGL2 = isWebGL2;
exports.assertWebGLContext = assertWebGLContext;
exports.assertWebGL2Context = assertWebGL2Context;
exports.setGLContextDefaults = setGLContextDefaults;
exports.createGLContext = createGLContext;
exports.instrumentGLContext = instrumentGLContext;
exports.destroyGLContext = destroyGLContext;
exports.resizeGLContext = resizeGLContext;
exports.ERR_WEBGL2 = exports.ERR_WEBGL = exports.ERR_CONTEXT = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _createHeadlessContext = require("./create-headless-context");

var _createCanvas = require("./create-canvas");

var _createBrowserContext = require("./create-browser-context");

var _getContextDebugInfo = require("../debug/get-context-debug-info");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var _globals = require("../utils/globals");

var ERR_CONTEXT = 'Invalid WebGLRenderingContext';
exports.ERR_CONTEXT = ERR_CONTEXT;
var ERR_WEBGL = ERR_CONTEXT;
exports.ERR_WEBGL = ERR_WEBGL;
var ERR_WEBGL2 = 'Requires WebGL2';
exports.ERR_WEBGL2 = ERR_WEBGL2;

function isWebGL(gl) {
  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function assertWebGLContext(gl) {
  (0, _utils.assert)(isWebGL(gl), ERR_CONTEXT);
}

function assertWebGL2Context(gl) {
  (0, _utils.assert)(isWebGL2(gl), ERR_WEBGL2);
}

var contextDefaults = {
  webgl2: true,
  webgl1: true,
  throwOnFailure: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};

function setGLContextDefaults() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  Object.assign(contextDefaults, {
    width: 1,
    height: 1
  }, options);
}

function createGLContext() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  options = Object.assign({}, contextDefaults, options);
  var _options = options,
      width = _options.width,
      height = _options.height;

  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }

    return null;
  }

  var gl;

  if (_utils.isBrowser) {
    var _options2 = options,
        canvas = _options2.canvas;
    var targetCanvas = (0, _createCanvas.getCanvas)({
      canvas: canvas,
      width: width,
      height: height,
      onError: onError
    });
    gl = (0, _createBrowserContext.createBrowserContext)(targetCanvas, options);
  } else {
    gl = (0, _createHeadlessContext.createHeadlessContext)((0, _objectSpread2["default"])({}, options, {
      width: width,
      height: height,
      onError: onError
    }));
  }

  if (!gl) {
    return null;
  }

  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}

function instrumentGLContext(gl) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (gl._instrumented) {
    return gl;
  }

  gl._version = gl._version || getVersion(gl);
  options = Object.assign({}, contextDefaults, options);
  var _options3 = options,
      manageState = _options3.manageState,
      debug = _options3.debug;

  if (manageState) {
    (0, _webglStateTracker.trackContextState)(gl, {
      copyState: false,
      log: function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _utils.log.log.apply(_utils.log, [1].concat(args))();
      }
    });
  }

  if (_utils.isBrowser && debug) {
    if (!_globals.global.makeDebugContext) {
      _utils.log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = _globals.global.makeDebugContext(gl, options);
      _utils.log.priority = Math.max(_utils.log.priority, 1);
    }
  }

  gl._instrumented = true;
  return gl;
}

function destroyGLContext(gl) {
  var ext = gl.getExtension('STACKGL_destroy_context');

  if (ext) {
    ext.destroy();
  }
}

function resizeGLContext(gl) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (gl.canvas) {
    var devicePixelRatio = options.useDevicePixels ? window.devicePixelRatio || 1 : 1;
    var width = "width" in options ? options.width : gl.canvas.clientWidth;
    var height = "height" in options ? options.height : gl.canvas.clientHeight;
    gl.canvas.width = width * devicePixelRatio;
    gl.canvas.height = height * devicePixelRatio;
    return;
  }

  var ext = gl.getExtension('STACKGL_resize_drawingbuffer');

  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}

function logInfo(gl) {
  var webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';
  var info = (0, _getContextDebugInfo.getContextDebugInfo)(gl);
  var driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : '';
  var debug = gl.debug ? ' debug' : '';

  _utils.log.once(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}

function getVersion(gl) {
  if (typeof _webglUtils.WebGL2RenderingContext !== 'undefined' && gl instanceof _webglUtils.WebGL2RenderingContext) {
    return 2;
  }

  return 1;
}

},{"../debug/get-context-debug-info":368,"../utils":388,"../utils/globals":387,"../webgl-utils":399,"./create-browser-context":361,"./create-canvas":362,"./create-headless-context":363,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/objectSpread":32,"@luma.gl/webgl-state-tracker":321}],361:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBrowserContext = createBrowserContext;

function createBrowserContext(canvas, options) {
  var _options$onError = options.onError,
      onError = _options$onError === void 0 ? function (message) {
    return null;
  } : _options$onError;

  var onCreateError = function onCreateError(error) {
    return onError("WebGL context: ".concat(error.statusMessage || 'error'));
  };

  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);
  var _options$webgl = options.webgl1,
      webgl1 = _options$webgl === void 0 ? true : _options$webgl,
      _options$webgl2 = options.webgl2,
      webgl2 = _options$webgl2 === void 0 ? true : _options$webgl2;
  var gl = null;

  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }

  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }

  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);

  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? 'WebGL2' : 'WebGL', " context"));
  }

  return gl;
}

},{}],362:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPageLoadPromise = getPageLoadPromise;
exports.createCanvas = createCanvas;
exports.getCanvas = getCanvas;

var _utils = require("../utils");

var isPage = _utils.isBrowser && typeof document !== 'undefined';
var isPageLoaded = isPage && document.readyState === 'complete';
var pageLoadPromise;

function getPageLoadPromise() {
  if (!pageLoadPromise) {
    pageLoadPromise = isPage ? new Promise(function (resolve, reject) {
      if (isPage && document.readyState === 'complete') {
        isPageLoaded = true;
        resolve(document);
        return;
      }

      window.onload = function () {
        isPageLoaded = true;
        resolve(document);
      };
    }) : Promise.resolve({});
  }

  return pageLoadPromise;
}

function createCanvas(_ref) {
  var _ref$width = _ref.width,
      width = _ref$width === void 0 ? 800 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 600 : _ref$height,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? 'gl-canvas' : _ref$id,
      _ref$insert = _ref.insert,
      insert = _ref$insert === void 0 ? true : _ref$insert;
  var canvas = document.createElement('canvas');
  canvas.id = id;
  canvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : '100%';
  canvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : '100%';

  if (insert) {
    var body = document.body;
    body.insertBefore(canvas, body.firstChild);
  }

  return canvas;
}

function getCanvas(_ref2) {
  var canvas = _ref2.canvas,
      width = _ref2.width,
      height = _ref2.height,
      _ref2$onError = _ref2.onError,
      onError = _ref2$onError === void 0 ? function () {} : _ref2$onError;
  var targetCanvas;

  if (typeof canvas === 'string') {
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }

    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = createCanvas({
      id: 'lumagl-canvas',
      width: width,
      height: height,
      onError: onError
    });
  }

  return targetCanvas;
}

},{"../utils":388}],363:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHeadlessContext = createHeadlessContext;

var _webglTypes = require("../webgl-utils/webgl-types");

var ERR_HEADLESSGL_NOT_AVAILABLE = 'Failed to create WebGL context in Node.js, headless gl not available';
var ERR_HEADLESSGL_FAILED = 'Failed to create WebGL context in Node.js, headless gl returned null';

function createHeadlessContext(options) {
  var width = options.width,
      height = options.height,
      webgl1 = options.webgl1,
      webgl2 = options.webgl2,
      onError = options.onError;

  if (webgl2 && !webgl1) {
    return onError('headless-gl does not support WebGL2');
  }

  if (!_webglTypes.headlessGL) {
    return onError(ERR_HEADLESSGL_NOT_AVAILABLE);
  }

  var gl = (0, _webglTypes.headlessGL)(width, height, options);

  if (!gl) {
    return onError(ERR_HEADLESSGL_FAILED);
  }

  return gl;
}

},{"../webgl-utils/webgl-types":404}],364:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.trackContextState;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.resetParameters;
  }
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.setParameter;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.setParameters;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.withParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getModifiedParameters;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function get() {
    return _context.createGLContext;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function get() {
    return _context.instrumentGLContext;
  }
});
Object.defineProperty(exports, "destroyGLContext", {
  enumerable: true,
  get: function get() {
    return _context.destroyGLContext;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function get() {
    return _context.resizeGLContext;
  }
});
Object.defineProperty(exports, "setGLContextDefaults", {
  enumerable: true,
  get: function get() {
    return _context.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "getPageLoadPromise", {
  enumerable: true,
  get: function get() {
    return _createCanvas.getPageLoadPromise;
  }
});
Object.defineProperty(exports, "getCanvas", {
  enumerable: true,
  get: function get() {
    return _createCanvas.getCanvas;
  }
});

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _context = require("./context");

var _createCanvas = require("./create-canvas");

},{"./context":360,"./create-canvas":362,"@luma.gl/webgl-state-tracker":321}],365:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForProgramConfiguration = getDebugTableForProgramConfiguration;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _attributeUtils = require("../webgl-utils/attribute-utils");

function getDebugTableForProgramConfiguration(config) {
  var table = {};
  var header = "Accessors for ".concat(config.id);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = config.attributeInfos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var attributeInfo = _step.value;

      if (attributeInfo) {
        var glslDeclaration = getGLSLDeclaration(attributeInfo);
        table["in ".concat(glslDeclaration)] = (0, _defineProperty2["default"])({}, header, JSON.stringify(attributeInfo.accessor));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = config.varyingInfos[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var varyingInfo = _step2.value;

      if (varyingInfo) {
        var _glslDeclaration = getGLSLDeclaration(varyingInfo);

        table["out ".concat(_glslDeclaration)] = (0, _defineProperty2["default"])({}, header, JSON.stringify(varyingInfo.accessor));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return table;
}

function getGLSLDeclaration(attributeInfo) {
  var _attributeInfo$access = attributeInfo.accessor,
      type = _attributeInfo$access.type,
      size = _attributeInfo$access.size;
  var typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);

  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }

  return attributeInfo.name;
}

},{"../webgl-utils/attribute-utils":396,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],366:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForUniforms = getDebugTableForUniforms;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("../utils");

function getDebugTableForUniforms() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$header = _ref.header,
      header = _ref$header === void 0 ? 'Uniforms' : _ref$header,
      program = _ref.program,
      uniforms = _ref.uniforms,
      _ref$undefinedOnly = _ref.undefinedOnly,
      undefinedOnly = _ref$undefinedOnly === void 0 ? false : _ref$undefinedOnly;

  (0, _utils.assert)(program);
  var SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
  var PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix';
  var uniformLocations = program._uniformSetters;
  var table = {};
  var uniformNames = Object.keys(uniformLocations).sort();
  var count = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = uniformNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _uniformName = _step.value;

      if (!_uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !_uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table: table,
          header: header,
          uniforms: uniforms,
          uniformName: _uniformName,
          undefinedOnly: undefinedOnly
        })) {
          count++;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = uniformNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _uniformName2 = _step2.value;

      if (_uniformName2.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table: table,
          header: header,
          uniforms: uniforms,
          uniformName: _uniformName2,
          undefinedOnly: undefinedOnly
        })) {
          count++;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = uniformNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _uniformName3 = _step3.value;

      if (!table[_uniformName3]) {
        if (addUniformToTable({
          table: table,
          header: header,
          uniforms: uniforms,
          uniformName: _uniformName3,
          undefinedOnly: undefinedOnly
        })) {
          count++;
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var unusedCount = 0;
  var unusedTable = {};

  if (!undefinedOnly) {
    for (var uniformName in uniforms) {
      var uniform = uniforms[uniformName];

      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = (0, _defineProperty2["default"])({
          Type: "NOT USED: ".concat(uniform)
        }, header, (0, _utils.formatValue)(uniform));
      }
    }
  }

  return {
    table: table,
    count: count,
    unusedTable: unusedTable,
    unusedCount: unusedCount
  };
}

function addUniformToTable(_ref2) {
  var table = _ref2.table,
      header = _ref2.header,
      uniforms = _ref2.uniforms,
      uniformName = _ref2.uniformName,
      undefinedOnly = _ref2.undefinedOnly;
  var value = uniforms[uniformName];
  var isDefined = isUniformDefined(value);

  if (!undefinedOnly || !isDefined) {
    var _table$uniformName;

    table[uniformName] = (_table$uniformName = {}, (0, _defineProperty2["default"])(_table$uniformName, header, isDefined ? (0, _utils.formatValue)(value) : 'N/A'), (0, _defineProperty2["default"])(_table$uniformName, 'Uniform Type', isDefined ? value : 'NOT PROVIDED'), _table$uniformName);
    return true;
  }

  return false;
}

function isUniformDefined(value) {
  return value !== undefined && value !== null;
}

},{"../utils":388,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],367:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForVertexArray = getDebugTableForVertexArray;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _buffer = _interopRequireDefault(require("../classes/buffer"));

var _webglUtils = require("../webgl-utils");

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _utils = require("../utils");

function getDebugTableForVertexArray() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      vertexArray = _ref.vertexArray,
      _ref$header = _ref.header,
      header = _ref$header === void 0 ? 'Attributes' : _ref$header;

  if (!vertexArray.configuration) {
    return {};
  }

  var table = {};

  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }

  var attributes = vertexArray.values;

  for (var attributeLocation in attributes) {
    var info = vertexArray._getAttributeInfo(attributeLocation);

    if (info) {
      var rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      var accessor = vertexArray.accessors[info.location];

      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }

      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }

  return table;
}

function getDebugTableRow(vertexArray, attribute, accessor, header) {
  var _ref3;

  var gl = vertexArray.gl;
  var type = 'NOT PROVIDED';
  var size = 'N/A';
  var verts = 'N/A';
  var bytes = 'N/A';
  var isInteger;
  var marker;
  var value;

  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace('Array', '');
    isInteger = type.indexOf('nt') !== -1;
  }

  if (attribute instanceof _buffer["default"]) {
    var _ref2;

    var buffer = attribute;

    var _buffer$getDebugData = buffer.getDebugData(),
        data = _buffer$getDebugData.data,
        modified = _buffer$getDebugData.modified;

    marker = modified ? '*' : '';
    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    var format;

    if (accessor) {
      var instanced = accessor.divisor > 0;
      format = "".concat(instanced ? 'I ' : 'P ', " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat((0, _webglUtils.getKey)(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }

    return _ref2 = {}, (0, _defineProperty2["default"])(_ref2, header, "".concat(marker).concat((0, _utils.formatValue)(value, {
      size: size,
      isInteger: isInteger
    }))), (0, _defineProperty2["default"])(_ref2, 'Format ', format), _ref2;
  }

  value = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace('Array', '');
  isInteger = type.indexOf('nt') !== -1;
  return _ref3 = {}, (0, _defineProperty2["default"])(_ref3, header, "".concat((0, _utils.formatValue)(value, {
    size: size,
    isInteger: isInteger
  }), " (constant)")), (0, _defineProperty2["default"])(_ref3, 'Format ', "".concat(size, "x").concat(type, " (constant)")), _ref3;
}

function getGLSLDeclaration(name, accessor) {
  var type = accessor.type,
      size = accessor.size;
  var typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);

  if (typeAndName) {
    return "".concat(name, " (").concat(typeAndName.name, ")");
  }

  return name;
}

},{"../classes/buffer":339,"../utils":388,"../webgl-utils":399,"../webgl-utils/attribute-utils":396,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],368:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextDebugInfo = getContextDebugInfo;

function getContextDebugInfo(gl) {
  var vendorMasked = gl.getParameter(7936);
  var rendererMasked = gl.getParameter(7937);
  var ext = gl.getExtension('WEBGL_debug_renderer_info');
  var vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  var rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked: vendorMasked,
    rendererMasked: rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}

},{}],369:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = canCompileGLGSExtension;

var _checkOldIe = _interopRequireDefault(require("./check-old-ie"));

var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));

var _utils = require("../utils");

var compiledGlslExtensions = {};

function canCompileGLGSExtension(gl, cap) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var feature = _webglFeaturesTable["default"][cap];
  (0, _utils.assert)(feature, cap);

  if (!(0, _checkOldIe["default"])(options)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  var extensionName = feature[0];
  var source = "#extension GL_".concat(extensionName, " : enable\nvoid main(void) {}");
  var shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}

},{"../utils":388,"./check-old-ie":370,"./webgl-features-table":374,"@babel/runtime/helpers/interopRequireDefault":25}],370:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isOldIE;

function isOldIE() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = typeof window !== 'undefined' && window.navigator || {};
  var userAgent = opts.userAgent || navigator.userAgent || '';
  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}

},{}],371:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasFeature = hasFeature;
exports.hasFeatures = hasFeatures;
exports.getFeatures = getFeatures;

var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(function (feature) {
    return isFeatureSupported(gl, feature);
  });
}

function getFeatures(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.caps) {
    gl.luma.caps = {};
    gl.luma.caps.webgl2 = (0, _webglUtils.isWebGL2)(gl);

    for (var cap in _webglFeaturesTable["default"]) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }

  return gl.luma.caps;
}

function isFeatureSupported(gl, cap) {
  var feature = _webglFeaturesTable["default"][cap];
  (0, _utils.assert)(feature, cap);
  var featureDefinition = (0, _webglUtils.isWebGL2)(gl) ? feature[1] || feature[0] : feature[0];
  var isSupported;

  if (typeof featureDefinition === 'function') {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = featureDefinition[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var extension = _step.value;
        isSupported = isSupported && Boolean(gl.getExtension(extension));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (typeof featureDefinition === 'string') {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === 'boolean') {
    isSupported = featureDefinition;
  } else {
    (0, _utils.assert)(false);
  }

  return isSupported;
}

},{"../utils":388,"../webgl-utils":399,"./webgl-features-table":374,"@babel/runtime/helpers/interopRequireDefault":25}],372:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function get() {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function get() {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function get() {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function get() {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function get() {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function get() {
    return _features.hasFeatures;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function get() {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function get() {
    return _checkGlslExtension["default"];
  }
});

var _limits = require("./limits");

var _webglFeaturesTable = require("./webgl-features-table");

var _features = require("./features");

var _checkGlslExtension = _interopRequireDefault(require("./check-glsl-extension"));

},{"./check-glsl-extension":369,"./features":371,"./limits":373,"./webgl-features-table":374,"@babel/runtime/helpers/interopRequireDefault":25}],373:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextLimits = getContextLimits;
exports.getGLContextInfo = getGLContextInfo;
exports.getContextInfo = getContextInfo;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _webglUtils = require("../webgl-utils");

var _webglLimitsTable = _interopRequireDefault(require("./webgl-limits-table"));

var _getContextDebugInfo = require("../debug/get-context-debug-info");

function getContextLimits(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};
    var isWebgl2 = (0, _webglUtils.isWebGL2)(gl);

    for (var parameter in _webglLimitsTable["default"]) {
      var limit = _webglLimitsTable["default"][parameter];
      var webgl1MinLimit = limit.gl1;
      var webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
      var minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;
      var limitNotAvailable = 'gl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);
      var value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }

  return gl.luma.limits;
}

function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};
  var info = (0, _getContextDebugInfo.getContextDebugInfo)(gl);

  if (!gl.luma.info) {
    var _gl$luma$info;

    gl.luma.info = (_gl$luma$info = {}, (0, _defineProperty2["default"])(_gl$luma$info, 37445, info.vendor), (0, _defineProperty2["default"])(_gl$luma$info, 37446, info.renderer), (0, _defineProperty2["default"])(_gl$luma$info, 7936, info.vendorMasked), (0, _defineProperty2["default"])(_gl$luma$info, 7937, info.rendererMasked), (0, _defineProperty2["default"])(_gl$luma$info, 7938, info.version), (0, _defineProperty2["default"])(_gl$luma$info, 35724, info.shadingLanguageVersion), _gl$luma$info);
  }

  return gl.luma.info;
}

function getContextInfo(gl) {
  return Object.assign((0, _getContextDebugInfo.getContextDebugInfo)(gl), {
    limits: getContextLimits(gl),
    info: getGLContextInfo(gl),
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  });
}

},{"../debug/get-context-debug-info":368,"../webgl-utils":399,"./webgl-limits-table":375,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],374:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.FEATURES = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _webglUtils = require("../webgl-utils");

var _FEATURES$WEBGL2$FEAT;

var FEATURES = {
  WEBGL2: 'WEBGL2',
  VERTEX_ARRAY_OBJECT: 'VERTEX_ARRAY_OBJECT',
  TIMER_QUERY: 'TIMER_QUERY',
  INSTANCED_RENDERING: 'INSTANCED_RENDERING',
  MULTIPLE_RENDER_TARGETS: 'MULTIPLE_RENDER_TARGETS',
  ELEMENT_INDEX_UINT32: 'ELEMENT_INDEX_UINT32',
  BLEND_EQUATION_MINMAX: 'BLEND_EQUATION_MINMAX',
  COLOR_ENCODING_SRGB: 'COLOR_ENCODING_SRGB',
  TEXTURE_DEPTH: 'TEXTURE_DEPTH',
  TEXTURE_FLOAT: 'TEXTURE_FLOAT',
  TEXTURE_HALF_FLOAT: 'TEXTURE_HALF_FLOAT',
  TEXTURE_FILTER_LINEAR_FLOAT: 'TEXTURE_FILTER_LINEAR_FLOAT',
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: 'TEXTURE_FILTER_LINEAR_HALF_FLOAT',
  TEXTURE_FILTER_ANISOTROPIC: 'TEXTURE_FILTER_ANISOTROPIC',
  COLOR_ATTACHMENT_RGBA32F: 'COLOR_ATTACHMENT_RGBA32F',
  COLOR_ATTACHMENT_FLOAT: 'COLOR_ATTACHMENT_FLOAT',
  COLOR_ATTACHMENT_HALF_FLOAT: 'COLOR_ATTACHMENT_HALF_FLOAT',
  GLSL_FRAG_DATA: 'GLSL_FRAG_DATA',
  GLSL_FRAG_DEPTH: 'GLSL_FRAG_DEPTH',
  GLSL_DERIVATIVES: 'GLSL_DERIVATIVES',
  GLSL_TEXTURE_LOD: 'GLSL_TEXTURE_LOD'
};
exports.FEATURES = FEATURES;

var _default = (_FEATURES$WEBGL2$FEAT = {}, (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.WEBGL2, [function (gl) {
  return (0, _webglUtils.isWebGL2)(gl);
}]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.VERTEX_ARRAY_OBJECT, ['OES_vertex_array_object', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.TIMER_QUERY, ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2']), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.INSTANCED_RENDERING, ['ANGLE_instanced_arrays', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.MULTIPLE_RENDER_TARGETS, ['WEBGL_draw_buffers', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.ELEMENT_INDEX_UINT32, ['OES_element_index_uint', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.BLEND_EQUATION_MINMAX, ['EXT_blend_minmax', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ENCODING_SRGB, ['EXT_sRGB', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_DEPTH, ['WEBGL_depth_texture', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FLOAT, ['OES_texture_float', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_HALF_FLOAT, ['OES_texture_half_float', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_LINEAR_FLOAT, ['OES_texture_float_linear']), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT, ['OES_texture_half_float_linear']), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_ANISOTROPIC, ['EXT_texture_filter_anisotropic']), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_RGBA32F, ['WEBGL_color_buffer_float', 'EXT_color_buffer_float']), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_FLOAT, [false, 'EXT_color_buffer_float']), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_HALF_FLOAT, [false, 'EXT_color_buffer_half_float']), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_FRAG_DATA, ['WEBGL_draw_buffers', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_FRAG_DEPTH, ['EXT_frag_depth', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_DERIVATIVES, ['OES_standard_derivatives', true]), (0, _defineProperty2["default"])(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_TEXTURE_LOD, ['EXT_shader_texture_lod', true]), _FEATURES$WEBGL2$FEAT);

exports["default"] = _default;

},{"../webgl-utils":399,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],375:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _$33901$3379$;

var _default = (_$33901$3379$ = {}, (0, _defineProperty2["default"])(_$33901$3379$, 33902, {
  gl1: new Float32Array([1, 1])
}), (0, _defineProperty2["default"])(_$33901$3379$, 33901, {
  gl1: new Float32Array([1, 1])
}), (0, _defineProperty2["default"])(_$33901$3379$, 3379, {
  gl1: 64,
  gl2: 2048
}), (0, _defineProperty2["default"])(_$33901$3379$, 34076, {
  gl1: 16
}), (0, _defineProperty2["default"])(_$33901$3379$, 34930, {
  gl1: 8
}), (0, _defineProperty2["default"])(_$33901$3379$, 35661, {
  gl1: 8
}), (0, _defineProperty2["default"])(_$33901$3379$, 35660, {
  gl1: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 34024, {
  gl1: 1
}), (0, _defineProperty2["default"])(_$33901$3379$, 36348, {
  gl1: 8
}), (0, _defineProperty2["default"])(_$33901$3379$, 34921, {
  gl1: 8
}), (0, _defineProperty2["default"])(_$33901$3379$, 36347, {
  gl1: 128
}), (0, _defineProperty2["default"])(_$33901$3379$, 36349, {
  gl1: 16
}), (0, _defineProperty2["default"])(_$33901$3379$, 3386, {
  gl1: new Int32Array([0, 0])
}), (0, _defineProperty2["default"])(_$33901$3379$, 32883, {
  gl1: 0,
  gl2: 256
}), (0, _defineProperty2["default"])(_$33901$3379$, 35071, {
  gl1: 0,
  gl2: 256
}), (0, _defineProperty2["default"])(_$33901$3379$, 37447, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 36063, {
  gl1: 0,
  gl2: 4
}), (0, _defineProperty2["default"])(_$33901$3379$, 35379, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35374, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35377, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 34852, {
  gl1: 0,
  gl2: 4
}), (0, _defineProperty2["default"])(_$33901$3379$, 36203, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 33001, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 33000, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 37157, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35373, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35657, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 36183, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 37137, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 34045, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35978, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35979, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35968, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35376, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35375, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35659, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 37154, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35371, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35658, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2["default"])(_$33901$3379$, 35076, {
  gl1: 0,
  gl2: -8,
  negative: true
}), (0, _defineProperty2["default"])(_$33901$3379$, 35077, {
  gl1: 0,
  gl2: 7
}), (0, _defineProperty2["default"])(_$33901$3379$, 35380, {
  gl1: 0,
  gl2: 0
}), _$33901$3379$);

exports["default"] = _default;

},{"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],376:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = formatGLSLCompilerError;
exports.parseGLSLCompilerError = parseGLSLCompilerError;

var _getShaderName = _interopRequireDefault(require("./get-shader-name"));

var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));

function formatGLSLCompilerError(errLog, src, shaderType) {
  var _parseGLSLCompilerErr = parseGLSLCompilerError(errLog, src, shaderType),
      shaderName = _parseGLSLCompilerErr.shaderName,
      errors = _parseGLSLCompilerErr.errors,
      warnings = _parseGLSLCompilerErr.warnings;

  return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
}

function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  var errorStrings = errLog.split(/\r?\n/);
  var errors = {};
  var warnings = {};
  var name = shaderName || (0, _getShaderName["default"])(src) || '(unnamed)';
  var shaderDescription = "".concat((0, _getShaderTypeName["default"])(shaderType), " shader ").concat(name);

  for (var i = 0; i < errorStrings.length; i++) {
    var errorString = errorStrings[i];

    if (errorString.length <= 1) {
      continue;
    }

    var segments = errorString.split(':');
    var type = segments[0];
    var line = parseInt(segments[2], 10);

    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }

    if (type !== 'WARNING') {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }

  var lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}

function formatErrors(errors, lines) {
  var message = '';

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];

    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }

    message += "".concat(line, "\n");

    if (errors[i + 1]) {
      var error = errors[i + 1];
      var segments = error.split(':', 3);
      var type = segments[0];
      var column = parseInt(segments[1], 10) || 0;
      var err = error.substring(segments.join(':').length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }

  return message;
}

function addLineNumbers(string) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';
  var lines = string.split(/\r?\n/);
  var maxDigits = String(lines.length + start - 1).length;
  return lines.map(function (line, i) {
    var lineNumber = i + start;
    var digits = String(lineNumber).length;
    var prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}

function padLeft(string, digits) {
  var result = '';

  for (var i = 0; i < digits; ++i) {
    result += ' ';
  }

  return "".concat(result).concat(string);
}

},{"./get-shader-name":377,"./get-shader-type-name":378,"@babel/runtime/helpers/interopRequireDefault":25}],377:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getShaderName;

function getShaderName(shader) {
  var defaultName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unnamed';
  var SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  var match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}

},{}],378:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getShaderTypeName;
var GL_FRAGMENT_SHADER = 0x8b30;
var GL_VERTEX_SHADER = 0x8b31;

function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return 'fragment';

    case GL_VERTEX_SHADER:
      return 'vertex';

    default:
      return 'unknown type';
  }
}

},{}],379:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getShaderVersion;

function getShaderVersion(source) {
  var version = 100;
  var words = source.match(/[^\s]+/g);

  if (words.length >= 2 && words[0] === '#version') {
    var v = parseInt(words[1], 10);

    if (Number.isFinite(v)) {
      version = v;
    }
  }

  return version;
}

},{}],380:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "formatGLSLCompilerError", {
  enumerable: true,
  get: function get() {
    return _formatGlslError["default"];
  }
});
Object.defineProperty(exports, "parseGLSLCompilerError", {
  enumerable: true,
  get: function get() {
    return _formatGlslError.parseGLSLCompilerError;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function get() {
    return _getShaderName["default"];
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function get() {
    return _getShaderVersion["default"];
  }
});
Object.defineProperty(exports, "getShaderTypeName", {
  enumerable: true,
  get: function get() {
    return _getShaderTypeName["default"];
  }
});

var _formatGlslError = _interopRequireWildcard(require("./format-glsl-error"));

var _getShaderName = _interopRequireDefault(require("./get-shader-name"));

var _getShaderVersion = _interopRequireDefault(require("./get-shader-version"));

var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));

},{"./format-glsl-error":376,"./get-shader-name":377,"./get-shader-type-name":378,"./get-shader-version":379,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26}],381:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function get() {
    return _init.lumaStats;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.resetParameters;
  }
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.setParameter;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.setParameters;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.withParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function get() {
    return _webglStateTracker.getModifiedParameters;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _webglTypes.Image;
  }
});
Object.defineProperty(exports, "WebGLRenderingContext", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLRenderingContext;
  }
});
Object.defineProperty(exports, "WebGLProgram", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLProgram;
  }
});
Object.defineProperty(exports, "WebGLShader", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLShader;
  }
});
Object.defineProperty(exports, "WebGLBuffer", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLBuffer;
  }
});
Object.defineProperty(exports, "WebGLFramebuffer", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLFramebuffer;
  }
});
Object.defineProperty(exports, "WebGLRenderbuffer", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLRenderbuffer;
  }
});
Object.defineProperty(exports, "WebGLTexture", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLTexture;
  }
});
Object.defineProperty(exports, "WebGLUniformLocation", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLUniformLocation;
  }
});
Object.defineProperty(exports, "WebGLActiveInfo", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLActiveInfo;
  }
});
Object.defineProperty(exports, "WebGLShaderPrecisionFormat", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLShaderPrecisionFormat;
  }
});
Object.defineProperty(exports, "WebGL2RenderingContext", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGL2RenderingContext;
  }
});
Object.defineProperty(exports, "webGLTypesAvailable", {
  enumerable: true,
  get: function get() {
    return _webglTypes.webGLTypesAvailable;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function get() {
    return _context.createGLContext;
  }
});
Object.defineProperty(exports, "destroyGLContext", {
  enumerable: true,
  get: function get() {
    return _context.destroyGLContext;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function get() {
    return _context.resizeGLContext;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function get() {
    return _context.instrumentGLContext;
  }
});
Object.defineProperty(exports, "setGLContextDefaults", {
  enumerable: true,
  get: function get() {
    return _context.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "getCanvas", {
  enumerable: true,
  get: function get() {
    return _createCanvas.getCanvas;
  }
});
Object.defineProperty(exports, "getPageLoadPromise", {
  enumerable: true,
  get: function get() {
    return _createCanvas.getPageLoadPromise;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _requestAnimationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "cancelAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _requestAnimationFrame.cancelAnimationFrame;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function get() {
    return _webglChecks.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function get() {
    return _webglChecks.isWebGL2;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function get() {
    return _textureUtils.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function get() {
    return _constantsToKeys.getKeyValue;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function get() {
    return _constantsToKeys.getKey;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function get() {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function get() {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function get() {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getContextDebugInfo", {
  enumerable: true,
  get: function get() {
    return _getContextDebugInfo.getContextDebugInfo;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function get() {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function get() {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function get() {
    return _features.hasFeatures;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function get() {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function get() {
    return _checkGlslExtension["default"];
  }
});
Object.defineProperty(exports, "Accessor", {
  enumerable: true,
  get: function get() {
    return _accessor["default"];
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function get() {
    return _buffer["default"];
  }
});
Object.defineProperty(exports, "Shader", {
  enumerable: true,
  get: function get() {
    return _shader.Shader;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function get() {
    return _shader.VertexShader;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function get() {
    return _shader.FragmentShader;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function get() {
    return _program["default"];
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function get() {
    return _framebuffer["default"];
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function get() {
    return _renderbuffer["default"];
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function get() {
    return _texture2d["default"];
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function get() {
    return _textureCube["default"];
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function get() {
    return _clear.clear;
  }
});
Object.defineProperty(exports, "clearBuffer", {
  enumerable: true,
  get: function get() {
    return _clear.clearBuffer;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function get() {
    return _copyAndBlit.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function get() {
    return _copyAndBlit.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "copyToDataUrl", {
  enumerable: true,
  get: function get() {
    return _copyAndBlit.copyToDataUrl;
  }
});
Object.defineProperty(exports, "copyToImage", {
  enumerable: true,
  get: function get() {
    return _copyAndBlit.copyToImage;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function get() {
    return _copyAndBlit.copyToTexture;
  }
});
Object.defineProperty(exports, "blit", {
  enumerable: true,
  get: function get() {
    return _copyAndBlit.blit;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function get() {
    return _query["default"];
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function get() {
    return _texture3d["default"];
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function get() {
    return _transformFeedback["default"];
  }
});
Object.defineProperty(exports, "VertexArrayObject", {
  enumerable: true,
  get: function get() {
    return _vertexArrayObject["default"];
  }
});
Object.defineProperty(exports, "VertexArray", {
  enumerable: true,
  get: function get() {
    return _vertexArray["default"];
  }
});
Object.defineProperty(exports, "UniformBufferLayout", {
  enumerable: true,
  get: function get() {
    return _uniformBufferLayout["default"];
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _loadFile.setPathPrefix;
  }
});
Object.defineProperty(exports, "loadFile", {
  enumerable: true,
  get: function get() {
    return _loadFile.loadFile;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function get() {
    return _loadFile.loadImage;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function get() {
    return _getShaderName["default"];
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function get() {
    return _getShaderVersion["default"];
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return _log["default"];
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert["default"];
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function get() {
    return _utils.uid;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function get() {
    return _utils.isObjectEmpty;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _isBrowser["default"];
  }
});
Object.defineProperty(exports, "parseUniformName", {
  enumerable: true,
  get: function get() {
    return _uniforms.parseUniformName;
  }
});
Object.defineProperty(exports, "getUniformSetter", {
  enumerable: true,
  get: function get() {
    return _uniforms.getUniformSetter;
  }
});
Object.defineProperty(exports, "getDebugTableForUniforms", {
  enumerable: true,
  get: function get() {
    return _debugUniforms.getDebugTableForUniforms;
  }
});
Object.defineProperty(exports, "getDebugTableForVertexArray", {
  enumerable: true,
  get: function get() {
    return _debugVertexArray.getDebugTableForVertexArray;
  }
});
Object.defineProperty(exports, "getDebugTableForProgramConfiguration", {
  enumerable: true,
  get: function get() {
    return _debugProgramConfiguration.getDebugTableForProgramConfiguration;
  }
});

var _init = require("./init");

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _webglTypes = require("./webgl-utils/webgl-types");

var _context = require("./context/context");

var _createCanvas = require("./context/create-canvas");

var _requestAnimationFrame = require("./webgl-utils/request-animation-frame");

var _webglChecks = require("./webgl-utils/webgl-checks");

var _textureUtils = require("./webgl-utils/texture-utils");

var _constantsToKeys = require("./webgl-utils/constants-to-keys");

var _limits = require("./features/limits");

var _getContextDebugInfo = require("./debug/get-context-debug-info");

var _webglFeaturesTable = require("./features/webgl-features-table");

var _features = require("./features/features");

var _checkGlslExtension = _interopRequireDefault(require("./features/check-glsl-extension"));

var _accessor = _interopRequireDefault(require("./classes/accessor"));

var _buffer = _interopRequireDefault(require("./classes/buffer"));

var _shader = require("./classes/shader");

var _program = _interopRequireDefault(require("./classes/program"));

var _framebuffer = _interopRequireDefault(require("./classes/framebuffer"));

var _renderbuffer = _interopRequireDefault(require("./classes/renderbuffer"));

var _texture2d = _interopRequireDefault(require("./classes/texture-2d"));

var _textureCube = _interopRequireDefault(require("./classes/texture-cube"));

var _clear = require("./classes/clear");

var _copyAndBlit = require("./classes/copy-and-blit");

var _query = _interopRequireDefault(require("./classes/query"));

var _texture3d = _interopRequireDefault(require("./classes/texture-3d"));

var _transformFeedback = _interopRequireDefault(require("./classes/transform-feedback"));

var _vertexArrayObject = _interopRequireDefault(require("./classes/vertex-array-object"));

var _vertexArray = _interopRequireDefault(require("./classes/vertex-array"));

var _uniformBufferLayout = _interopRequireDefault(require("./classes/uniform-buffer-layout"));

var _loadFile = require("./utils/load-file");

var _getShaderName = _interopRequireDefault(require("./glsl-utils/get-shader-name"));

var _getShaderVersion = _interopRequireDefault(require("./glsl-utils/get-shader-version"));

var _log = _interopRequireDefault(require("./utils/log"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _utils = require("./utils/utils");

var _globals = require("./utils/globals");

var _isBrowser = _interopRequireDefault(require("./utils/is-browser"));

var _uniforms = require("./classes/uniforms");

var _debugUniforms = require("./debug/debug-uniforms");

var _debugVertexArray = require("./debug/debug-vertex-array");

var _debugProgramConfiguration = require("./debug/debug-program-configuration");

},{"./classes/accessor":338,"./classes/buffer":339,"./classes/clear":340,"./classes/copy-and-blit":341,"./classes/framebuffer":342,"./classes/program":344,"./classes/query":345,"./classes/renderbuffer":347,"./classes/shader":349,"./classes/texture-2d":350,"./classes/texture-3d":351,"./classes/texture-cube":352,"./classes/transform-feedback":355,"./classes/uniform-buffer-layout":356,"./classes/uniforms":357,"./classes/vertex-array":359,"./classes/vertex-array-object":358,"./context/context":360,"./context/create-canvas":362,"./debug/debug-program-configuration":365,"./debug/debug-uniforms":366,"./debug/debug-vertex-array":367,"./debug/get-context-debug-info":368,"./features/check-glsl-extension":369,"./features/features":371,"./features/limits":373,"./features/webgl-features-table":374,"./glsl-utils/get-shader-name":377,"./glsl-utils/get-shader-version":379,"./init":382,"./utils/assert":384,"./utils/globals":387,"./utils/is-browser":389,"./utils/load-file":392,"./utils/log":393,"./utils/utils":395,"./webgl-utils/constants-to-keys":397,"./webgl-utils/request-animation-frame":400,"./webgl-utils/texture-utils":401,"./webgl-utils/webgl-checks":403,"./webgl-utils/webgl-types":404,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/webgl-state-tracker":321}],382:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
exports["default"] = exports.lumaStats = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _isBrowser = _interopRequireDefault(require("./utils/is-browser"));

var _globals = require("./utils/globals");

var _log = _interopRequireDefault(require("./utils/log"));

var _probe = require("probe.gl");

require("@luma.gl/webgl2-polyfill");

var VERSION = typeof "7.2.0-beta.1" !== 'undefined' ? "7.2.0-beta.1" : 'untranspiled source';
var STARTUP_MESSAGE = 'set luma.log.priority=1 (or higher) to trace rendering';

var StatsManager = function () {
  function StatsManager() {
    (0, _classCallCheck2["default"])(this, StatsManager);
    this.stats = new Map();
  }

  (0, _createClass2["default"])(StatsManager, [{
    key: "get",
    value: function get(name) {
      if (!this.stats.has(name)) {
        this.stats.set(name, new _probe.Stats({
          id: name
        }));
      }

      return this.stats.get(name);
    }
  }]);
  return StatsManager;
}();

var lumaStats = new StatsManager();
exports.lumaStats = lumaStats;

if (_globals.global.luma && _globals.global.luma.VERSION !== VERSION) {
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(_globals.global.luma.VERSION, " vs ").concat(VERSION));
}

if (!_globals.global.luma) {
  if (_isBrowser["default"]) {
    _log["default"].log(1, "luma.gl ".concat(VERSION, " - ").concat(STARTUP_MESSAGE))();
  }

  _globals.global.luma = _globals.global.luma || {
    VERSION: VERSION,
    version: VERSION,
    log: _log["default"],
    stats: lumaStats,
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}

var _default = _globals.global.luma;
exports["default"] = _default;

},{"./utils/globals":387,"./utils/is-browser":389,"./utils/log":393,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@luma.gl/webgl2-polyfill":334,"probe.gl":444}],383:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScratchArrayBuffer = getScratchArrayBuffer;
exports.getScratchArray = getScratchArray;
exports.fillArray = fillArray;
var arrayBuffer = null;

function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }

  return arrayBuffer;
}

function getScratchArray(Type, length) {
  var scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}

function fillArray(_ref) {
  var target = _ref.target,
      source = _ref.source,
      _ref$start = _ref.start,
      start = _ref$start === void 0 ? 0 : _ref$start,
      _ref$count = _ref.count,
      count = _ref$count === void 0 ? 1 : _ref$count;
  var length = source.length;
  var total = count * length;
  var copied = 0;

  for (var i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}

},{}],384:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"dup":329}],385:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkProps = checkProps;

var _log = _interopRequireDefault(require("./log"));

function checkProps(className, props, propChecks) {
  var _propChecks$removedPr = propChecks.removedProps,
      removedProps = _propChecks$removedPr === void 0 ? {} : _propChecks$removedPr,
      _propChecks$deprecate = propChecks.deprecatedProps,
      deprecatedProps = _propChecks$deprecate === void 0 ? {} : _propChecks$deprecate,
      _propChecks$replacedP = propChecks.replacedProps,
      replacedProps = _propChecks$replacedP === void 0 ? {} : _propChecks$replacedP;

  for (var propName in removedProps) {
    if (propName in props) {
      var replacementProp = removedProps[propName];
      var replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : 'N/A';

      _log["default"].removed("".concat(className, ".").concat(propName), replacement)();
    }
  }

  for (var _propName in deprecatedProps) {
    if (_propName in props) {
      var _replacementProp = deprecatedProps[_propName];

      _log["default"].deprecated("".concat(className, ".").concat(_propName), "".concat(className, ".").concat(_replacementProp))();
    }
  }

  var newProps = null;

  for (var _propName2 in replacedProps) {
    if (_propName2 in props) {
      var _replacementProp2 = replacedProps[_propName2];

      _log["default"].deprecated("".concat(className, ".").concat(_propName2), "".concat(className, ".").concat(_replacementProp2))();

      newProps = newProps || Object.assign({}, props);
      newProps[_replacementProp2] = props[_propName2];
      delete newProps[_propName2];
    }
  }

  return newProps || props;
}

},{"./log":393,"@babel/runtime/helpers/interopRequireDefault":25}],386:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatValue = formatValue;

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

},{}],387:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.document = exports.global = exports.window = exports.self = void 0;
var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],388:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert["default"];
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return _log["default"];
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _isBrowser["default"];
  }
});
Object.defineProperty(exports, "isOldIE", {
  enumerable: true,
  get: function get() {
    return _isOldIe["default"];
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function get() {
    return _utils.uid;
  }
});
Object.defineProperty(exports, "isPowerOfTwo", {
  enumerable: true,
  get: function get() {
    return _utils.isPowerOfTwo;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function get() {
    return _utils.isObjectEmpty;
  }
});
Object.defineProperty(exports, "formatValue", {
  enumerable: true,
  get: function get() {
    return _formatValue.formatValue;
  }
});
Object.defineProperty(exports, "stubRemovedMethods", {
  enumerable: true,
  get: function get() {
    return _stubMethods.stubRemovedMethods;
  }
});
Object.defineProperty(exports, "checkProps", {
  enumerable: true,
  get: function get() {
    return _checkProps.checkProps;
  }
});

var _assert = _interopRequireDefault(require("./assert"));

var _log = _interopRequireDefault(require("./log"));

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isOldIe = _interopRequireDefault(require("./is-old-ie"));

var _utils = require("./utils");

var _formatValue = require("./format-value");

var _stubMethods = require("./stub-methods");

var _checkProps = require("./check-props");

},{"./assert":384,"./check-props":385,"./format-value":386,"./is-browser":389,"./is-old-ie":391,"./log":393,"./stub-methods":394,"./utils":395,"@babel/runtime/helpers/interopRequireDefault":25}],389:[function(require,module,exports){
(function (process){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.isBrowserMainThread = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) === 'object' && String(process) === '[object process]' && !process.browser;
var isBrowser = !isNode || _isElectron["default"];
var isBrowserMainThread = isBrowser && typeof document !== 'undefined';
exports.isBrowserMainThread = isBrowserMainThread;
var _default = isBrowser;
exports["default"] = _default;

}).call(this,require('_process'))
},{"./is-electron":390,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],390:[function(require,module,exports){
(function (process){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function isElectron() {
  if (typeof window !== 'undefined' && (0, _typeof2["default"])(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2["default"])(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  if ((typeof navigator === "undefined" ? "undefined" : (0, _typeof2["default"])(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}

var _default = isElectron();

exports["default"] = _default;

}).call(this,require('_process'))
},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],391:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isOldIE;

var _globals = require("./globals");

function isOldIE() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = _globals.window.navigator || {};
  var userAgent = opts.userAgent || navigator.userAgent || '';
  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}

},{"./globals":387}],392:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPathPrefix = setPathPrefix;
exports.loadFile = loadFile;
exports.loadImage = loadImage;

var _utils = require("../utils");

var pathPrefix = '';

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function loadFile(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _utils.assert)(typeof url === 'string');
  url = pathPrefix + url;
  var dataType = options.dataType || 'text';
  return fetch(url, options).then(function (res) {
    return res[dataType]();
  });
}

function loadImage(url, opts) {
  (0, _utils.assert)(typeof url === 'string');
  url = pathPrefix + url;
  return new Promise(function (resolve, reject) {
    try {
      var image = new Image();

      image.onload = function () {
        return resolve(image);
      };

      image.onerror = function () {
        return reject(new Error("Could not load image ".concat(url, ".")));
      };

      image.crossOrigin = opts && opts.crossOrigin || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}

},{"../utils":388}],393:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _probe = require("probe.gl");

var _default = new _probe.Log({
  id: 'luma'
}).enable();

exports["default"] = _default;

},{"probe.gl":444}],394:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stubRemovedMethods = stubRemovedMethods;

var _log = _interopRequireDefault(require("./log"));

function stubRemovedMethods(instance, className, version, methodNames) {
  var upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at http://uber.github.io/luma.gl/#/documentation/overview/upgrade-guide");
  var prototype = Object.getPrototypeOf(instance);
  methodNames.forEach(function (methodName) {
    if (prototype.methodName) {
      return;
    }

    prototype[methodName] = function () {
      _log["default"].removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();

      throw new Error(methodName);
    };
  });
}

},{"./log":393,"@babel/runtime/helpers/interopRequireDefault":25}],395:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uid = uid;
exports.isPowerOfTwo = isPowerOfTwo;
exports.isObjectEmpty = isObjectEmpty;

var _assert = _interopRequireDefault(require("./assert"));

var uidCounters = {};

function uid() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
  uidCounters[id] = uidCounters[id] || 1;
  var count = uidCounters[id]++;
  return "".concat(id, "-").concat(count);
}

function isPowerOfTwo(n) {
  (0, _assert["default"])(typeof n === 'number', 'Input must be a number');
  return n && (n & n - 1) === 0;
}

function isObjectEmpty(obj) {
  var isEmpty = true;

  for (var key in obj) {
    isEmpty = false;
    break;
  }

  return isEmpty;
}

},{"./assert":384,"@babel/runtime/helpers/interopRequireDefault":25}],396:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPrimitiveDrawMode = getPrimitiveDrawMode;
exports.getPrimitiveCount = getPrimitiveCount;
exports.getVertexCount = getVertexCount;
exports.decomposeCompositeGLType = decomposeCompositeGLType;
exports.getCompositeGLType = getCompositeGLType;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("../utils");

var _COMPOSITE_GL_TYPES;

var GL_BYTE = 0x1400;
var GL_UNSIGNED_BYTE = 0x1401;
var GL_SHORT = 0x1402;
var GL_UNSIGNED_SHORT = 0x1403;
var GL_POINTS = 0x0;
var GL_LINES = 0x1;
var GL_LINE_LOOP = 0x2;
var GL_LINE_STRIP = 0x3;
var GL_TRIANGLES = 0x4;
var GL_TRIANGLE_STRIP = 0x5;
var GL_TRIANGLE_FAN = 0x6;
var GL_FLOAT = 0x1406;
var GL_FLOAT_VEC2 = 0x8b50;
var GL_FLOAT_VEC3 = 0x8b51;
var GL_FLOAT_VEC4 = 0x8b52;
var GL_INT = 0x1404;
var GL_INT_VEC2 = 0x8b53;
var GL_INT_VEC3 = 0x8b54;
var GL_INT_VEC4 = 0x8b55;
var GL_UNSIGNED_INT = 0x1405;
var GL_UNSIGNED_INT_VEC2 = 0x8dc6;
var GL_UNSIGNED_INT_VEC3 = 0x8dc7;
var GL_UNSIGNED_INT_VEC4 = 0x8dc8;
var GL_BOOL = 0x8b56;
var GL_BOOL_VEC2 = 0x8b57;
var GL_BOOL_VEC3 = 0x8b58;
var GL_BOOL_VEC4 = 0x8b59;
var GL_FLOAT_MAT2 = 0x8b5a;
var GL_FLOAT_MAT3 = 0x8b5b;
var GL_FLOAT_MAT4 = 0x8b5c;
var GL_FLOAT_MAT2x3 = 0x8b65;
var GL_FLOAT_MAT2x4 = 0x8b66;
var GL_FLOAT_MAT3x2 = 0x8b67;
var GL_FLOAT_MAT3x4 = 0x8b68;
var GL_FLOAT_MAT4x2 = 0x8b69;
var GL_FLOAT_MAT4x3 = 0x8b6a;
var COMPOSITE_GL_TYPES = (_COMPOSITE_GL_TYPES = {}, (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT, [GL_FLOAT, 1, 'float']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC2, [GL_FLOAT, 2, 'vec2']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC3, [GL_FLOAT, 3, 'vec3']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC4, [GL_FLOAT, 4, 'vec4']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_INT, [GL_INT, 1, 'int']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_INT_VEC2, [GL_INT, 2, 'ivec2']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_INT_VEC3, [GL_INT, 3, 'ivec3']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_INT_VEC4, [GL_INT, 4, 'ivec4']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT, [GL_UNSIGNED_INT, 1, 'uint']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC2, [GL_UNSIGNED_INT, 2, 'uvec2']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC3, [GL_UNSIGNED_INT, 3, 'uvec3']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC4, [GL_UNSIGNED_INT, 4, 'uvec4']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_BOOL, [GL_FLOAT, 1, 'bool']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_BOOL_VEC2, [GL_FLOAT, 2, 'bvec2']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_BOOL_VEC3, [GL_FLOAT, 3, 'bvec3']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_BOOL_VEC4, [GL_FLOAT, 4, 'bvec4']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2, [GL_FLOAT, 8, 'mat2']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2x3, [GL_FLOAT, 8, 'mat2x3']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2x4, [GL_FLOAT, 8, 'mat2x4']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3, [GL_FLOAT, 12, 'mat3']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3x2, [GL_FLOAT, 12, 'mat3x2']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3x4, [GL_FLOAT, 12, 'mat3x4']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4, [GL_FLOAT, 16, 'mat4']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4x2, [GL_FLOAT, 16, 'mat4x2']), (0, _defineProperty2["default"])(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4x3, [GL_FLOAT, 16, 'mat4x3']), _COMPOSITE_GL_TYPES);

function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;

    case GL_LINES:
      return GL_LINES;

    case GL_LINE_STRIP:
      return GL_LINES;

    case GL_LINE_LOOP:
      return GL_LINES;

    case GL_TRIANGLES:
      return GL_TRIANGLES;

    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;

    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function getPrimitiveCount(_ref) {
  var drawMode = _ref.drawMode,
      vertexCount = _ref.vertexCount;

  switch (drawMode) {
    case GL_POINTS:
    case GL_LINE_LOOP:
      return vertexCount;

    case GL_LINES:
      return vertexCount / 2;

    case GL_LINE_STRIP:
      return vertexCount - 1;

    case GL_TRIANGLES:
      return vertexCount / 3;

    case GL_TRIANGLE_STRIP:
    case GL_TRIANGLE_FAN:
      return vertexCount - 2;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function getVertexCount(_ref2) {
  var drawMode = _ref2.drawMode,
      vertexCount = _ref2.vertexCount;
  var primitiveCount = getPrimitiveCount({
    drawMode: drawMode,
    vertexCount: vertexCount
  });

  switch (getPrimitiveDrawMode(drawMode)) {
    case GL_POINTS:
      return primitiveCount;

    case GL_LINES:
      return primitiveCount * 2;

    case GL_TRIANGLES:
      return primitiveCount * 3;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function decomposeCompositeGLType(compositeGLType) {
  var typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];

  if (!typeAndSize) {
    return null;
  }

  var _typeAndSize = (0, _slicedToArray2["default"])(typeAndSize, 2),
      type = _typeAndSize[0],
      components = _typeAndSize[1];

  return {
    type: type,
    components: components
  };
}

function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;

    default:
  }

  for (var glType in COMPOSITE_GL_TYPES) {
    var _COMPOSITE_GL_TYPES$g = (0, _slicedToArray2["default"])(COMPOSITE_GL_TYPES[glType], 3),
        compType = _COMPOSITE_GL_TYPES$g[0],
        compComponents = _COMPOSITE_GL_TYPES$g[1],
        name = _COMPOSITE_GL_TYPES$g[2];

    if (compType === type && compComponents === components) {
      return {
        glType: glType,
        name: name
      };
    }
  }

  return null;
}

},{"../utils":388,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],397:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKeyValue = getKeyValue;
exports.getKey = getKey;
exports.getKeyType = getKeyType;

var _utils = require("../utils");

function getKeyValue(gl, name) {
  if (typeof name !== 'string') {
    return name;
  }

  var number = Number(name);

  if (!isNaN(number)) {
    return number;
  }

  name = name.replace(/^.*\./, '');
  var value = gl[name];
  (0, _utils.assert)(value !== undefined, "Accessing undefined constant GL.".concat(name));
  return value;
}

function getKey(gl, value) {
  value = Number(value);

  for (var key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }

  return String(value);
}

function getKeyType(gl, value) {
  (0, _utils.assert)(value !== undefined, 'undefined key');
  value = Number(value);

  for (var key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }

  return String(value);
}

},{"../utils":388}],398:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glFormatToComponents = glFormatToComponents;
exports.glTypeToBytes = glTypeToBytes;

var _utils = require("../utils");

function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;

    case 33328:
    case 33319:
      return 2;

    case 6407:
    case 34837:
      return 3;

    case 6408:
    case 34836:
      return 4;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;

    case 33635:
    case 32819:
    case 32820:
      return 2;

    case 5126:
      return 4;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

},{"../utils":388}],399:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _webglTypes.Image;
  }
});
Object.defineProperty(exports, "WebGLRenderingContext", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLRenderingContext;
  }
});
Object.defineProperty(exports, "WebGL2RenderingContext", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGL2RenderingContext;
  }
});
Object.defineProperty(exports, "WebGLProgram", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLProgram;
  }
});
Object.defineProperty(exports, "WebGLShader", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLShader;
  }
});
Object.defineProperty(exports, "WebGLBuffer", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLBuffer;
  }
});
Object.defineProperty(exports, "WebGLFramebuffer", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLFramebuffer;
  }
});
Object.defineProperty(exports, "WebGLRenderbuffer", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLRenderbuffer;
  }
});
Object.defineProperty(exports, "WebGLTexture", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLTexture;
  }
});
Object.defineProperty(exports, "WebGLUniformLocation", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLUniformLocation;
  }
});
Object.defineProperty(exports, "WebGLActiveInfo", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLActiveInfo;
  }
});
Object.defineProperty(exports, "WebGLShaderPrecisionFormat", {
  enumerable: true,
  get: function get() {
    return _webglTypes.WebGLShaderPrecisionFormat;
  }
});
Object.defineProperty(exports, "webGLTypesAvailable", {
  enumerable: true,
  get: function get() {
    return _webglTypes.webGLTypesAvailable;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function get() {
    return _webglChecks.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function get() {
    return _webglChecks.isWebGL2;
  }
});
Object.defineProperty(exports, "assertWebGLContext", {
  enumerable: true,
  get: function get() {
    return _webglChecks.assertWebGLContext;
  }
});
Object.defineProperty(exports, "assertWebGL2Context", {
  enumerable: true,
  get: function get() {
    return _webglChecks.assertWebGL2Context;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _requestAnimationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "cancelAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _requestAnimationFrame.cancelAnimationFrame;
  }
});
Object.defineProperty(exports, "getGLTypeFromTypedArray", {
  enumerable: true,
  get: function get() {
    return _typedArrayUtils.getGLTypeFromTypedArray;
  }
});
Object.defineProperty(exports, "getTypedArrayFromGLType", {
  enumerable: true,
  get: function get() {
    return _typedArrayUtils.getTypedArrayFromGLType;
  }
});
Object.defineProperty(exports, "flipRows", {
  enumerable: true,
  get: function get() {
    return _typedArrayUtils.flipRows;
  }
});
Object.defineProperty(exports, "scalePixels", {
  enumerable: true,
  get: function get() {
    return _typedArrayUtils.scalePixels;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function get() {
    return _constantsToKeys.getKeyValue;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function get() {
    return _constantsToKeys.getKey;
  }
});
Object.defineProperty(exports, "getKeyType", {
  enumerable: true,
  get: function get() {
    return _constantsToKeys.getKeyType;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function get() {
    return _textureUtils.cloneTextureFrom;
  }
});

var _webglTypes = require("./webgl-types");

var _webglChecks = require("./webgl-checks");

var _requestAnimationFrame = require("./request-animation-frame");

var _typedArrayUtils = require("./typed-array-utils");

var _constantsToKeys = require("./constants-to-keys");

var _textureUtils = require("./texture-utils");

},{"./constants-to-keys":397,"./request-animation-frame":400,"./texture-utils":401,"./typed-array-utils":402,"./webgl-checks":403,"./webgl-types":404}],400:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestAnimationFrame = requestAnimationFrame;
exports.cancelAnimationFrame = cancelAnimationFrame;

function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}

function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}

},{}],401:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneTextureFrom = cloneTextureFrom;
exports.toFramebuffer = toFramebuffer;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));

var _textureCube = _interopRequireDefault(require("../classes/texture-cube"));

var _texture3d = _interopRequireDefault(require("../classes/texture-3d"));

var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));

var _utils = require("../utils");

function cloneTextureFrom(refTexture, overrides) {
  (0, _utils.assert)(refTexture instanceof _texture2d["default"] || refTexture instanceof _textureCube["default"] || refTexture instanceof _texture3d["default"]);
  var TextureType = refTexture.constructor;
  var gl = refTexture.gl,
      width = refTexture.width,
      height = refTexture.height,
      format = refTexture.format,
      type = refTexture.type,
      dataFormat = refTexture.dataFormat,
      border = refTexture.border,
      mipmaps = refTexture.mipmaps;
  var textureOptions = Object.assign({
    width: width,
    height: height,
    format: format,
    type: type,
    dataFormat: dataFormat,
    border: border,
    mipmaps: mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}

function toFramebuffer(texture, opts) {
  var gl = texture.gl,
      width = texture.width,
      height = texture.height,
      id = texture.id;
  var framebuffer = new _framebuffer["default"](gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width: width,
    height: height,
    attachments: (0, _defineProperty2["default"])({}, 36064, texture)
  }));
  return framebuffer;
}

},{"../classes/framebuffer":342,"../classes/texture-2d":350,"../classes/texture-3d":351,"../classes/texture-cube":352,"../utils":388,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25}],402:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
exports.getTypedArrayFromGLType = getTypedArrayFromGLType;
exports.flipRows = flipRows;
exports.scalePixels = scalePixels;
var ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';

function getGLTypeFromTypedArray(arrayOrType) {
  var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;

  switch (type) {
    case Float32Array:
      return 5126;

    case Uint16Array:
      return 5123;

    case Uint32Array:
      return 5125;

    case Uint8Array:
      return 5121;

    case Uint8ClampedArray:
      return 5121;

    case Int8Array:
      return 5120;

    case Int16Array:
      return 5122;

    case Int32Array:
      return 5124;

    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}

function getTypedArrayFromGLType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === void 0 ? true : _ref$clamped;

  switch (glType) {
    case 5126:
      return Float32Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}

function flipRows(_ref2) {
  var data = _ref2.data,
      width = _ref2.width,
      height = _ref2.height,
      _ref2$bytesPerPixel = _ref2.bytesPerPixel,
      bytesPerPixel = _ref2$bytesPerPixel === void 0 ? 4 : _ref2$bytesPerPixel,
      temp = _ref2.temp;
  var bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);

  for (var y = 0; y < height / 2; ++y) {
    var topOffset = y * bytesPerRow;
    var bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}

function scalePixels(_ref3) {
  var data = _ref3.data,
      width = _ref3.width,
      height = _ref3.height;
  var newWidth = Math.round(width / 2);
  var newHeight = Math.round(height / 2);
  var newData = new Uint8Array(newWidth * newHeight * 4);

  for (var y = 0; y < newHeight; y++) {
    for (var x = 0; x < newWidth; x++) {
      for (var c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }

  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}

},{}],403:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWebGL = isWebGL;
exports.isWebGL2 = isWebGL2;
exports.assertWebGLContext = assertWebGLContext;
exports.assertWebGL2Context = assertWebGL2Context;
exports.ERR_WEBGL2 = exports.ERR_WEBGL = exports.ERR_CONTEXT = void 0;

var _utils = require("../utils");

var ERR_CONTEXT = 'Invalid WebGLRenderingContext';
exports.ERR_CONTEXT = ERR_CONTEXT;
var ERR_WEBGL = ERR_CONTEXT;
exports.ERR_WEBGL = ERR_WEBGL;
var ERR_WEBGL2 = 'Requires WebGL2';
exports.ERR_WEBGL2 = ERR_WEBGL2;

function isWebGL(gl) {
  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function assertWebGLContext(gl) {
  (0, _utils.assert)(isWebGL(gl), ERR_CONTEXT);
}

function assertWebGL2Context(gl) {
  (0, _utils.assert)(isWebGL2(gl), ERR_WEBGL2);
}

},{"../utils":388}],404:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.headlessGL = headlessGL;
exports.WebGL2RenderingContext = exports.WebGLShaderPrecisionFormat = exports.WebGLActiveInfo = exports.WebGLUniformLocation = exports.WebGLTexture = exports.WebGLRenderbuffer = exports.WebGLFramebuffer = exports.WebGLBuffer = exports.WebGLShader = exports.WebGLProgram = exports.WebGLRenderingContext = exports.Image = exports.webGLTypesAvailable = exports.headlessTypes = exports.ERR_HEADLESSGL_LOAD = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _globals = require("../utils/globals");

var _isBrowser = _interopRequireDefault(require("../utils/is-browser"));

var ERR_HEADLESSGL_LOAD = "luma.gl: loaded under Node.js without headless gl installed, meaning that WebGL contexts can not be created. This may not be an error. For example, this is a typical configuration for isorender applications running on the server.";
exports.ERR_HEADLESSGL_LOAD = ERR_HEADLESSGL_LOAD;
var m = module;
var headlessTypes = null;
exports.headlessTypes = headlessTypes;

function headlessGL() {
  var headless = m.require('gl');

  if (!headless) {
    throw new Error(ERR_HEADLESSGL_LOAD);
  }

  return headless.apply(void 0, arguments);
}

if (!_isBrowser["default"]) {
  try {
    exports.headlessTypes = headlessTypes = m.require('gl/wrap');
  } catch (error) {}
}

var DummyType = function DummyType() {
  (0, _classCallCheck2["default"])(this, DummyType);
};

var _ref = headlessTypes || _globals.global,
    _ref$WebGLRenderingCo = _ref.WebGLRenderingContext,
    WebGLRenderingContext = _ref$WebGLRenderingCo === void 0 ? DummyType : _ref$WebGLRenderingCo,
    _ref$WebGLProgram = _ref.WebGLProgram,
    WebGLProgram = _ref$WebGLProgram === void 0 ? DummyType : _ref$WebGLProgram,
    _ref$WebGLShader = _ref.WebGLShader,
    WebGLShader = _ref$WebGLShader === void 0 ? DummyType : _ref$WebGLShader,
    _ref$WebGLBuffer = _ref.WebGLBuffer,
    WebGLBuffer = _ref$WebGLBuffer === void 0 ? DummyType : _ref$WebGLBuffer,
    _ref$WebGLFramebuffer = _ref.WebGLFramebuffer,
    WebGLFramebuffer = _ref$WebGLFramebuffer === void 0 ? DummyType : _ref$WebGLFramebuffer,
    _ref$WebGLRenderbuffe = _ref.WebGLRenderbuffer,
    WebGLRenderbuffer = _ref$WebGLRenderbuffe === void 0 ? DummyType : _ref$WebGLRenderbuffe,
    _ref$WebGLTexture = _ref.WebGLTexture,
    WebGLTexture = _ref$WebGLTexture === void 0 ? DummyType : _ref$WebGLTexture,
    _ref$WebGLUniformLoca = _ref.WebGLUniformLocation,
    WebGLUniformLocation = _ref$WebGLUniformLoca === void 0 ? DummyType : _ref$WebGLUniformLoca,
    _ref$WebGLActiveInfo = _ref.WebGLActiveInfo,
    WebGLActiveInfo = _ref$WebGLActiveInfo === void 0 ? DummyType : _ref$WebGLActiveInfo,
    _ref$WebGLShaderPreci = _ref.WebGLShaderPrecisionFormat,
    WebGLShaderPrecisionFormat = _ref$WebGLShaderPreci === void 0 ? DummyType : _ref$WebGLShaderPreci;

exports.WebGLShaderPrecisionFormat = WebGLShaderPrecisionFormat;
exports.WebGLActiveInfo = WebGLActiveInfo;
exports.WebGLUniformLocation = WebGLUniformLocation;
exports.WebGLTexture = WebGLTexture;
exports.WebGLRenderbuffer = WebGLRenderbuffer;
exports.WebGLFramebuffer = WebGLFramebuffer;
exports.WebGLBuffer = WebGLBuffer;
exports.WebGLShader = WebGLShader;
exports.WebGLProgram = WebGLProgram;
exports.WebGLRenderingContext = WebGLRenderingContext;
var webGLTypesAvailable = WebGLRenderingContext !== DummyType && WebGLProgram !== DummyType && WebGLShader !== DummyType && WebGLBuffer !== DummyType && WebGLFramebuffer !== DummyType && WebGLRenderbuffer !== DummyType && WebGLTexture !== DummyType && WebGLUniformLocation !== DummyType && WebGLActiveInfo !== DummyType && WebGLShaderPrecisionFormat !== DummyType;
exports.webGLTypesAvailable = webGLTypesAvailable;

function getWebGL2RenderingContext() {
  var WebGL2RenderingContextNotSupported = function WebGL2RenderingContextNotSupported() {
    (0, _classCallCheck2["default"])(this, WebGL2RenderingContextNotSupported);
  };

  return _globals.global.WebGL2RenderingContext || WebGL2RenderingContextNotSupported;
}

function getImage() {
  var ImageNotSupported = function ImageNotSupported() {
    (0, _classCallCheck2["default"])(this, ImageNotSupported);
  };

  return _globals.global.Image || ImageNotSupported;
}

var WebGL2RenderingContext = getWebGL2RenderingContext();
exports.WebGL2RenderingContext = WebGL2RenderingContext;
var Image = getImage();
exports.Image = Image;

},{"../utils/globals":387,"../utils/is-browser":389,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/interopRequireDefault":25}],405:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],406:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}

;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":405}],407:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromQuat2 = fromQuat2;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}

;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":405}],408:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.getAngle = getAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.exp = exp;
exports.ln = ln;
exports.pow = pow;
exports.slerp = slerp;
exports.random = random;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var mat3 = _interopRequireWildcard(require("./mat3.js"));

var vec3 = _interopRequireWildcard(require("./vec3.js"));

var vec4 = _interopRequireWildcard(require("./vec4.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {quat} a     Origin unit quaternion 
 * @param  {quat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */


function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */


function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 * 
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;
},{"./common.js":405,"./mat3.js":406,"./vec3.js":410,"./vec4.js":411}],409:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */


function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":405}],410:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":405}],411:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}

;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":405}],412:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],413:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _common = require("../lib/common");

var Polygon = function () {
  function Polygon(points) {
    (0, _classCallCheck2.default)(this, Polygon);
    this.points = points;
    this.isClosed = (0, _common.equals)(this.points[this.points.length - 1], this.points[0]);
    Object.freeze(this);
  }

  (0, _createClass2.default)(Polygon, [{
    key: "getSignedArea",
    value: function getSignedArea() {
      var area = 0;
      this.forEachSegment(function (p1, p2) {
        area += (p1[0] + p2[0]) * (p1[1] - p2[1]);
      });
      return area / 2;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      return Math.abs(this.getSignedArea());
    }
  }, {
    key: "getWindingDirection",
    value: function getWindingDirection() {
      return Math.sign(this.getSignedArea());
    }
  }, {
    key: "forEachSegment",
    value: function forEachSegment(visitor) {
      var length = this.points.length;

      for (var i = 0; i < length - 1; i++) {
        visitor(this.points[i], this.points[i + 1], i, i + 1);
      }

      if (this.isPolygon && !this.isClosed()) {
        visitor(this.points[length - 1], this.points[0], length - 1, 0);
      }
    }
  }]);
  return Polygon;
}();

exports.default = Polygon;

},{"../lib/common":416,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],414:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _common = require("./lib/common");

var _matrix = _interopRequireDefault(require("./matrix4"));

var _quaternion2 = _interopRequireDefault(require("./quaternion"));

var _vector = _interopRequireDefault(require("./vector3"));

var ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
var ALMOST_ONE = 0.99999;

function validateOrder(value) {
  return value >= 0 && value < 6;
}

function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }

  return value;
}

var Euler = function (_MathArray) {
  (0, _inherits2.default)(Euler, _MathArray);
  (0, _createClass2.default)(Euler, [{
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }], [{
    key: "rotationOrder",
    value: function rotationOrder(order) {
      return Euler.RotationOrders[order];
    }
  }, {
    key: "ZYX",
    get: function get() {
      return 0;
    }
  }, {
    key: "YXZ",
    get: function get() {
      return 1;
    }
  }, {
    key: "XZY",
    get: function get() {
      return 2;
    }
  }, {
    key: "ZXY",
    get: function get() {
      return 3;
    }
  }, {
    key: "YZX",
    get: function get() {
      return 4;
    }
  }, {
    key: "XYZ",
    get: function get() {
      return 5;
    }
  }, {
    key: "RollPitchYaw",
    get: function get() {
      return 0;
    }
  }, {
    key: "DefaultOrder",
    get: function get() {
      return Euler.ZYX;
    }
  }, {
    key: "RotationOrders",
    get: function get() {
      return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
    }
  }]);

  function Euler() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;
    (0, _classCallCheck2.default)(this, Euler);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Euler).call(this, 4));

    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      var _this2;

      (_this2 = _this).fromVector3.apply(_this2, arguments);
    } else {
      _this.set(x, y, z, order);
    }

    return _this;
  }

  (0, _createClass2.default)(Euler, [{
    key: "fromQuaternion",
    value: function fromQuaternion(quaternion) {
      var _quaternion = (0, _slicedToArray2.default)(quaternion, 4),
          x = _quaternion[0],
          y = _quaternion[1],
          z = _quaternion[2],
          w = _quaternion[3];

      var ysqr = y * y;
      var t0 = -2.0 * (ysqr + z * z) + 1.0;
      var t1 = +2.0 * (x * y + w * z);
      var t2 = -2.0 * (x * z - w * y);
      var t3 = +2.0 * (y * z + w * x);
      var t4 = -2.0 * (x * x + ysqr) + 1.0;
      t2 = t2 > 1.0 ? 1.0 : t2;
      t2 = t2 < -1.0 ? -1.0 : t2;
      var roll = Math.atan2(t3, t4);
      var pitch = Math.asin(t2);
      var yaw = Math.atan2(t1, t0);
      return new Euler(roll, pitch, yaw, Euler.RollPitchYaw);
    }
  }, {
    key: "copy",
    value: function copy(array) {
      for (var i = 0; i < 3; ++i) {
        this[i] = array[i];
      }

      this[3] = Number.isFinite(array[3]) || this.order;
      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments.length > 3 ? arguments[3] : undefined;
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = Number.isFinite(order) ? order : this[3];
      return this.check();
    }
  }, {
    key: "validate",
    value: function validate() {
      return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      return array;
    }
  }, {
    key: "toArray4",
    value: function toArray4() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      array[offset + 3] = this[3];
      return array;
    }
  }, {
    key: "toVector3",
    value: function toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this[0], this[1], this[2]);
      }

      return new _vector.default(this[0], this[1], this[2]);
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v, order) {
      return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this[0] = array[0 + offset];
      this[1] = array[1 + offset];
      this[2] = array[2 + offset];

      if (array[3] !== undefined) {
        this[3] = array[3];
      }

      return this.check();
    }
  }, {
    key: "fromRollPitchYaw",
    value: function fromRollPitchYaw(roll, pitch, yaw) {
      return this.set(roll, pitch, yaw, Euler.ZYX);
    }
  }, {
    key: "fromRotationMatrix",
    value: function fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;

      this._fromRotationMatrix(m, order);

      return this.check();
    }
  }, {
    key: "getRotationMatrix",
    value: function getRotationMatrix() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _matrix.default();

      this._getRotationMatrix(m);

      return m;
    }
  }, {
    key: "getQuaternion",
    value: function getQuaternion() {
      var q = new _quaternion2.default();

      switch (this[4]) {
        case Euler.XYZ:
          return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);

        case Euler.YXZ:
          return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);

        case Euler.ZXY:
          return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);

        case Euler.ZYX:
          return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);

        case Euler.YZX:
          return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);

        case Euler.XZY:
          return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }
    }
  }, {
    key: "_fromRotationMatrix",
    value: function _fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;
      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];
      order = order || this[3];

      switch (order) {
        case Euler.XYZ:
          this[1] = Math.asin((0, _common.clamp)(m13, -1, 1));

          if (Math.abs(m13) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m33);
            this[2] = Math.atan2(-m12, m11);
          } else {
            this[0] = Math.atan2(m32, m22);
            this[2] = 0;
          }

          break;

        case Euler.YXZ:
          this[0] = Math.asin(-(0, _common.clamp)(m23, -1, 1));

          if (Math.abs(m23) < ALMOST_ONE) {
            this[1] = Math.atan2(m13, m33);
            this[2] = Math.atan2(m21, m22);
          } else {
            this[1] = Math.atan2(-m31, m11);
            this[2] = 0;
          }

          break;

        case Euler.ZXY:
          this[0] = Math.asin((0, _common.clamp)(m32, -1, 1));

          if (Math.abs(m32) < ALMOST_ONE) {
            this[1] = Math.atan2(-m31, m33);
            this[2] = Math.atan2(-m12, m22);
          } else {
            this[1] = 0;
            this[2] = Math.atan2(m21, m11);
          }

          break;

        case Euler.ZYX:
          this[1] = Math.asin(-(0, _common.clamp)(m31, -1, 1));

          if (Math.abs(m31) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m33);
            this[2] = Math.atan2(m21, m11);
          } else {
            this[0] = 0;
            this[2] = Math.atan2(-m12, m22);
          }

          break;

        case Euler.YZX:
          this[2] = Math.asin((0, _common.clamp)(m21, -1, 1));

          if (Math.abs(m21) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m22);
            this[1] = Math.atan2(-m31, m11);
          } else {
            this[0] = 0;
            this[1] = Math.atan2(m13, m33);
          }

          break;

        case Euler.XZY:
          this[2] = Math.asin(-(0, _common.clamp)(m12, -1, 1));

          if (Math.abs(m12) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m22);
            this[1] = Math.atan2(m13, m11);
          } else {
            this[0] = Math.atan2(-m23, m33);
            this[1] = 0;
          }

          break;

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      this[3] = order;
      return this;
    }
  }, {
    key: "_getRotationMatrix",
    value: function _getRotationMatrix() {
      var te = new _matrix.default();
      var x = this.x,
          y = this.y,
          z = this.z;
      var a = Math.cos(x);
      var c = Math.cos(y);
      var e = Math.cos(z);
      var b = Math.sin(x);
      var d = Math.sin(y);
      var f = Math.sin(z);

      switch (this[3]) {
        case Euler.XYZ:
          {
            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
            break;
          }

        case Euler.YXZ:
          {
            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
            break;
          }

        case Euler.ZXY:
          {
            var _ce = c * e,
                _cf = c * f,
                _de = d * e,
                _df = d * f;

            te[0] = _ce - _df * b;
            te[4] = -a * f;
            te[8] = _de + _cf * b;
            te[1] = _cf + _de * b;
            te[5] = a * e;
            te[9] = _df - _ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
            break;
          }

        case Euler.ZYX:
          {
            var _ae = a * e,
                _af = a * f,
                _be = b * e,
                _bf = b * f;

            te[0] = c * e;
            te[4] = _be * d - _af;
            te[8] = _ae * d + _bf;
            te[1] = c * f;
            te[5] = _bf * d + _ae;
            te[9] = _af * d - _be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
            break;
          }

        case Euler.YZX:
          {
            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
            break;
          }

        case Euler.XZY:
          {
            var _ac = a * c,
                _ad = a * d,
                _bc = b * c,
                _bd = b * d;

            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = _ac * f + _bd;
            te[5] = a * e;
            te[9] = _ad * f - _bc;
            te[2] = _bc * f - _ad;
            te[6] = b * e;
            te[10] = _bd * f + _ac;
            break;
          }

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "toQuaternion",
    value: function toQuaternion() {
      var cy = Math.cos(this.yaw * 0.5);
      var sy = Math.sin(this.yaw * 0.5);
      var cr = Math.cos(this.roll * 0.5);
      var sr = Math.sin(this.roll * 0.5);
      var cp = Math.cos(this.pitch * 0.5);
      var sp = Math.sin(this.pitch * 0.5);
      var w = cy * cr * cp + sy * sr * sp;
      var x = cy * sr * cp - sy * cr * sp;
      var y = cy * cr * sp + sy * sr * cp;
      var z = sy * cr * cp - cy * sr * sp;
      return new _quaternion2.default(x, y, z, w);
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "alpha",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "beta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "gamma",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "phi",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "theta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "psi",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "roll",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "pitch",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "yaw",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "order",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = checkOrder(value);
    }
  }]);
  return Euler;
}(_mathArray.default);

exports.default = Euler;

},{"./lib/common":416,"./lib/math-array":417,"./matrix4":421,"./quaternion":423,"./vector3":426,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37}],415:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Vector2", {
  enumerable: true,
  get: function get() {
    return _vector.default;
  }
});
Object.defineProperty(exports, "Vector3", {
  enumerable: true,
  get: function get() {
    return _vector2.default;
  }
});
Object.defineProperty(exports, "Vector4", {
  enumerable: true,
  get: function get() {
    return _vector3.default;
  }
});
Object.defineProperty(exports, "Matrix3", {
  enumerable: true,
  get: function get() {
    return _matrix.default;
  }
});
Object.defineProperty(exports, "Matrix4", {
  enumerable: true,
  get: function get() {
    return _matrix2.default;
  }
});
Object.defineProperty(exports, "Quaternion", {
  enumerable: true,
  get: function get() {
    return _quaternion.default;
  }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function get() {
    return _common.config;
  }
});
Object.defineProperty(exports, "checkNumber", {
  enumerable: true,
  get: function get() {
    return _common.checkNumber;
  }
});
Object.defineProperty(exports, "configure", {
  enumerable: true,
  get: function get() {
    return _common.configure;
  }
});
Object.defineProperty(exports, "formatValue", {
  enumerable: true,
  get: function get() {
    return _common.formatValue;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return _common.isArray;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function get() {
    return _common.clone;
  }
});
Object.defineProperty(exports, "radians", {
  enumerable: true,
  get: function get() {
    return _common.radians;
  }
});
Object.defineProperty(exports, "degrees", {
  enumerable: true,
  get: function get() {
    return _common.degrees;
  }
});
Object.defineProperty(exports, "sin", {
  enumerable: true,
  get: function get() {
    return _common.sin;
  }
});
Object.defineProperty(exports, "cos", {
  enumerable: true,
  get: function get() {
    return _common.cos;
  }
});
Object.defineProperty(exports, "tan", {
  enumerable: true,
  get: function get() {
    return _common.tan;
  }
});
Object.defineProperty(exports, "asin", {
  enumerable: true,
  get: function get() {
    return _common.asin;
  }
});
Object.defineProperty(exports, "acos", {
  enumerable: true,
  get: function get() {
    return _common.acos;
  }
});
Object.defineProperty(exports, "atan", {
  enumerable: true,
  get: function get() {
    return _common.atan;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function get() {
    return _common.clamp;
  }
});
Object.defineProperty(exports, "lerp", {
  enumerable: true,
  get: function get() {
    return _common.lerp;
  }
});
Object.defineProperty(exports, "equals", {
  enumerable: true,
  get: function get() {
    return _common.equals;
  }
});
Object.defineProperty(exports, "_SphericalCoordinates", {
  enumerable: true,
  get: function get() {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "_Pose", {
  enumerable: true,
  get: function get() {
    return _pose.default;
  }
});
Object.defineProperty(exports, "_Euler", {
  enumerable: true,
  get: function get() {
    return _euler.default;
  }
});
Object.defineProperty(exports, "_Polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.default;
  }
});

var _vector = _interopRequireDefault(require("./vector2"));

var _vector2 = _interopRequireDefault(require("./vector3"));

var _vector3 = _interopRequireDefault(require("./vector4"));

var _matrix = _interopRequireDefault(require("./matrix3"));

var _matrix2 = _interopRequireDefault(require("./matrix4"));

var _quaternion = _interopRequireDefault(require("./quaternion"));

var _common = require("./lib/common");

var _sphericalCoordinates = _interopRequireDefault(require("./spherical-coordinates"));

var _pose = _interopRequireDefault(require("./pose"));

var _euler = _interopRequireDefault(require("./euler"));

var _polygon = _interopRequireDefault(require("./addons/polygon"));

},{"./addons/polygon":413,"./euler":414,"./lib/common":416,"./matrix3":420,"./matrix4":421,"./pose":422,"./quaternion":423,"./spherical-coordinates":424,"./vector2":425,"./vector3":426,"./vector4":427,"@babel/runtime/helpers/interopRequireDefault":25}],416:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configure = configure;
exports.checkNumber = checkNumber;
exports.formatValue = formatValue;
exports.formatAngle = formatAngle;
exports.isArray = isArray;
exports.clone = clone;
exports.radians = radians;
exports.degrees = degrees;
exports.sin = sin;
exports.cos = cos;
exports.tan = tan;
exports.asin = asin;
exports.acos = acos;
exports.atan = atan;
exports.clamp = clamp;
exports.lerp = lerp;
exports.equals = equals;
exports.config = void 0;
var config = {};
exports.config = config;
config.EPSILON = 1e-12;
config.debug = true;
config.precision = 4;
config.printTypes = false;
config.printDegrees = false;
config.printRowMajor = true;

function configure(options) {
  if ('epsilon' in options) {
    config.EPSILON = options.epsilon;
  }

  if ('debug' in options) {
    config.debug = options.debug;
  }
}

function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }

  return value;
}

function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

function formatValue(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$precision = _ref.precision,
      precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;

  value = round(value);
  return parseFloat(value.toPrecision(precision));
}

function formatAngle(value) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$precision = _ref2.precision,
      precision = _ref2$precision === void 0 ? config.precision || 4 : _ref2$precision,
      _ref2$printDegrees = _ref2.printDegrees,
      printDegrees = _ref2$printDegrees === void 0 ? config.printAngles : _ref2$printDegrees;

  value = printDegrees ? degrees(value) : value;
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision))).concat(printDegrees ? '°' : '');
}

function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && value.length !== undefined;
}

function clone(array) {
  return array.clone ? array.clone() : new Array(array);
}

function map(value, func) {
  if (isArray(value)) {
    var result = clone(value);

    for (var i = 0; i < result.length; ++i) {
      result[i] = func(result[i], i, result);
    }

    return result;
  }

  return func(value);
}

function radians(degrees) {
  return map(degrees, function (degrees) {
    return degrees / 180 * Math.PI;
  });
}

function degrees(radians) {
  return map(radians, function (radians) {
    return radians * 180 / Math.PI;
  });
}

function sin(radians) {
  return map(radians, function (angle) {
    return Math.sin(angle);
  });
}

function cos(radians) {
  return map(radians, function (angle) {
    return Math.cos(angle);
  });
}

function tan(radians) {
  return map(radians, function (angle) {
    return Math.tan(angle);
  });
}

function asin(radians) {
  return map(radians, function (angle) {
    return Math.asin(angle);
  });
}

function acos(radians) {
  return map(radians, function (angle) {
    return Math.acos(angle);
  });
}

function atan(radians) {
  return map(radians, function (angle) {
    return Math.atan(angle);
  });
}

function clamp(value, min, max) {
  return map(value, function (value) {
    return Math.max(min, Math.min(max, value));
  });
}

function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map(function (ai, i) {
      return lerp(ai, b[i], t);
    });
  }

  return t * b + (1 - t) * a;
}

function equals(a, b) {
  if (isArray(a) && isArray(b)) {
    if (a === b) {
      return true;
    }

    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; ++i) {
      if (!equals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

},{}],417:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _common = require("./common");

var MathArray = function (_Array) {
  (0, _inherits2.default)(MathArray, _Array);

  function MathArray() {
    (0, _classCallCheck2.default)(this, MathArray);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MathArray).apply(this, arguments));
  }

  (0, _createClass2.default)(MathArray, [{
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this).check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i];
      }

      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = (i < 0 || arguments.length <= i ? undefined : arguments[i]) || 0;
      }

      return this.check();
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }

      return this.check();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.formatString(_common.config);
    }
  }, {
    key: "formatString",
    value: function formatString(opts) {
      var string = '';

      for (var i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ', ' : '') + (0, _common.formatValue)(this[i], opts);
      }

      return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        array[offset + i] = this[i];
      }

      return array;
    }
  }, {
    key: "toFloat32Array",
    value: function toFloat32Array() {
      return new Float32Array(this);
    }
  }, {
    key: "equals",
    value: function equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (!(0, _common.equals)(this[i], array[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "negate",
    value: function negate() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }

      return this.check();
    }
  }, {
    key: "inverse",
    value: function inverse() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = 1 / this[i];
      }

      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      if (t === undefined) {
        t = b;
        b = a;
        a = this;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var ai = a[i];
        this[i] = ai + t * (b[i] - ai);
      }

      return this.check();
    }
  }, {
    key: "min",
    value: function min(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "max",
    value: function max(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "clamp",
    value: function clamp(minVector, maxVector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }

      return this.check();
    }
  }, {
    key: "validate",
    value: function validate() {
      var valid = this.length === this.ELEMENTS;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }

      return valid;
    }
  }, {
    key: "check",
    value: function check() {
      if (_common.config.debug && !this.validate(this)) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }

      return this;
    }
  }, {
    key: "sub",
    value: function sub(a) {
      return this.subtract(a);
    }
  }, {
    key: "setScalar",
    value: function setScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }

      return this.check();
    }
  }, {
    key: "addScalar",
    value: function addScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }

      return this.check();
    }
  }, {
    key: "subScalar",
    value: function subScalar(a) {
      return this.addScalar(-a);
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(a) {
      return this.scale(a);
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(a) {
      return this.scale(1 / a);
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(min, max) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min), max);
      }

      return this.check();
    }
  }]);
  return MathArray;
}((0, _wrapNativeSuper2.default)(Array));

exports.default = MathArray;

},{"./common":416,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/wrapNativeSuper":42}],418:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateVector = validateVector;

function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }

  return v.every(Number.isFinite);
}

},{}],419:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _mathArray = _interopRequireDefault(require("./math-array"));

var _common = require("./common");

var assert = function assert(x, m) {
  if (!x) {
    throw new Error(m);
  }
};

var Vector = function (_MathArray) {
  (0, _inherits2.default)(Vector, _MathArray);

  function Vector() {
    (0, _classCallCheck2.default)(this, Vector);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector).apply(this, arguments));
  }

  (0, _createClass2.default)(Vector, [{
    key: "len",
    value: function len() {
      return Math.sqrt(this.lengthSquared());
    }
  }, {
    key: "magnitude",
    value: function magnitude() {
      return Math.sqrt(this.lengthSquared());
    }
  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        length += this[i] * this[i];
      }

      return length;
    }
  }, {
    key: "distance",
    value: function distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
  }, {
    key: "distanceSquared",
    value: function distanceSquared(mathArray) {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var dist = this[i] - mathArray[i];
        length += dist * dist;
      }

      return (0, _common.checkNumber)(length);
    }
  }, {
    key: "dot",
    value: function dot(mathArray) {
      var product = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        product += this[i] * mathArray[i];
      }

      return (0, _common.checkNumber)(product);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var length = this.magnitude();

      if (length !== 0) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length;
        }
      }

      return this.check();
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      for (var _i = 0; _i < vectors.length; _i++) {
        var vector = vectors[_i];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "subtract",
    value: function subtract() {
      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      for (var _i2 = 0; _i2 < vectors.length; _i2++) {
        var vector = vectors[_i2];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "multiply",
    value: function multiply() {
      for (var _len3 = arguments.length, vectors = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        vectors[_key3] = arguments[_key3];
      }

      for (var _i3 = 0; _i3 < vectors.length; _i3++) {
        var vector = vectors[_i3];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "divide",
    value: function divide() {
      for (var _len4 = arguments.length, vectors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        vectors[_key4] = arguments[_key4];
      }

      for (var _i4 = 0; _i4 < vectors.length; _i4++) {
        var vector = vectors[_i4];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(_scale) {
      if (Array.isArray(_scale)) {
        return this.multiply(_scale);
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= _scale;
      }

      return this.check();
    }
  }, {
    key: "scaleAndAdd",
    value: function scaleAndAdd(vector, scale) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = this[i] * scale + vector[i];
      }

      return this.check();
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.lengthSquared();
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(vector) {
      return this.distance(vector);
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
  }, {
    key: "getComponent",
    value: function getComponent(i) {
      assert(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      return (0, _common.checkNumber)(this[i]);
    }
  }, {
    key: "setComponent",
    value: function setComponent(i, value) {
      assert(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      this[i] = value;
      return this.check();
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      return this.copy(a).add(b);
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      return this.copy(a).subtract(b);
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(a, b) {
      return this.copy(a).multiply(b);
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(a, b) {
      return this.add(new this.constructor(a).multiplyScalar(b));
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }]);
  return Vector;
}(_mathArray.default);

exports.default = Vector;

},{"./common":416,"./math-array":417,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],420:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateMatrix3 = validateMatrix3;
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _validators = require("./lib/validators");

var _common = require("./lib/common");

var _vector = _interopRequireDefault(require("./vector2"));

var _vector2 = _interopRequireDefault(require("./vector3"));

var mat3 = _interopRequireWildcard(require("gl-matrix/mat3"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var IDENTITY = [1, 0, 0, 0, 1, 0, 0, 0, 1];

function validateMatrix3(m) {
  return m.length === 9 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]) && Number.isFinite(m[6]) && Number.isFinite(m[7]) && Number.isFinite(m[8]);
}

var Matrix3 = function (_MathArray) {
  (0, _inherits2.default)(Matrix3, _MathArray);

  function Matrix3() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _classCallCheck2.default)(this, Matrix3);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Matrix3).call(this, 9));

    if (Array.isArray(args[0]) && arguments.length === 1) {
      _this.copy(args[0]);
    } else {
      _this.identity();
    }

    return _this;
  }

  (0, _createClass2.default)(Matrix3, [{
    key: "setRowMajor",
    value: function setRowMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m01 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m02 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m10 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m11 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var m12 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var m20 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m21 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m22 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "setColumnMajor",
    value: function setColumnMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m01 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m11 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var m21 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var m02 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m12 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m22 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      return this.setColumnMajor.apply(this, (0, _toConsumableArray2.default)(array));
    }
  }, {
    key: "set",
    value: function set() {
      return this.setColumnMajor.apply(this, arguments);
    }
  }, {
    key: "getElement",
    value: function getElement(i, j) {
      var columnMajor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return columnMajor ? this[i * 3 + j] : this[j * 3 + i];
    }
  }, {
    key: "setElement",
    value: function setElement(i, j, value) {
      var columnMajor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (columnMajor) {
        this[i * 3 + j] = (0, _common.checkNumber)(value);
      } else {
        this[j * 3 + i] = (0, _common.checkNumber)(value);
      }

      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return mat3.determinant(this);
    }
  }, {
    key: "identity",
    value: function identity() {
      for (var i = 0; i < IDENTITY.length; ++i) {
        this[i] = IDENTITY[i];
      }

      return this.check();
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      mat3.fromQuat(this, q);
      return this.check();
    }
  }, {
    key: "transpose",
    value: function transpose() {
      mat3.transpose(this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      mat3.invert(this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      mat3.multiply(this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      mat3.multiply(this, this, a);
      return this.check();
    }
  }, {
    key: "rotate",
    value: function rotate(radians) {
      mat3.rotate(this, this, radians);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        mat3.scale(this, this, factor);
      } else {
        mat3.scale(this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      mat3.translate(this, this, vec);
      return this.check();
    }
  }, {
    key: "transformVector2",
    value: function transformVector2(vector, out) {
      out = out || new _vector.default();
      vec2.transformMat3(out, vector, this);
      (0, _validators.validateVector)(out, 2);
      return out;
    }
  }, {
    key: "transformVector3",
    value: function transformVector3(vector, out) {
      out = out || new _vector2.default();
      vec3.transformMat3(out, vector, this);
      (0, _validators.validateVector)(out, 3);
      return out;
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, out) {
      switch (vector.length) {
        case 2:
          return this.transformVector2(vector, out);

        case 3:
          return this.transformVector3(vector, out);

        default:
          throw new Error('Illegal vector');
      }
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 9;
    }
  }]);
  return Matrix3;
}(_mathArray.default);

exports.default = Matrix3;

},{"./lib/common":416,"./lib/math-array":417,"./lib/validators":418,"./vector2":425,"./vector3":426,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/toConsumableArray":39,"gl-matrix/mat3":406,"gl-matrix/vec2":409,"gl-matrix/vec3":410}],421:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateMatrix4 = validateMatrix4;
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _common = require("./lib/common");

var _validators = require("./lib/validators");

var _vector = _interopRequireDefault(require("./vector2"));

var _vector2 = _interopRequireDefault(require("./vector3"));

var _vector3 = _interopRequireDefault(require("./vector4"));

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

function validateMatrix4(m) {
  return m.length === 16 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]) && Number.isFinite(m[6]) && Number.isFinite(m[7]) && Number.isFinite(m[8]) && Number.isFinite(m[9]) && Number.isFinite(m[10]) && Number.isFinite(m[11]) && Number.isFinite(m[12]) && Number.isFinite(m[13]) && Number.isFinite(m[14]) && Number.isFinite(m[15]);
}

var Matrix4 = function (_MathArray) {
  (0, _inherits2.default)(Matrix4, _MathArray);

  function Matrix4() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _classCallCheck2.default)(this, Matrix4);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Matrix4).call(this, 16));

    if (Array.isArray(args[0]) && arguments.length === 1) {
      _this.copy(args[0]);
    } else {
      _this.identity();
    }

    return _this;
  }

  (0, _createClass2.default)(Matrix4, [{
    key: "setRowMajor",
    value: function setRowMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m01 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m02 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m03 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m10 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var m12 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m13 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m20 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var m21 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
      var m23 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
      var m30 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      var m31 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      var m32 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "setColumnMajor",
    value: function setColumnMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m30 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m01 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var m21 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m31 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m02 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var m12 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
      var m32 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
      var m03 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      var m13 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      var m23 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      return this.setColumnMajor.apply(this, arguments);
    }
  }, {
    key: "getElement",
    value: function getElement(i, j) {
      var columnMajor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return columnMajor ? this[i][j] : this[j][i];
    }
  }, {
    key: "setElement",
    value: function setElement(i, j, value) {
      var columnMajor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (columnMajor) {
        this[i][j] = (0, _common.checkNumber)(value);
      } else {
        this[j][i] = (0, _common.checkNumber)(value);
      }

      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return mat4.determinant(this);
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.copy(IDENTITY);
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      mat4.fromQuat(this, q);
      return this.check();
    }
  }, {
    key: "frustum",
    value: function frustum(_ref) {
      var left = _ref.left,
          right = _ref.right,
          bottom = _ref.bottom,
          top = _ref.top,
          near = _ref.near,
          far = _ref.far;
      mat4.frustum(this, left, right, bottom, top, near, far);
      return this.check();
    }
  }, {
    key: "lookAt",
    value: function lookAt(_ref2) {
      var eye = _ref2.eye,
          _ref2$center = _ref2.center,
          center = _ref2$center === void 0 ? [0, 0, 0] : _ref2$center,
          _ref2$up = _ref2.up,
          up = _ref2$up === void 0 ? [0, 1, 0] : _ref2$up;
      mat4.lookAt(this, eye, center, up);
      return this.check();
    }
  }, {
    key: "ortho",
    value: function ortho(_ref3) {
      var left = _ref3.left,
          right = _ref3.right,
          bottom = _ref3.bottom,
          top = _ref3.top,
          _ref3$near = _ref3.near,
          near = _ref3$near === void 0 ? 0.1 : _ref3$near,
          _ref3$far = _ref3.far,
          far = _ref3$far === void 0 ? 500 : _ref3$far;
      mat4.ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
  }, {
    key: "orthographic",
    value: function orthographic(_ref4) {
      var _ref4$fovy = _ref4.fovy,
          fovy = _ref4$fovy === void 0 ? 45 * Math.PI / 180 : _ref4$fovy,
          _ref4$aspect = _ref4.aspect,
          aspect = _ref4$aspect === void 0 ? 1 : _ref4$aspect,
          _ref4$focalDistance = _ref4.focalDistance,
          focalDistance = _ref4$focalDistance === void 0 ? 1 : _ref4$focalDistance,
          _ref4$near = _ref4.near,
          near = _ref4$near === void 0 ? 0.1 : _ref4$near,
          _ref4$far = _ref4.far,
          far = _ref4$far === void 0 ? 500 : _ref4$far;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      var halfY = fovy / 2;
      var top = focalDistance * Math.tan(halfY);
      var right = top * aspect;
      return new Matrix4().ortho({
        left: -right,
        right: right,
        bottom: -top,
        top: top,
        near: near,
        far: far
      });
    }
  }, {
    key: "perspective",
    value: function perspective() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          fovy = _ref5.fovy,
          _ref5$fov = _ref5.fov,
          fov = _ref5$fov === void 0 ? 45 * Math.PI / 180 : _ref5$fov,
          _ref5$aspect = _ref5.aspect,
          aspect = _ref5$aspect === void 0 ? 1 : _ref5$aspect,
          _ref5$near = _ref5.near,
          near = _ref5$near === void 0 ? 0.1 : _ref5$near,
          _ref5$far = _ref5.far,
          far = _ref5$far === void 0 ? 500 : _ref5$far;

      fovy = fovy || fov;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      mat4.perspective(this, fovy, aspect, near, far);
      return this.check();
    }
  }, {
    key: "transpose",
    value: function transpose() {
      mat4.transpose(this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      mat4.invert(this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      mat4.multiply(this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      mat4.multiply(this, this, a);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(radians) {
      mat4.rotateX(this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(radians) {
      mat4.rotateY(this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(radians) {
      mat4.rotateZ(this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateXYZ",
    value: function rotateXYZ(_ref6) {
      var _ref7 = (0, _slicedToArray2.default)(_ref6, 3),
          rx = _ref7[0],
          ry = _ref7[1],
          rz = _ref7[2];

      return this.rotateX(rx).rotateY(ry).rotateZ(rz);
    }
  }, {
    key: "rotateAxis",
    value: function rotateAxis(radians, axis) {
      mat4.rotate(this, this, radians, axis);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        mat4.scale(this, this, factor);
      } else {
        mat4.scale(this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      mat4.translate(this, this, vec);
      return this.check();
    }
  }, {
    key: "transformVector2",
    value: function transformVector2(vector, out) {
      out = out || new _vector.default();
      vec2.transformMat4(out, vector, this);
      (0, _validators.validateVector)(out, 2);
      return out;
    }
  }, {
    key: "transformVector3",
    value: function transformVector3(vector, out) {
      out = out || new _vector2.default();
      vec3.transformMat4(out, vector, this);
      (0, _validators.validateVector)(out, 3);
      return out;
    }
  }, {
    key: "transformVector4",
    value: function transformVector4(vector, out) {
      out = out || new _vector3.default();
      vec4.transformMat4(out, vector, this);
      (0, _validators.validateVector)(out, 4);
      return out.check();
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, out) {
      switch (vector.length) {
        case 2:
          return this.transformVector2(vector, out);

        case 3:
          return this.transformVector3(vector, out);

        case 4:
          return this.transformVector4(vector, out);

        default:
          throw new Error('Illegal vector');
      }
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(vector, out) {
      return this._transformVector(vector, out, 0);
    }
  }, {
    key: "transformPoint",
    value: function transformPoint(vector, out) {
      return this._transformVector(vector, out, 1);
    }
  }, {
    key: "_transformVector",
    value: function _transformVector(vector, out, w) {
      switch (vector.length) {
        case 2:
          out = out || new _vector.default();
          vec4.transformMat4(out, [vector[0], vector[1], 0, w], this);
          out.length = 2;
          (0, _validators.validateVector)(out, 2);
          break;

        case 3:
          out = out || new _vector2.default();
          vec4.transformMat4(out, [vector[0], vector[1], vector[2], w], this);
          out.length = 3;
          (0, _validators.validateVector)(out, 3);
          break;

        case 4:
          if (Boolean(w) !== Boolean(vector[3])) {
            throw new Error('math.gl: Matrix4.transformPoint - invalid vector');
          }

          out = out || new _vector3.default();
          vec4.transformMat4(out, vector, this);
          (0, _validators.validateVector)(out, 4);
          break;

        default:
          throw new Error('Illegal vector');
      }

      return out;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 16;
    }
  }]);
  return Matrix4;
}(_mathArray.default);

exports.default = Matrix4;

},{"./lib/common":416,"./lib/math-array":417,"./lib/validators":418,"./vector2":425,"./vector3":426,"./vector4":427,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"@babel/runtime/helpers/slicedToArray":37,"gl-matrix/mat4":407,"gl-matrix/vec2":409,"gl-matrix/vec3":410,"gl-matrix/vec4":411}],422:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _matrix = _interopRequireDefault(require("./matrix4"));

var _vector = _interopRequireDefault(require("./vector3"));

var _euler = _interopRequireDefault(require("./euler"));

var Pose = function () {
  function Pose(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$z = _ref.z,
        z = _ref$z === void 0 ? 0 : _ref$z,
        _ref$roll = _ref.roll,
        roll = _ref$roll === void 0 ? 0 : _ref$roll,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
        _ref$yaw = _ref.yaw,
        yaw = _ref$yaw === void 0 ? 0 : _ref$yaw,
        position = _ref.position,
        orientation = _ref.orientation;
    (0, _classCallCheck2.default)(this, Pose);

    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector.default(position);
    } else {
      this.position = new _vector.default(x, y, z);
    }

    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler.default(orientation, orientation[3]);
    } else {
      this.orientation = new _euler.default(roll, pitch, yaw, _euler.default.RollPitchYaw);
    }
  }

  (0, _createClass2.default)(Pose, [{
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getOrientation",
    value: function getOrientation() {
      return this.orientation;
    }
  }, {
    key: "equals",
    value: function equals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
    }
  }, {
    key: "getTransformationMatrix",
    value: function getTransformationMatrix() {
      var sr = Math.sin(this.roll);
      var sp = Math.sin(this.pitch);
      var sw = Math.sin(this.yaw);
      var cr = Math.cos(this.roll);
      var cp = Math.cos(this.pitch);
      var cw = Math.cos(this.yaw);
      var matrix = new _matrix.default().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
      return matrix;
    }
  }, {
    key: "getTransformationMatrixFromPose",
    value: function getTransformationMatrixFromPose(pose) {
      return new _matrix.default().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
    }
  }, {
    key: "getTransformationMatrixToPose",
    value: function getTransformationMatrixToPose(pose) {
      return new _matrix.default().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
    }
  }, {
    key: "x",
    get: function get() {
      return this.position.x;
    },
    set: function set(value) {
      return this.position.x = value;
    }
  }, {
    key: "y",
    get: function get() {
      return this.position.y;
    },
    set: function set(value) {
      return this.position.y = value;
    }
  }, {
    key: "z",
    get: function get() {
      return this.position.z;
    },
    set: function set(value) {
      return this.position.z = value;
    }
  }, {
    key: "roll",
    get: function get() {
      return this.orientation.roll;
    },
    set: function set(value) {
      return this.orientation.roll = value;
    }
  }, {
    key: "pitch",
    get: function get() {
      return this.orientation.pitch;
    },
    set: function set(value) {
      return this.orientation.pitch = value;
    }
  }, {
    key: "yaw",
    get: function get() {
      return this.orientation.yaw;
    },
    set: function set(value) {
      return this.orientation.yaw = value;
    }
  }]);
  return Pose;
}();

exports.default = Pose;

},{"./euler":414,"./matrix4":421,"./vector3":426,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],423:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateQuaternion = validateQuaternion;
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _common = require("./lib/common");

var quat = _interopRequireWildcard(require("gl-matrix/quat"));

var IDENTITY_QUATERNION = [0, 0, 0, 1];

function validateQuaternion(q) {
  return q.length === 4 && Number.isFinite(q[0]) && Number.isFinite(q[1]) && Number.isFinite(q[2]) && Number.isFinite(q[3]);
}

var Quaternion = function (_MathArray) {
  (0, _inherits2.default)(Quaternion, _MathArray);

  function Quaternion() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    (0, _classCallCheck2.default)(this, Quaternion);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Quaternion).call(this, 4));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }

    return _this;
  }

  (0, _createClass2.default)(Quaternion, [{
    key: "fromMatrix3",
    value: function fromMatrix3(m) {
      quat.fromMat3(this, m);
      return this.check();
    }
  }, {
    key: "fromValues",
    value: function fromValues(x, y, z, w) {
      return this.set(x, y, z, w);
    }
  }, {
    key: "identity",
    value: function identity() {
      quat.identity(this);
      return this.check();
    }
  }, {
    key: "length",
    value: function length() {
      return quat.length(this);
    }
  }, {
    key: "squaredLength",
    value: function squaredLength(a) {
      return quat.squaredLength(this);
    }
  }, {
    key: "dot",
    value: function dot(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.dot only takes one argument');
      }

      return quat.dot(this, a);
    }
  }, {
    key: "rotationTo",
    value: function rotationTo(vectorA, vectorB) {
      quat.rotationTo(this, vectorA, vectorB);
      return this.check();
    }
  }, {
    key: "add",
    value: function add(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.add only takes one argument');
      }

      quat.add(this, a);
      return this.check();
    }
  }, {
    key: "calculateW",
    value: function calculateW() {
      quat.calculateW(this, this);
      return this.check();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      quat.conjugate(this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      quat.invert(this, this);
      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      quat.lerp(this, a, b, t);
      return this.check();
    }
  }, {
    key: "multiply",
    value: function multiply(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.multiply only takes one argument');
      }

      quat.multiply(this, this, a);
      return this.check();
    }
  }, {
    key: "normalize",
    value: function normalize() {
      quat.normalize(this, this);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(rad) {
      quat.rotateX(this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(rad) {
      quat.rotateY(this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(rad) {
      quat.rotateZ(this, this, rad);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(b) {
      quat.scale(this, this, b);
      return this.check();
    }
  }, {
    key: "set",
    value: function set(i, j, k, l) {
      quat.set(this, i, j, k, l);
      return this.check();
    }
  }, {
    key: "setAxisAngle",
    value: function setAxisAngle(axis, rad) {
      quat.setAxisAngle(this, axis, rad);
      return this.check();
    }
  }, {
    key: "slerp",
    value: function slerp(_ref) {
      var _ref$start = _ref.start,
          start = _ref$start === void 0 ? IDENTITY_QUATERNION : _ref$start,
          target = _ref.target,
          ratio = _ref.ratio;
      quat.slerp(this, start, target, ratio);
      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = (0, _common.checkNumber)(value);
    }
  }]);
  return Quaternion;
}(_mathArray.default);

exports.default = Quaternion;

},{"./lib/common":416,"./lib/math-array":417,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"gl-matrix/quat":408}],424:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _common = require("./lib/common");

var _vector = _interopRequireDefault(require("./vector3"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var EPSILON = 0.000001;
var EARTH_RADIUS_METERS = 6.371e6;

var SphericalCoordinates = function () {
  function SphericalCoordinates() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        phi = _ref.phi,
        theta = _ref.theta,
        radius = _ref.radius,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        altitude = _ref.altitude,
        _ref$radiusScale = _ref.radiusScale,
        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;

    (0, _classCallCheck2.default)(this, SphericalCoordinates);

    if (arguments.length === 0) {
      this.phi = 0;
      this.theta = 0;
      this.radius = 1;
    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {
      this.phi = phi || 0;
      this.theta = theta || 0;
    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {
      this.bearing = bearing || 0;
      this.pitch = pitch || 0;
    }

    this.radius = radius || 1;
    this.radiusScale = radiusScale || 1;
    this.check();
  }

  (0, _createClass2.default)(SphericalCoordinates, [{
    key: "toString",
    value: function toString() {
      return this.formatString(_common.config);
    }
  }, {
    key: "formatString",
    value: function formatString(_ref2) {
      var printTypes = _ref2.printTypes,
          printDegrees = _ref2.printDegrees;
      var f = _common.formatValue;
      return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return (0, _common.equals)(this.radius, other.radius) && (0, _common.equals)(this.theta, other.theta) && (0, _common.equals)(this.phi, other.phi);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
  }, {
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
  }, {
    key: "fromLngLatZ",
    value: function fromLngLatZ(_ref3) {
      var _ref4 = (0, _slicedToArray2.default)(_ref3, 3),
          lng = _ref4[0],
          lat = _ref4[1],
          z = _ref4[2];

      this.radius = 1 + z / this.radiusScale;
      this.phi = (0, _common.radians)(lat);
      this.theta = (0, _common.radians)(lng);
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v) {
      this.radius = vec3.length(v);

      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(v[0], v[1]);
        this.phi = Math.acos((0, _common.clamp)(v[2] / this.radius, -1, 1));
      }

      return this.check();
    }
  }, {
    key: "toVector3",
    value: function toVector3() {
      return new _vector.default(0, 0, this.radius).rotateX({
        radians: this.theta
      }).rotateZ({
        radians: this.phi
      });
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    }
  }, {
    key: "check",
    value: function check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error('SphericalCoordinates: some fields set to invalid numbers');
      }

      return this;
    }
  }, {
    key: "bearing",
    get: function get() {
      return 180 - (0, _common.degrees)(this.phi);
    },
    set: function set(v) {
      this.phi = Math.PI - (0, _common.radians)(v);
    }
  }, {
    key: "pitch",
    get: function get() {
      return (0, _common.degrees)(this.theta);
    },
    set: function set(v) {
      this.theta = (0, _common.radians)(v);
    }
  }, {
    key: "longitude",
    get: function get() {
      return (0, _common.degrees)(this.phi);
    }
  }, {
    key: "latitude",
    get: function get() {
      return (0, _common.degrees)(this.theta);
    }
  }, {
    key: "lng",
    get: function get() {
      return (0, _common.degrees)(this.phi);
    }
  }, {
    key: "lat",
    get: function get() {
      return (0, _common.degrees)(this.theta);
    }
  }, {
    key: "z",
    get: function get() {
      return (this.radius - 1) * this.radiusScale;
    }
  }]);
  return SphericalCoordinates;
}();

exports.default = SphericalCoordinates;

},{"./lib/common":416,"./vector3":426,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/slicedToArray":37,"gl-matrix/vec3":410}],425:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _vector = _interopRequireDefault(require("./lib/vector"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var Vector2 = function (_Vector) {
  (0, _inherits2.default)(Vector2, _Vector);

  function Vector2() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, Vector2);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector2).call(this, 2));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y);
    }

    return _this;
  }

  (0, _createClass2.default)(Vector2, [{
    key: "cross",
    value: function cross(vector) {
      vec2.cross(this, this, vector);
      return this.check();
    }
  }, {
    key: "horizontalAngle",
    value: function horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
  }, {
    key: "verticalAngle",
    value: function verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
  }, {
    key: "operation",
    value: function operation(_operation) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      _operation.apply(void 0, [this, this].concat(args));

      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 2;
    }
  }]);
  return Vector2;
}(_vector.default);

exports.default = Vector2;

},{"./lib/vector":419,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"gl-matrix/vec2":409}],426:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _vector = _interopRequireDefault(require("./lib/vector"));

var _common = require("./lib/common");

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var ORIGIN = [0, 0, 0];

var Vector3 = function (_Vector) {
  (0, _inherits2.default)(Vector3, _Vector);

  function Vector3() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    (0, _classCallCheck2.default)(this, Vector3);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector3).call(this, 3));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z);
    }

    return _this;
  }

  (0, _createClass2.default)(Vector3, [{
    key: "angle",
    value: function angle(vector) {
      return vec3.angle(this, vector);
    }
  }, {
    key: "cross",
    value: function cross(vector) {
      vec3.cross(this, this, vector);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(_ref) {
      var radians = _ref.radians,
          _ref$origin = _ref.origin,
          origin = _ref$origin === void 0 ? ORIGIN : _ref$origin;
      vec3.rotateX(this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(_ref2) {
      var radians = _ref2.radians,
          _ref2$origin = _ref2.origin,
          origin = _ref2$origin === void 0 ? ORIGIN : _ref2$origin;
      vec3.rotateY(this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(_ref3) {
      var radians = _ref3.radians,
          _ref3$origin = _ref3.origin,
          origin = _ref3$origin === void 0 ? ORIGIN : _ref3$origin;
      vec3.rotateZ(this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "operation",
    value: function operation(_operation) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      _operation.apply(void 0, [this, this].concat(args));

      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 3;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }]);
  return Vector3;
}(_vector.default);

exports.default = Vector3;

},{"./lib/common":416,"./lib/vector":419,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"gl-matrix/vec3":410}],427:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _vector = _interopRequireDefault(require("./lib/vector"));

var _common = require("./lib/common");

var Vector4 = function (_Vector) {
  (0, _inherits2.default)(Vector4, _Vector);

  function Vector4() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    (0, _classCallCheck2.default)(this, Vector4);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector4).call(this, 4));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }

    return _this;
  }

  (0, _createClass2.default)(Vector4, [{
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      m.transformVector(this, this);
      return this;
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = (0, _common.checkNumber)(value);
    }
  }]);
  return Vector4;
}(_vector.default);

exports.default = Vector4;

},{"./lib/common":416,"./lib/vector":419,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/possibleConstructorReturn":35}],428:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GESTURE_EVENT_ALIASES = exports.EVENT_RECOGNIZER_MAP = exports.INPUT_EVENT_TYPES = exports.BASIC_EVENT_ALIASES = exports.RECOGNIZER_FALLBACK_MAP = exports.RECOGNIZER_COMPATIBLE_MAP = exports.RECOGNIZERS = void 0;

var _hammer = _interopRequireDefault(require("./utils/hammer"));

var RECOGNIZERS = _hammer["default"] ? [[_hammer["default"].Rotate, {
  enable: false
}], [_hammer["default"].Pinch, {
  enable: false
}], [_hammer["default"].Swipe, {
  enable: false
}], [_hammer["default"].Pan, {
  threshold: 0,
  enable: false
}], [_hammer["default"].Press, {
  enable: false
}], [_hammer["default"].Tap, {
  event: 'doubletap',
  taps: 2,
  enable: false
}], [_hammer["default"].Tap, {
  event: 'anytap',
  enable: false
}], [_hammer["default"].Tap, {
  enable: false
}]] : null;
exports.RECOGNIZERS = RECOGNIZERS;
var RECOGNIZER_COMPATIBLE_MAP = {
  rotate: ['pinch'],
  pan: ['press', 'doubletap', 'anytap', 'tap'],
  doubletap: ['anytap'],
  anytap: ['tap']
};
exports.RECOGNIZER_COMPATIBLE_MAP = RECOGNIZER_COMPATIBLE_MAP;
var RECOGNIZER_FALLBACK_MAP = {
  doubletap: ['tap']
};
exports.RECOGNIZER_FALLBACK_MAP = RECOGNIZER_FALLBACK_MAP;
var BASIC_EVENT_ALIASES = {
  pointerdown: 'pointerdown',
  pointermove: 'pointermove',
  pointerup: 'pointerup',
  touchstart: 'pointerdown',
  touchmove: 'pointermove',
  touchend: 'pointerup',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup'
};
exports.BASIC_EVENT_ALIASES = BASIC_EVENT_ALIASES;
var INPUT_EVENT_TYPES = {
  KEY_EVENTS: ['keydown', 'keyup'],
  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],
  WHEEL_EVENTS: ['wheel', 'mousewheel', 'DOMMouseScroll']
};
exports.INPUT_EVENT_TYPES = INPUT_EVENT_TYPES;
var EVENT_RECOGNIZER_MAP = {
  tap: 'tap',
  anytap: 'anytap',
  doubletap: 'doubletap',
  press: 'press',
  pinch: 'pinch',
  pinchin: 'pinch',
  pinchout: 'pinch',
  pinchstart: 'pinch',
  pinchmove: 'pinch',
  pinchend: 'pinch',
  pinchcancel: 'pinch',
  rotate: 'rotate',
  rotatestart: 'rotate',
  rotatemove: 'rotate',
  rotateend: 'rotate',
  rotatecancel: 'rotate',
  pan: 'pan',
  panstart: 'pan',
  panmove: 'pan',
  panup: 'pan',
  pandown: 'pan',
  panleft: 'pan',
  panright: 'pan',
  panend: 'pan',
  pancancel: 'pan',
  swipe: 'swipe',
  swipeleft: 'swipe',
  swiperight: 'swipe',
  swipeup: 'swipe',
  swipedown: 'swipe'
};
exports.EVENT_RECOGNIZER_MAP = EVENT_RECOGNIZER_MAP;
var GESTURE_EVENT_ALIASES = {
  click: 'tap',
  anyclick: 'anytap',
  dblclick: 'doubletap',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup',
  mouseover: 'pointerover',
  mouseout: 'pointerout',
  mouseleave: 'pointerleave'
};
exports.GESTURE_EVENT_ALIASES = GESTURE_EVENT_ALIASES;

},{"./utils/hammer":439,"@babel/runtime/helpers/interopRequireDefault":25}],429:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _hammer = require("./utils/hammer");

var _wheelInput = _interopRequireDefault(require("./inputs/wheel-input"));

var _moveInput = _interopRequireDefault(require("./inputs/move-input"));

var _keyInput = _interopRequireDefault(require("./inputs/key-input"));

var _contextmenuInput = _interopRequireDefault(require("./inputs/contextmenu-input"));

var _eventRegistrar = _interopRequireDefault(require("./utils/event-registrar"));

var _constants = require("./constants");

var DEFAULT_OPTIONS = {
  events: null,
  recognizers: null,
  recognizerOptions: {},
  Manager: _hammer.Manager,
  touchAction: 'none'
};

var EventManager = function () {
  function EventManager() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, EventManager);
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    this.events = new Map();
    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.setElement(element);
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  (0, _createClass2["default"])(EventManager, [{
    key: "setElement",
    value: function setElement(element) {
      var _this = this;

      if (this.element) {
        this.destroy();
      }

      this.element = element;

      if (!element) {
        return;
      }

      var options = this.options;
      var ManagerClass = options.Manager;
      this.manager = new ManagerClass(element, {
        touchAction: options.touchAction,
        recognizers: options.recognizers || _constants.RECOGNIZERS
      }).on('hammer.input', this._onBasicInput);

      if (!options.recognizers) {
        Object.keys(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {
          var recognizer = _this.manager.get(name);

          if (recognizer) {
            _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }

      for (var recognizerName in options.recognizerOptions) {
        var recognizer = this.manager.get(recognizerName);

        if (recognizer) {
          var recognizerOption = options.recognizerOptions[recognizerName];
          delete recognizerOption.enable;
          recognizer.set(recognizerOption);
        }
      }

      this.wheelInput = new _wheelInput["default"](element, this._onOtherEvent, {
        enable: false
      });
      this.moveInput = new _moveInput["default"](element, this._onOtherEvent, {
        enable: false
      });
      this.keyInput = new _keyInput["default"](element, this._onOtherEvent, {
        enable: false
      });
      this.contextmenuInput = new _contextmenuInput["default"](element, this._onOtherEvent, {
        enable: false
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
              eventAlias = _step$value[0],
              eventRegistrar = _step$value[1];

          if (!eventRegistrar.isEmpty()) {
            this._toggleRecognizer(eventRegistrar.recognizerName, true);

            this.manager.on(eventAlias, eventRegistrar.handleEvent);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.element) {
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.contextmenuInput.destroy();
        this.manager.destroy();
        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.contextmenuInput = null;
        this.manager = null;
        this.element = null;
      }
    }
  }, {
    key: "on",
    value: function on(event, handler, srcElement) {
      this._addEventHandler(event, handler, srcElement, false);
    }
  }, {
    key: "once",
    value: function once(event, handler, srcElement) {
      this._addEventHandler(event, handler, srcElement, true);
    }
  }, {
    key: "off",
    value: function off(event, handler) {
      this._removeEventHandler(event, handler);
    }
  }, {
    key: "_toggleRecognizer",
    value: function _toggleRecognizer(name, enabled) {
      var manager = this.manager;

      if (!manager) {
        return;
      }

      var recognizer = manager.get(name);

      if (recognizer && recognizer.options.enable !== enabled) {
        recognizer.set({
          enable: enabled
        });
        var fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];

        if (fallbackRecognizers && !this.options.recognizers) {
          fallbackRecognizers.forEach(function (otherName) {
            var otherRecognizer = manager.get(otherName);

            if (enabled) {
              otherRecognizer.requireFailure(name);
              recognizer.dropRequireFailure(otherName);
            } else {
              otherRecognizer.dropRequireFailure(name);
            }
          });
        }
      }

      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
      this.contextmenuInput.enableEventType(name, enabled);
    }
  }, {
    key: "_addEventHandler",
    value: function _addEventHandler(event, handler, srcElement, once) {
      if (typeof event !== 'string') {
        srcElement = handler;

        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName], srcElement, once);
        }

        return;
      }

      var manager = this.manager,
          events = this.events;
      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
      var eventRegistrar = events.get(eventAlias);

      if (!eventRegistrar) {
        eventRegistrar = new _eventRegistrar["default"](this);
        events.set(eventAlias, eventRegistrar);
        eventRegistrar.recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;

        if (manager) {
          manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }

      this._toggleRecognizer(eventRegistrar.recognizerName, true);

      eventRegistrar.add(event, handler, srcElement, once);
    }
  }, {
    key: "_removeEventHandler",
    value: function _removeEventHandler(event, handler) {
      if (typeof event !== 'string') {
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }

        return;
      }

      var events = this.events;
      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
      var eventRegistrar = events.get(eventAlias);

      if (!eventRegistrar) {
        return;
      }

      eventRegistrar.remove(event, handler);

      if (eventRegistrar.isEmpty()) {
        var recognizerName = eventRegistrar.recognizerName;
        var isRecognizerUsed = false;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = events.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var eh = _step2.value;

            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
              isRecognizerUsed = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }
  }, {
    key: "_onBasicInput",
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;
      var alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];

      if (alias) {
        this.manager.emit(alias, event);
      }
    }
  }, {
    key: "_onOtherEvent",
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);
  return EventManager;
}();

exports["default"] = EventManager;

},{"./constants":428,"./inputs/contextmenu-input":431,"./inputs/key-input":432,"./inputs/move-input":433,"./inputs/wheel-input":434,"./utils/event-registrar":435,"./utils/hammer":439,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],430:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "EventManager", {
  enumerable: true,
  get: function get() {
    return _eventManager["default"];
  }
});

var _eventManager = _interopRequireDefault(require("./event-manager"));

},{"./event-manager":429,"@babel/runtime/helpers/interopRequireDefault":25}],431:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var EVENT_TYPE = 'contextmenu';

var ContextmenuInput = function () {
  function ContextmenuInput(element, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, ContextmenuInput);
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.handleEvent = this.handleEvent.bind(this);
    element.addEventListener('contextmenu', this.handleEvent);
  }

  (0, _createClass2["default"])(ContextmenuInput, [{
    key: "destroy",
    value: function destroy() {
      this.element.removeEventListener('contextmenu', this.handleEvent);
    }
  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }

      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: 'mouse',
        target: event.target
      });
    }
  }]);
  return ContextmenuInput;
}();

exports["default"] = ContextmenuInput;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],432:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _constants = require("../constants");

var KEY_EVENTS = _constants.INPUT_EVENT_TYPES.KEY_EVENTS;
var DOWN_EVENT_TYPE = 'keydown';
var UP_EVENT_TYPE = 'keyup';

var KeyInput = function () {
  function KeyInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, KeyInput);
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = KEY_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    element.tabIndex = 1;
    element.style.outline = 'none';
    this.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  (0, _createClass2["default"])(KeyInput, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === DOWN_EVENT_TYPE) {
        this.enableDownEvent = enabled;
      }

      if (eventType === UP_EVENT_TYPE) {
        this.enableUpEvent = enabled;
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      var targetElement = event.target || event.srcElement;

      if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {
        return;
      }

      if (this.enableDownEvent && event.type === 'keydown') {
        this.callback({
          type: DOWN_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }

      if (this.enableUpEvent && event.type === 'keyup') {
        this.callback({
          type: UP_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    }
  }]);
  return KeyInput;
}();

exports["default"] = KeyInput;

},{"../constants":428,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],433:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _constants = require("../constants");

var MOUSE_EVENTS = _constants.INPUT_EVENT_TYPES.MOUSE_EVENTS;
var MOVE_EVENT_TYPE = 'pointermove';
var OVER_EVENT_TYPE = 'pointerover';
var OUT_EVENT_TYPE = 'pointerout';
var LEAVE_EVENT_TYPE = 'pointerleave';

var MoveInput = function () {
  function MoveInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, MoveInput);
    this.element = element;
    this.callback = callback;
    this.pressed = false;
    this.options = Object.assign({
      enable: true
    }, options);
    this.enableMoveEvent = this.options.enable;
    this.enableLeaveEvent = this.options.enable;
    this.enableOutEvent = this.options.enable;
    this.enableOverEvent = this.options.enable;
    this.events = MOUSE_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    this.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  (0, _createClass2["default"])(MoveInput, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === MOVE_EVENT_TYPE) {
        this.enableMoveEvent = enabled;
      }

      if (eventType === OVER_EVENT_TYPE) {
        this.enableOverEvent = enabled;
      }

      if (eventType === OUT_EVENT_TYPE) {
        this.enableOutEvent = enabled;
      }

      if (eventType === LEAVE_EVENT_TYPE) {
        this.enableLeaveEvent = enabled;
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    }
  }, {
    key: "handleOverEvent",
    value: function handleOverEvent(event) {
      if (this.enableOverEvent) {
        if (event.type === 'mouseover') {
          this.callback({
            type: OVER_EVENT_TYPE,
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
          });
        }
      }
    }
  }, {
    key: "handleOutEvent",
    value: function handleOutEvent(event) {
      if (this.enableOutEvent) {
        if (event.type === 'mouseout') {
          this.callback({
            type: OUT_EVENT_TYPE,
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
          });
        }
      }
    }
  }, {
    key: "handleLeaveEvent",
    value: function handleLeaveEvent(event) {
      if (this.enableLeaveEvent) {
        if (event.type === 'mouseleave') {
          this.callback({
            type: LEAVE_EVENT_TYPE,
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
          });
        }
      }
    }
  }, {
    key: "handleMoveEvent",
    value: function handleMoveEvent(event) {
      if (this.enableMoveEvent) {
        switch (event.type) {
          case 'mousedown':
            if (event.button >= 0) {
              this.pressed = true;
            }

            break;

          case 'mousemove':
            if (event.which === 0) {
              this.pressed = false;
            }

            if (!this.pressed) {
              this.callback({
                type: MOVE_EVENT_TYPE,
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
              });
            }

            break;

          case 'mouseup':
            this.pressed = false;
            break;

          default:
        }
      }
    }
  }]);
  return MoveInput;
}();

exports["default"] = MoveInput;

},{"../constants":428,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],434:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _constants = require("../constants");

var _globals = require("../utils/globals");

var firefox = _globals.userAgent.indexOf('firefox') !== -1;
var WHEEL_EVENTS = _constants.INPUT_EVENT_TYPES.WHEEL_EVENTS;
var EVENT_TYPE = 'wheel';
var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40;
var SHIFT_MULTIPLIER = 0.25;

var WheelInput = function () {
  function WheelInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, WheelInput);
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.events = WHEEL_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    this.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent, _globals.passiveSupported ? {
        passive: false
      } : false);
    });
  }

  (0, _createClass2["default"])(WheelInput, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }

      var value = event.deltaY;

      if (_globals.window.WheelEvent) {
        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
          value /= _globals.window.devicePixelRatio;
        }

        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }

      var wheelPosition = {
        x: event.clientX,
        y: event.clientY
      };

      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }

      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }

      this._onWheel(event, -value, wheelPosition);
    }
  }, {
    key: "_onWheel",
    value: function _onWheel(srcEvent, delta, position) {
      this.callback({
        type: EVENT_TYPE,
        center: position,
        delta: delta,
        srcEvent: srcEvent,
        pointerType: 'mouse',
        target: srcEvent.target
      });
    }
  }]);
  return WheelInput;
}();

exports["default"] = WheelInput;

},{"../constants":428,"../utils/globals":437,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],435:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _eventUtils = require("./event-utils");

var EventRegistrar = function () {
  function EventRegistrar(eventManager) {
    (0, _classCallCheck2["default"])(this, EventRegistrar);
    this.eventManager = eventManager;
    this.handlers = [];
    this.handlersByElement = new Map();
    this.handleEvent = this.handleEvent.bind(this);
  }

  (0, _createClass2["default"])(EventRegistrar, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.handlers.length === 0;
    }
  }, {
    key: "add",
    value: function add(type, handler) {
      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'root';
      var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var handlers = this.handlers,
          handlersByElement = this.handlersByElement;

      if (!handlersByElement.has(srcElement)) {
        handlersByElement.set(srcElement, []);
      }

      var entry = {
        type: type,
        handler: handler,
        srcElement: srcElement,
        once: once
      };
      handlers.push(entry);
      handlersByElement.get(srcElement).push(entry);
    }
  }, {
    key: "remove",
    value: function remove(type, handler) {
      var handlers = this.handlers,
          handlersByElement = this.handlersByElement;

      for (var i = handlers.length - 1; i >= 0; i--) {
        var entry = handlers[i];

        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i, 1);
          var entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);

          if (entries.length === 0) {
            handlersByElement["delete"](entry.srcElement);
          }
        }
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (this.isEmpty()) {
        return;
      }

      var mjolnirEvent = this._normalizeEvent(event);

      var target = event.srcEvent.target;

      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);

        if (mjolnirEvent.handled) {
          return;
        }

        target = target.parentNode;
      }

      this._emit(mjolnirEvent, 'root');
    }
  }, {
    key: "_emit",
    value: function _emit(event, srcElement) {
      var entries = this.handlersByElement.get(srcElement);

      if (entries) {
        var immediatePropagationStopped = false;

        var stopPropagation = function stopPropagation() {
          event.handled = true;
        };

        var stopImmediatePropagation = function stopImmediatePropagation() {
          event.handled = true;
          immediatePropagationStopped = true;
        };

        var entriesToRemove = [];

        for (var i = 0; i < entries.length; i++) {
          var _entries$i = entries[i],
              type = _entries$i.type,
              handler = _entries$i.handler,
              once = _entries$i.once;
          handler(Object.assign({}, event, {
            type: type,
            stopPropagation: stopPropagation,
            stopImmediatePropagation: stopImmediatePropagation
          }));

          if (once) {
            entriesToRemove.push(entries[i]);
          }

          if (immediatePropagationStopped) {
            break;
          }
        }

        for (var _i = 0; _i < entriesToRemove.length; _i++) {
          var _entriesToRemove$_i = entriesToRemove[_i],
              type = _entriesToRemove$_i.type,
              handler = _entriesToRemove$_i.handler;
          this.remove(type, handler);
        }
      }
    }
  }, {
    key: "_normalizeEvent",
    value: function _normalizeEvent(event) {
      var rootElement = this.eventManager.element;
      return Object.assign({}, event, (0, _eventUtils.whichButtons)(event), (0, _eventUtils.getOffsetPosition)(event, rootElement), {
        handled: false,
        rootElement: rootElement
      });
    }
  }]);
  return EventRegistrar;
}();

exports["default"] = EventRegistrar;

},{"./event-utils":436,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],436:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whichButtons = whichButtons;
exports.getOffsetPosition = getOffsetPosition;
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
var MOUSE_EVENT_WHICH_LEFT = 1;
var MOUSE_EVENT_WHICH_MIDDLE = 2;
var MOUSE_EVENT_WHICH_RIGHT = 3;
var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2;
var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;

function whichButtons(event) {
  var eventType = MOUSE_EVENTS[event.srcEvent.type];

  if (!eventType) {
    return null;
  }

  var _event$srcEvent = event.srcEvent,
      buttons = _event$srcEvent.buttons,
      button = _event$srcEvent.button,
      which = _event$srcEvent.which;
  var leftButton = false;
  var middleButton = false;
  var rightButton = false;

  if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }

  return {
    leftButton: leftButton,
    middleButton: middleButton,
    rightButton: rightButton
  };
}

function getOffsetPosition(event, rootElement) {
  var srcEvent = event.srcEvent;

  if (!event.center && !Number.isFinite(srcEvent.clientX)) {
    return null;
  }

  var center = event.center || {
    x: srcEvent.clientX,
    y: srcEvent.clientY
  };
  var rect = rootElement.getBoundingClientRect();
  var scaleX = rect.width / rootElement.offsetWidth;
  var scaleY = rect.height / rootElement.offsetHeight;
  var offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY
  };
  return {
    center: center,
    offsetCenter: offsetCenter
  };
}

},{}],437:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.passiveSupported = exports.document = exports.global = exports.window = exports.userAgent = void 0;
var userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
exports.userAgent = userAgent;
var window_ = typeof window !== 'undefined' ? window : global;
exports.window = window_;
var global_ = typeof global !== 'undefined' ? global : window;
exports.global = global_;
var document_ = typeof document !== 'undefined' ? document : {};
exports.document = document_;
var passiveSupported = false;
exports.passiveSupported = passiveSupported;

try {
  var options = {
    get passive() {
      exports.passiveSupported = passiveSupported = true;
      return true;
    }

  };
  window_.addEventListener('test', options, options);
  window_.removeEventListener('test', options, options);
} catch (err) {}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],438:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enhancePointerEventInput = enhancePointerEventInput;
exports.enhanceMouseInput = enhanceMouseInput;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};

function some(array, predict) {
  for (var i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }

  return false;
}

function enhancePointerEventInput(PointerEventInput) {
  var oldHandler = PointerEventInput.prototype.handler;

  PointerEventInput.prototype.handler = function handler(ev) {
    var store = this.store;

    if (ev.button > 0) {
      if (!some(store, function (e) {
        return e.pointerId === ev.pointerId;
      })) {
        store.push(ev);
      }
    }

    oldHandler.call(this, ev);
  };
}

function enhanceMouseInput(MouseInput) {
  MouseInput.prototype.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type];

    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }

    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }

    if (!this.pressed) {
      return;
    }

    if (eventType & INPUT_END) {
      this.pressed = false;
    }

    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: 'mouse',
      srcEvent: ev
    });
  };
}

},{}],439:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Manager = void 0;

var _hammerjs = _interopRequireDefault(require("hammerjs"));

var _hammerOverrides = require("./hammer-overrides");

(0, _hammerOverrides.enhancePointerEventInput)(_hammerjs["default"].PointerEventInput);
(0, _hammerOverrides.enhanceMouseInput)(_hammerjs["default"].MouseInput);
var Manager = _hammerjs["default"].Manager;
exports.Manager = Manager;
var _default = _hammerjs["default"];
exports["default"] = _default;

},{"./hammer-overrides":438,"@babel/runtime/helpers/interopRequireDefault":25,"hammerjs":412}],440:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobile = isMobile;
exports["default"] = getBrowser;

var _globals = require("./globals");

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isMobile() {
  return typeof _globals.window.orientation !== 'undefined';
}

function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser["default"])()) {
    return 'Node';
  }

  if ((0, _isElectron["default"])(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals.window.chrome) {
    return 'Chrome';
  }

  if (_globals.window.safari) {
    return 'Safari';
  }

  if (_globals.window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}

},{"./globals":441,"./is-browser":442,"./is-electron":443,"@babel/runtime/helpers/interopRequireDefault":25}],441:[function(require,module,exports){
(function (process,global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.console = exports.process = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var process_ = globals.process || {};
exports.process = process_;
var console_ = console;
exports.console = console_;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],442:[function(require,module,exports){
(function (process){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || (0, _isElectron["default"])();
}

function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}

}).call(this,require('_process'))
},{"./is-electron":443,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],443:[function(require,module,exports){
(function (process){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isElectron;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && (0, _typeof2["default"])(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2["default"])(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : (0, _typeof2["default"])(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}

}).call(this,require('_process'))
},{"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/typeof":40,"_process":6}],444:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function get() {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals2.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _isBrowser["default"];
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function get() {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function get() {
    return _getBrowser["default"];
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function get() {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function get() {
    return _isElectron["default"];
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert["default"];
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function get() {
    return _stats["default"];
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return _log["default"];
  }
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function get() {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function get() {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function get() {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function get() {
    return _formatters.rightPad;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function get() {
    return _autobind.autobind;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function get() {
    return _localStorage["default"];
  }
});
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function get() {
    return _hiResTimestamp["default"];
  }
});
exports["default"] = void 0;

require("./init");

var _globals = require("./utils/globals");

var _globals2 = require("./env/globals");

var _isBrowser = _interopRequireWildcard(require("./env/is-browser"));

var _getBrowser = _interopRequireWildcard(require("./env/get-browser"));

var _isElectron = _interopRequireDefault(require("./env/is-electron"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _stats = _interopRequireDefault(require("./lib/stats"));

var _log = _interopRequireDefault(require("./lib/log"));

var _color = require("./utils/color");

var _formatters = require("./utils/formatters");

var _autobind = require("./utils/autobind");

var _localStorage = _interopRequireDefault(require("./utils/local-storage"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

var _default = new _log["default"]({
  id: 'probe.gl'
});

exports["default"] = _default;

},{"./env/get-browser":440,"./env/globals":441,"./env/is-browser":442,"./env/is-electron":443,"./init":445,"./lib/log":446,"./lib/stats":448,"./utils/assert":449,"./utils/autobind":450,"./utils/color":451,"./utils/formatters":452,"./utils/globals":453,"./utils/hi-res-timestamp":454,"./utils/local-storage":455,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26}],445:[function(require,module,exports){
"use strict";

var _globals = require("./utils/globals");

_globals.global.probe = {};

},{"./utils/globals":453}],446:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _globals = require("../utils/globals");

var _localStorage = _interopRequireDefault(require("../utils/local-storage"));

var _formatters = require("../utils/formatters");

var _color = require("../utils/color");

var _autobind = require("../utils/autobind");

var _assert2 = _interopRequireDefault(require("../utils/assert"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var originalConsole = {
  debug: _globals.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: false,
  priority: 0
};

function noop() {}

var cache = {};

function getTableHeader(table) {
  for (var key in table) {
    for (var title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

var Log = function () {
  function Log() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id;

    (0, _classCallCheck2["default"])(this, Log);
    this.id = id;
    this.VERSION = _globals.VERSION;
    this._startTs = (0, _hiResTimestamp["default"])();
    this._deltaTs = (0, _hiResTimestamp["default"])();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _localStorage["default"]("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }

  (0, _createClass2["default"])(Log, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this._storage.config.enabled;
    }
  }, {
    key: "getPriority",
    value: function getPriority() {
      return this._storage.config.priority;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._storage.config.priority;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      return Number(((0, _hiResTimestamp["default"])() - this._startTs).toPrecision(10));
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      return Number(((0, _hiResTimestamp["default"])() - this._deltaTs).toPrecision(10));
    }
  }, {
    key: "enable",
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._storage.updateConfiguration({
        enabled: enabled
      });

      return this;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      this._storage.updateConfiguration({
        priority: level
      });

      return this;
    }
  }, {
    key: "assert",
    value: function assert(condition, message) {
      (0, _assert2["default"])(condition, message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.warn,
        once: true
      });
    }
  }, {
    key: "error",
    value: function error(message) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.error
      });
    }
  }, {
    key: "deprecated",
    value: function deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "removed",
    value: function removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "probe",
    value: function probe(priority, message) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.log,
        time: true,
        once: true
      });
    }
  }, {
    key: "log",
    value: function log(priority, message) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug
      });
    }
  }, {
    key: "info",
    value: function info(priority, message) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
        args[_key5 - 2] = arguments[_key5];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: console.info
      });
    }
  }, {
    key: "once",
    value: function once(priority, message) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
        args[_key6 - 2] = arguments[_key6];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug || originalConsole.info,
        once: true
      });
    }
  }, {
    key: "table",
    value: function table(priority, _table, columns) {
      if (_table) {
        var tag = getTableHeader(_table);
        return this._getLogFunction({
          priority: priority,
          message: _table,
          args: columns && [columns],
          tag: tag,
          method: console.table || noop
        });
      }

      return noop;
    }
  }, {
    key: "image",
    value: function image(_ref2) {
      var priority = _ref2.priority,
          _image = _ref2.image,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? '' : _ref2$message,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

      if (priority > this.getPriority()) {
        return noop;
      }

      return _globals.isBrowser ? this._logImageInBrowser({
        image: _image,
        message: message,
        scale: scale
      }) : this._logImageInNode({
        image: _image,
        message: message,
        scale: scale
      });
    }
  }, {
    key: "settings",
    value: function settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
  }, {
    key: "get",
    value: function get(setting) {
      return this._storage.config[setting];
    }
  }, {
    key: "set",
    value: function set(setting, value) {
      this._storage.updateConfiguration((0, _defineProperty2["default"])({}, setting, value));
    }
  }, {
    key: "_logImageInNode",
    value: function _logImageInNode(_ref3) {
      var image = _ref3.image,
          _ref3$message = _ref3.message,
          message = _ref3$message === void 0 ? '' : _ref3$message,
          _ref3$scale = _ref3.scale,
          scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
      var asciify = null;

      try {
        asciify = module.require('asciify-image');
      } catch (error) {}

      if (asciify) {
        return function () {
          return asciify(image, {
            fit: 'box',
            width: "".concat(Math.round(80 * scale), "%")
          }).then(function (data) {
            return console.log(data);
          });
        };
      }

      return noop;
    }
  }, {
    key: "_logImageInBrowser",
    value: function _logImageInBrowser(_ref4) {
      var image = _ref4.image,
          _ref4$message = _ref4.message,
          message = _ref4$message === void 0 ? '' : _ref4$message,
          _ref4$scale = _ref4.scale,
          scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

      if (typeof image === 'string') {
        var img = new Image();

        img.onload = function () {
          var _console;

          var args = (0, _formatters.formatImage)(img, message, scale);

          (_console = console).log.apply(_console, (0, _toConsumableArray2["default"])(args));
        };

        img.src = image;
        return noop;
      }

      var element = image.nodeName || '';

      if (element.toLowerCase() === 'img') {
        var _console2;

        (_console2 = console).log.apply(_console2, (0, _toConsumableArray2["default"])((0, _formatters.formatImage)(image, message, scale)));

        return noop;
      }

      if (element.toLowerCase() === 'canvas') {
        var _img = new Image();

        _img.onload = function () {
          var _console3;

          return (_console3 = console).log.apply(_console3, (0, _toConsumableArray2["default"])((0, _formatters.formatImage)(_img, message, scale)));
        };

        _img.src = image.toDataURL();
        return noop;
      }

      return noop;
    }
  }, {
    key: "time",
    value: function time(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.time ? console.time : console.info
      });
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeEnd ? console.timeEnd : console.info
      });
    }
  }, {
    key: "timeStamp",
    value: function timeStamp(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeStamp || noop
      });
    }
  }, {
    key: "group",
    value: function group(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        collapsed: false
      };
      opts = this._normalizeArguments({
        priority: priority,
        message: message,
        opts: opts
      });
      var _opts = opts,
          collapsed = _opts.collapsed;
      return this._getLogFunction({
        priority: priority,
        message: message,
        opts: opts,
        method: (collapsed ? console.groupCollapsed : console.group) || console.info
      });
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.group(priority, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd(priority) {
      return this._getLogFunction({
        priority: priority,
        message: '',
        method: console.groupEnd || noop
      });
    }
  }, {
    key: "withGroup",
    value: function withGroup(priority, message, func) {
      var opts = this._normalizeArguments({
        priority: priority,
        message: message
      });

      this.group(opts);

      try {
        func();
      } finally {
        this.groupEnd(opts.message);
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      if (console.trace) {
        console.trace();
      }
    }
  }, {
    key: "_shouldLog",
    value: function _shouldLog(priority) {
      priority = this._normalizePriority(priority);
      return priority === 0 || this.isEnabled() && this.getPriority() >= priority;
    }
  }, {
    key: "_getElapsedTime",
    value: function _getElapsedTime() {
      var total = this.getTotal();
      var delta = this.getDelta();
      this._deltaTs = (0, _hiResTimestamp["default"])();
      return {
        total: total,
        delta: delta
      };
    }
  }, {
    key: "_getLogFunction",
    value: function _getLogFunction(opts) {
      if (this._shouldLog(opts.priority)) {
        var _opts2 = opts,
            method = _opts2.method;
        opts = this._parseArguments(opts);
        (0, _assert2["default"])(method);
        var _opts3 = opts,
            message = _opts3.message;
        var tag = opts.tag || opts.message;

        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = (0, _hiResTimestamp["default"])();
          } else {
            return noop;
          }
        }

        message = this._decorateMessage(message, opts);
        return method.bind.apply(method, [console, message].concat((0, _toConsumableArray2["default"])(opts.args)));
      }

      return noop;
    }
  }, {
    key: "_parseArguments",
    value: function _parseArguments(options) {
      var normOpts = this._normalizeArguments(options);

      var _this$_getElapsedTime = this._getElapsedTime(),
          delta = _this$_getElapsedTime.delta,
          total = _this$_getElapsedTime.total;

      return Object.assign(options, normOpts, {
        delta: delta,
        total: total
      });
    }
  }, {
    key: "_normalizePriority",
    value: function _normalizePriority(priority) {
      var resolvedPriority;

      switch ((0, _typeof2["default"])(priority)) {
        case 'number':
          resolvedPriority = priority;
          break;

        case 'object':
          resolvedPriority = priority.priority || 0;
          break;

        default:
          resolvedPriority = 0;
      }

      (0, _assert2["default"])(Number.isFinite(resolvedPriority) && resolvedPriority >= 0);
      return resolvedPriority;
    }
  }, {
    key: "_normalizeArguments",
    value: function _normalizeArguments(_ref5) {
      var priority = _ref5.priority,
          message = _ref5.message,
          _ref5$args = _ref5.args,
          args = _ref5$args === void 0 ? [] : _ref5$args,
          opts = _ref5.opts;
      var newOpts = {
        priority: this._normalizePriority(priority),
        message: message,
        args: args
      };

      switch ((0, _typeof2["default"])(priority)) {
        case 'string':
        case 'function':
          if (message !== undefined) {
            args.unshift(message);
          }

          Object.assign(newOpts, {
            message: priority
          });
          break;

        case 'object':
          Object.assign(newOpts, priority);
          break;

        default:
      }

      if (typeof newOpts.message === 'function') {
        newOpts.message = this._shouldLog(newOpts.priority) ? newOpts.message() : '';
      }

      (0, _assert2["default"])(typeof newOpts.message === 'string' || (0, _typeof2["default"])(newOpts.message) === 'object');
      return Object.assign(newOpts, opts);
    }
  }, {
    key: "_decorateMessage",
    value: function _decorateMessage(message, opts) {
      if (typeof message === 'string') {
        var time = '';

        if (opts.time) {
          var _this$_getElapsedTime2 = this._getElapsedTime(),
              total = _this$_getElapsedTime2.total;

          time = (0, _formatters.leftPad)((0, _formatters.formatTime)(total));
        }

        message = opts.time ? "".concat(this.id, ": ").concat(time, "  ").concat(message) : "".concat(this.id, ": ").concat(message);
        message = (0, _color.addColor)(message, opts.color, opts.background);
      }

      return message;
    }
  }, {
    key: "priority",
    set: function set(newPriority) {
      this._storage.updateConfiguration({
        priority: newPriority
      });

      return this;
    },
    get: function get() {
      return this._storage.config.priority;
    }
  }]);
  return Log;
}();

exports["default"] = Log;
Log.VERSION = _globals.VERSION;

},{"../utils/assert":449,"../utils/autobind":450,"../utils/color":451,"../utils/formatters":452,"../utils/globals":453,"../utils/hi-res-timestamp":454,"../utils/local-storage":455,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/defineProperty":21,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/toConsumableArray":39,"@babel/runtime/helpers/typeof":40}],447:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var Stat = function () {
  function Stat(name) {
    (0, _classCallCheck2["default"])(this, Stat);
    this.name = name;
    this.reset();
  }

  (0, _createClass2["default"])(Stat, [{
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this.count += value;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this.count -= value;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this.time += time;
      this.lastTiming = time;
      this.count++;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = (0, _hiResTimestamp["default"])();
      this._timerPending = true;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return;
      }

      this.addTime((0, _hiResTimestamp["default"])() - this._startTime);
      this._timerPending = false;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.count > 0 ? this.time / this.count : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.count / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.lastTiming = 0;
      this._startTime = 0;
      this._timerPending = false;
    }
  }]);
  return Stat;
}();

exports["default"] = Stat;

},{"../utils/hi-res-timestamp":454,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],448:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _stat = _interopRequireDefault(require("./stat"));

var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id;
    (0, _classCallCheck2["default"])(this, Stats);
    this.id = id;
    this.stats = {};
    Object.seal(this);
  }

  (0, _createClass2["default"])(Stats, [{
    key: "get",
    value: function get(name) {
      this.stats[name] = this.stats[name] || new _stat["default"](name);
      return this.stats[name];
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }]);
  return Stats;
}();

exports["default"] = Stats;

},{"./stat":447,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],449:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

},{}],450:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;

function autobind(obj) {
  var predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!predefined.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (var _iterator = propNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

},{}],451:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addColor = addColor;
exports.COLOR = void 0;

var _globals = require("./globals");

var COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};
exports.COLOR = COLOR;

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}

},{"./globals":453}],452:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTime = formatTime;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
exports.formatValue = formatValue;
exports.formatImage = formatImage;

function formatTime(ms) {
  var formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}

function leftPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}

function rightPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  var imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  var width = image.width * scale;
  var height = image.height * scale;
  var style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}

},{}],453:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals.console;
  }
});
exports.isBrowser = exports.VERSION = void 0;

var _isBrowser = _interopRequireDefault(require("../env/is-browser"));

var _globals = require("../env/globals");

var VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
var isBrowser = (0, _isBrowser["default"])();
exports.isBrowser = isBrowser;

},{"../env/globals":441,"../env/is-browser":442,"@babel/runtime/helpers/interopRequireDefault":25}],454:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getHiResTimestamp;

var _globals = require("./globals");

function getHiResTimestamp() {
  var timestamp;

  if (_globals.isBrowser && _globals.window.performance) {
    timestamp = _globals.window.performance.now();
  } else if (_globals.process.hrtime) {
    var timeParts = _globals.process.hrtime();

    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}

},{"./globals":453}],455:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function getStorage(type) {
  try {
    var storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

var LocalStorage = function () {
  function LocalStorage(id, defaultSettings) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _classCallCheck2["default"])(this, LocalStorage);
    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  (0, _createClass2["default"])(LocalStorage, [{
    key: "getConfiguration",
    value: function getConfiguration() {
      return this.config;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(configuration) {
      Object.assign(this.config, configuration);

      if (this.storage) {
        var serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }

      return this;
    }
  }, {
    key: "_loadConfiguration",
    value: function _loadConfiguration() {
      var configuration = {};

      if (this.storage) {
        var serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }

      Object.assign(this.config, configuration);
      return this;
    }
  }]);
  return LocalStorage;
}();

exports["default"] = LocalStorage;

},{"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25}],456:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],457:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var isBrowser = typeof window !== 'undefined' && window.addEventListener;

var timers = new Map();

/**
 * Ready check for Seer initialization
 *
 * @returns {Boolean}
 */
var isReady = function isReady() {
  return isBrowser && window.__SEER_INITIALIZED__;
};

/**
 * Utility method allowing to throttle a user action based on a key and a minimun delay.
 *
 * @param key {String} A unique key
 * @param delay {Number} The minimal delay to throttle
 * @returns {Boolean}
 */
var throttle = function throttle(key, delay) {
  var time = timers.get(key);
  var now = Date.now();
  if (time && now - time < delay) {
    return true;
  }
  timers.set(key, now);
  return false;
};

var replacer = function replacer(seen) {
  return function (key, value) {
    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && seen.has(value)) {
      return;
    }
    seen.add(value);
    var isArray = Object.prototype.toString.call(value).slice(8, -1).includes('Array');
    if (isArray) {
      return Array.prototype.slice.call(value, 0, 20);
    }
    return value;
  };
};

/**
 * Low-level api leveraging window.postMessage
 *
 * @param type {String} The action type
 * @param payload {Any} The action payload
 */
var send = function send(type) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isBrowser || !isReady()) {
    return;
  }

  var seen = new Set();
  var payload = JSON.stringify(data, replacer(seen));

  try {
    window.postMessage({ type: type, payload: payload, source: 'seer-agent' }, '*');
  } catch (e) {
    if (throttle('seer-log', 2E3)) {
      return;
    }
    console.log(e); // eslint-disable-line
  }
};

var listeners = new Map();

var listener = function listener(message) {
  if (!message || !message.data || message.data.source !== 'seer-core') {
    return;
  }
  var _message$data = message.data,
      type = _message$data.type,
      payload = _message$data.payload;


  var typeListeners = listeners.get(type);
  if (typeListeners) {
    typeListeners.forEach(function (cb) {
      return cb(payload);
    });
  }
};

/**
 * Initilize window listener. There will be only one for the whole process
 * to prevent too many registrations.
 *
 * This method will be called automatically if you use the `listenFor` method.
 */
var init = function init() {
  if (!isBrowser || window.__SEER_LISTENER__) {
    return;
  }
  window.addEventListener('message', listener);
  window.__SEER_LISTENER__ = true;
};

/**
 * Clean listener. Can be useful in case you want to unregister upcoming events
 * or liberate memory.
 */
var clean = function clean() {
  if (!isBrowser || !window.__SEER_LISTENER__) {
    return;
  }
  window.removeEventListener('message', listener);
  delete window.__SEER_LISTENER__;
};

/**
 * Create a listener that will be called upon events of the given key.
 *
 * @param key {String} The unique tab key
 * @param cb {Function} A callback that will receive the message payload
 */
var listenFor = function listenFor(type, cb) {
  if (!isBrowser) {
    return;
  }
  if (!type || !cb) {
    throw new Error('Please provide a type and callback');
  }
  if (!listeners.has(type)) {
    listeners.set(type, []);
  }
  if (!window.__SEER_LISTENER__) {
    init();
  }
  listeners.get(type).push(cb);
};

/**
 * Remove an identity listener
 *
 * @param cb {Function} The callback to remove
 */
var removeListener = function removeListener(cb) {
  listeners.forEach(function (typeListeners, key) {
    listeners.set(key, typeListeners.filter(function (l) {
      return l !== cb;
    }));
  });
};

/**
 * Creates a new indexed list.
 * It works by index to get O(1) accessing and performance.
 *
 * @param key {String} The key of the tab
 * @param data {Object} The indexed object
 */
var list = function list(key, data) {
  return send('LIST', { key: key, data: data });
};

/**
 * Creates an element in the indexed list, based on the itemKey.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param data {Any} The value of the item
 */
var listItem = function listItem(key, itemKey) {
  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return send('LIST_ITEM', { key: key, itemKey: itemKey, data: data });
};

/**
 * Update an item property, can be deeply nested.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param path {String} The path of the variable you want to update
 * @param data {Object} The new value
 */
var updateItem = function updateItem(key, itemKey, path, data) {
  return send('UPDATE_ITEM', { key: key, itemKey: itemKey, path: path, data: data });
};

/**
 * Similar to updateItem, but allows to pass an array with {path,data} pairs for
 * multiple update of the same item without having to send multiple messages.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param array {Array} The array of updates
 * @param array.path {String} The path for this update
 * @param array.data {Object} The value of this update
 */
var multiUpdate = function multiUpdate(key, itemKey, array) {
  return send('MULTI_UPDATE_ITEM', { key: key, itemKey: itemKey, array: array });
};

/**
 * Remove a specific item in a specific tab.
 *
 * @param key {String} They key of the tab
 * @param itemKey {String} The key of the item
 */
var deleteItem = function deleteItem(key, itemKey) {
  return send('DELETE_ITEM', { key: key, itemKey: itemKey });
};

/**
 * Will create a log message to an item, that will be displayde with the current time.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param msg {String} The message to display
 */
var addLog = function addLog(key, itemKey, msg) {
  return send('ADD_LOG', { key: key, itemKey: itemKey, msg: msg });
};

exports.default = {

  send: send,
  throttle: throttle,
  isReady: isReady,

  list: list,
  listItem: listItem,
  updateItem: updateItem,
  multiUpdate: multiUpdate,
  deleteItem: deleteItem,
  addLog: addLog,

  listeners: listeners,
  listenFor: listenFor,
  removeListener: removeListener,
  init: init,
  clean: clean

};

},{}],458:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'viewport-mercator-project: assertion failed.');
  }
}

},{}],459:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fitBounds;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));

var _assert = _interopRequireDefault(require("./assert"));

function fitBounds(_ref) {
  var width = _ref.width,
      height = _ref.height,
      bounds = _ref.bounds,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? 0 : _ref$padding,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;

  var _bounds = (0, _slicedToArray2.default)(bounds, 2),
      _bounds$ = (0, _slicedToArray2.default)(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = (0, _slicedToArray2.default)(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  if (Number.isFinite(padding)) {
    var p = padding;
    padding = {
      top: p,
      bottom: p,
      left: p,
      right: p
    };
  } else {
    (0, _assert.default)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  }

  var viewport = new _webMercatorViewport.default({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });
  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  (0, _assert.default)(targetSize[0] > 0 && targetSize[1] > 0);
  var scaleX = targetSize[0] / size[0];
  var scaleY = targetSize[1] / size[1];
  var offsetX = (padding.right - padding.left) / 2 / scaleX;
  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;
  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}

},{"./assert":458,"./web-mercator-viewport":466,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/slicedToArray":37}],460:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flyToViewport;

var _mathUtils = require("./math-utils");

var _webMercatorUtils = require("./web-mercator-utils");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var EPSILON = 0.01;
var VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];

function flyToViewport(startProps, endProps, t) {
  var viewport = {};
  var rho = 1.414;
  var startZoom = startProps.zoom;
  var startCenter = [startProps.longitude, startProps.latitude];
  var startScale = (0, _webMercatorUtils.zoomToScale)(startZoom);
  var endZoom = endProps.zoom;
  var endCenter = [endProps.longitude, endProps.latitude];
  var scale = (0, _webMercatorUtils.zoomToScale)(endZoom - startZoom);
  var startCenterXY = (0, _webMercatorUtils.lngLatToWorld)(startCenter, startScale);
  var endCenterXY = (0, _webMercatorUtils.lngLatToWorld)(endCenter, startScale);
  var uDelta = vec2.sub([], endCenterXY, startCenterXY);
  var w0 = Math.max(startProps.width, startProps.height);
  var w1 = w0 / scale;
  var u1 = vec2.length(uDelta);

  if (Math.abs(u1) < EPSILON) {
    for (var _i = 0; _i < VIEWPORT_TRANSITION_PROPS.length; _i++) {
      var key = VIEWPORT_TRANSITION_PROPS[_i];
      var startValue = startProps[key];
      var endValue = endProps[key];
      viewport[key] = (0, _mathUtils.lerp)(startValue, endValue, t);
    }

    return viewport;
  }

  var rho2 = rho * rho;
  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);
  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);
  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  var S = (r1 - r0) / rho;
  var s = t * S;
  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
  var scaleIncrement = 1 / w;
  var newZoom = startZoom + (0, _webMercatorUtils.scaleToZoom)(scaleIncrement);
  var newCenterWorld = vec2.scale([], uDelta, u);
  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);
  vec2.scale(newCenterWorld, newCenterWorld, scaleIncrement);
  var newCenter = (0, _webMercatorUtils.worldToLngLat)(newCenterWorld, (0, _webMercatorUtils.zoomToScale)(newZoom));
  viewport.longitude = newCenter[0];
  viewport.latitude = newCenter[1];
  viewport.zoom = newZoom;
  return viewport;
}

},{"./math-utils":462,"./web-mercator-utils":465,"@babel/runtime/helpers/interopRequireWildcard":26,"gl-matrix/vec2":409}],461:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function get() {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "PerspectiveMercatorViewport", {
  enumerable: true,
  get: function get() {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "fitBounds", {
  enumerable: true,
  get: function get() {
    return _fitBounds.default;
  }
});
Object.defineProperty(exports, "normalizeViewportProps", {
  enumerable: true,
  get: function get() {
    return _normalizeViewportProps.default;
  }
});
Object.defineProperty(exports, "flyToViewport", {
  enumerable: true,
  get: function get() {
    return _flyToViewport.default;
  }
});
Object.defineProperty(exports, "lngLatToWorld", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.lngLatToWorld;
  }
});
Object.defineProperty(exports, "worldToLngLat", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.worldToLngLat;
  }
});
Object.defineProperty(exports, "worldToPixels", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.worldToPixels;
  }
});
Object.defineProperty(exports, "pixelsToWorld", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.pixelsToWorld;
  }
});
Object.defineProperty(exports, "getMeterZoom", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.getMeterZoom;
  }
});
Object.defineProperty(exports, "getDistanceScales", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.getDistanceScales;
  }
});
Object.defineProperty(exports, "addMetersToLngLat", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.addMetersToLngLat;
  }
});
Object.defineProperty(exports, "getViewMatrix", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.getViewMatrix;
  }
});
Object.defineProperty(exports, "getProjectionMatrix", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.getProjectionMatrix;
  }
});
Object.defineProperty(exports, "getProjectionParameters", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.getProjectionParameters;
  }
});
Object.defineProperty(exports, "getUncenteredViewMatrix", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.getViewMatrix;
  }
});
Object.defineProperty(exports, "projectFlat", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.lngLatToWorld;
  }
});
Object.defineProperty(exports, "unprojectFlat", {
  enumerable: true,
  get: function get() {
    return _webMercatorUtils.worldToLngLat;
  }
});

var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));

var _fitBounds = _interopRequireDefault(require("./fit-bounds"));

var _normalizeViewportProps = _interopRequireDefault(require("./normalize-viewport-props"));

var _flyToViewport = _interopRequireDefault(require("./fly-to-viewport"));

var _webMercatorUtils = require("./web-mercator-utils");

},{"./fit-bounds":459,"./fly-to-viewport":460,"./normalize-viewport-props":463,"./web-mercator-utils":465,"./web-mercator-viewport":466,"@babel/runtime/helpers/interopRequireDefault":25}],462:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMat4 = createMat4;
exports.transformVector = transformVector;
exports.mod = mod;
exports.lerp = lerp;

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

function transformVector(matrix, vector) {
  var result = vec4.transformMat4([], vector, matrix);
  vec4.scale(result, result, 1 / result[3]);
  return result;
}

function mod(value, divisor) {
  var modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}

function lerp(start, end, step) {
  return step * end + (1 - step) * start;
}

},{"@babel/runtime/helpers/interopRequireWildcard":26,"gl-matrix/vec4":411}],463:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeViewportProps;

var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));

var _mathUtils = require("./math-utils");

var MAX_LATITUDE = 85.05113;
var MIN_LATITUDE = -85.05113;

function normalizeViewportProps(_ref) {
  var width = _ref.width,
      height = _ref.height,
      longitude = _ref.longitude,
      latitude = _ref.latitude,
      zoom = _ref.zoom,
      _ref$pitch = _ref.pitch,
      pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
      _ref$bearing = _ref.bearing,
      bearing = _ref$bearing === void 0 ? 0 : _ref$bearing;

  if (longitude < -180 || longitude > 180) {
    longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
  }

  if (bearing < -180 || bearing > 180) {
    bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
  }

  var flatViewport = new _webMercatorViewport.default({
    width: width,
    height: height,
    longitude: longitude,
    latitude: latitude,
    zoom: zoom
  });
  var topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
  var bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
  var shiftY = 0;

  if (bottomY - topY < height) {
    zoom += Math.log2(height / (bottomY - topY));
    flatViewport = new _webMercatorViewport.default({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom
    });
    topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
    bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
  }

  if (topY > 0) {
    shiftY = topY;
  } else if (bottomY < height) {
    shiftY = bottomY - height;
  }

  if (shiftY) {
    latitude = flatViewport.unproject([width / 2, height / 2 + shiftY])[1];
  }

  return {
    width: width,
    height: height,
    longitude: longitude,
    latitude: latitude,
    zoom: zoom,
    pitch: pitch,
    bearing: bearing
  };
}

},{"./math-utils":462,"./web-mercator-viewport":466,"@babel/runtime/helpers/interopRequireDefault":25}],464:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _mathUtils = require("./math-utils");

var _webMercatorUtils = require("./web-mercator-utils");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var IDENTITY = (0, _mathUtils.createMat4)();

var Viewport = function () {
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === void 0 ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === void 0 ? IDENTITY : _ref$projectionMatrix;

    (0, _classCallCheck2.default)(this, Viewport);
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;
    this.pixelsPerMeter = 1;
    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;
    var vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    var m = (0, _mathUtils.createMat4)();
    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
    mat4.translate(m, m, [1, -1, 0]);
    mat4.multiply(m, m, this.viewProjectionMatrix);
    var mInverse = mat4.invert((0, _mathUtils.createMat4)(), m);

    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }

  (0, _createClass2.default)(Viewport, [{
    key: "equals",
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
    }
  }, {
    key: "project",
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;

      var worldPosition = this.projectPosition(xyz);
      var coord = (0, _webMercatorUtils.worldToPixels)(worldPosition, this.pixelProjectionMatrix);

      var _coord = (0, _slicedToArray2.default)(coord, 2),
          x = _coord[0],
          y = _coord[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }
  }, {
    key: "unproject",
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft,
          targetZ = _ref3.targetZ;

      var _xyz = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          z = _xyz[2];

      var y2 = topLeft ? y : this.height - y;
      var targetZWorld = targetZ && targetZ * this.pixelsPerMeter;
      var coord = (0, _webMercatorUtils.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);

      var _this$unprojectPositi = this.unprojectPosition(coord),
          _this$unprojectPositi2 = (0, _slicedToArray2.default)(_this$unprojectPositi, 3),
          X = _this$unprojectPositi2[0],
          Y = _this$unprojectPositi2[1],
          Z = _this$unprojectPositi2[2];

      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }

      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
  }, {
    key: "projectPosition",
    value: function projectPosition(xyz) {
      var _this$projectFlat = this.projectFlat(xyz),
          _this$projectFlat2 = (0, _slicedToArray2.default)(_this$projectFlat, 2),
          X = _this$projectFlat2[0],
          Y = _this$projectFlat2[1];

      var Z = (xyz[2] || 0) * this.pixelsPerMeter;
      return [X, Y, Z];
    }
  }, {
    key: "unprojectPosition",
    value: function unprojectPosition(xyz) {
      var _this$unprojectFlat = this.unprojectFlat(xyz),
          _this$unprojectFlat2 = (0, _slicedToArray2.default)(_this$unprojectFlat, 2),
          X = _this$unprojectFlat2[0],
          Y = _this$unprojectFlat2[1];

      var Z = (xyz[2] || 0) / this.pixelsPerMeter;
      return [X, Y, Z];
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return xyz;
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return xyz;
    }
  }]);
  return Viewport;
}();

exports.default = Viewport;

},{"./math-utils":462,"./web-mercator-utils":465,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/slicedToArray":37,"gl-matrix/mat4":407}],465:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomToScale = zoomToScale;
exports.scaleToZoom = scaleToZoom;
exports.lngLatToWorld = lngLatToWorld;
exports.worldToLngLat = worldToLngLat;
exports.getMeterZoom = getMeterZoom;
exports.getDistanceScales = getDistanceScales;
exports.addMetersToLngLat = addMetersToLngLat;
exports.getViewMatrix = getViewMatrix;
exports.getProjectionParameters = getProjectionParameters;
exports.getProjectionMatrix = getProjectionMatrix;
exports.worldToPixels = worldToPixels;
exports.pixelsToWorld = pixelsToWorld;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _mathUtils = require("./math-utils");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _assert = _interopRequireDefault(require("./assert"));

var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var EARTH_CIRCUMFERENCE = 40.03e6;
var DEFAULT_ALTITUDE = 1.5;

function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}

function scaleToZoom(scale) {
  return Math.log2(scale);
}

function lngLatToWorld(_ref, scale) {
  var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  (0, _assert.default)(Number.isFinite(lng) && Number.isFinite(scale));
  (0, _assert.default)(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
  scale *= TILE_SIZE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

function worldToLngLat(_ref3, scale) {
  var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale *= TILE_SIZE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

function getMeterZoom(_ref5) {
  var latitude = _ref5.latitude;
  (0, _assert.default)(Number.isFinite(latitude));
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}

function getDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale,
      _ref6$highPrecision = _ref6.highPrecision,
      highPrecision = _ref6$highPrecision === void 0 ? false : _ref6$highPrecision;
  scale = scale !== undefined ? scale : zoomToScale(zoom);
  (0, _assert.default)(Number.isFinite(latitude) && Number.isFinite(longitude) && Number.isFinite(scale));
  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];
  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;
    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }

  return result;
}

function addMetersToLngLat(lngLatZ, xyz) {
  var _lngLatZ = (0, _slicedToArray2.default)(lngLatZ, 3),
      longitude = _lngLatZ[0],
      latitude = _lngLatZ[1],
      z0 = _lngLatZ[2];

  var _xyz = (0, _slicedToArray2.default)(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      z = _xyz[2];

  var scale = 1;

  var _getDistanceScales = getDistanceScales({
    longitude: longitude,
    latitude: latitude,
    scale: scale,
    highPrecision: true
  }),
      pixelsPerMeter = _getDistanceScales.pixelsPerMeter,
      pixelsPerMeter2 = _getDistanceScales.pixelsPerMeter2;

  var worldspace = lngLatToWorld(lngLatZ, scale);
  worldspace[0] += x * (pixelsPerMeter[0] + pixelsPerMeter2[0] * y);
  worldspace[1] += y * (pixelsPerMeter[1] + pixelsPerMeter2[1] * y);
  var newLngLat = worldToLngLat(worldspace, scale);
  var newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}

function getViewMatrix(_ref7) {
  var height = _ref7.height,
      pitch = _ref7.pitch,
      bearing = _ref7.bearing,
      altitude = _ref7.altitude,
      _ref7$center = _ref7.center,
      center = _ref7$center === void 0 ? null : _ref7$center,
      _ref7$flipY = _ref7.flipY,
      flipY = _ref7$flipY === void 0 ? false : _ref7$flipY;
  var vm = (0, _mathUtils.createMat4)();
  mat4.translate(vm, vm, [0, 0, -altitude]);
  mat4.scale(vm, vm, [1, 1, 1 / height]);
  mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);

  if (flipY) {
    mat4.scale(vm, vm, [1, -1, 1]);
  }

  if (center) {
    mat4.translate(vm, vm, vec3.negate([], center));
  }

  return vm;
}

function getProjectionParameters(_ref8) {
  var width = _ref8.width,
      height = _ref8.height,
      _ref8$altitude = _ref8.altitude,
      altitude = _ref8$altitude === void 0 ? DEFAULT_ALTITUDE : _ref8$altitude,
      _ref8$pitch = _ref8.pitch,
      pitch = _ref8$pitch === void 0 ? 0 : _ref8$pitch,
      _ref8$nearZMultiplier = _ref8.nearZMultiplier,
      nearZMultiplier = _ref8$nearZMultiplier === void 0 ? 1 : _ref8$nearZMultiplier,
      _ref8$farZMultiplier = _ref8.farZMultiplier,
      farZMultiplier = _ref8$farZMultiplier === void 0 ? 1 : _ref8$farZMultiplier;
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;
  return {
    fov: 2 * Math.atan(height / 2 / altitude),
    aspect: width / height,
    focalDistance: altitude,
    near: nearZMultiplier,
    far: farZ * farZMultiplier
  };
}

function getProjectionMatrix(_ref9) {
  var width = _ref9.width,
      height = _ref9.height,
      pitch = _ref9.pitch,
      altitude = _ref9.altitude,
      nearZMultiplier = _ref9.nearZMultiplier,
      farZMultiplier = _ref9.farZMultiplier;

  var _getProjectionParamet = getProjectionParameters({
    width: width,
    height: height,
    altitude: altitude,
    pitch: pitch,
    nearZMultiplier: nearZMultiplier,
    farZMultiplier: farZMultiplier
  }),
      fov = _getProjectionParamet.fov,
      aspect = _getProjectionParamet.aspect,
      near = _getProjectionParamet.near,
      far = _getProjectionParamet.far;

  var projectionMatrix = mat4.perspective([], fov, aspect, near, far);
  return projectionMatrix;
}

function worldToPixels(xyz, pixelProjectionMatrix) {
  var _xyz2 = (0, _slicedToArray2.default)(xyz, 3),
      x = _xyz2[0],
      y = _xyz2[1],
      _xyz2$ = _xyz2[2],
      z = _xyz2$ === void 0 ? 0 : _xyz2$;

  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
}

function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var _xyz3 = (0, _slicedToArray2.default)(xyz, 3),
      x = _xyz3[0],
      y = _xyz3[1],
      z = _xyz3[2];

  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');

  if (Number.isFinite(z)) {
    var coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }

  var coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
  var coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);
  var z0 = coord0[2];
  var z1 = coord1[2];
  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2.lerp([], coord0, coord1, t);
}

},{"./assert":458,"./math-utils":462,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/slicedToArray":37,"gl-matrix/mat4":407,"gl-matrix/vec2":409,"gl-matrix/vec3":410}],466:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _viewport = _interopRequireDefault(require("./viewport"));

var _webMercatorUtils = require("./web-mercator-utils");

var _fitBounds3 = _interopRequireDefault(require("./fit-bounds"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var WebMercatorViewport = function (_Viewport) {
  (0, _inherits2.default)(WebMercatorViewport, _Viewport);

  function WebMercatorViewport() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$latitude = _ref.latitude,
        latitude = _ref$latitude === void 0 ? 0 : _ref$latitude,
        _ref$longitude = _ref.longitude,
        longitude = _ref$longitude === void 0 ? 0 : _ref$longitude,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === void 0 ? 0 : _ref$zoom,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude,
        nearZMultiplier = _ref.nearZMultiplier,
        farZMultiplier = _ref.farZMultiplier;

    (0, _classCallCheck2.default)(this, WebMercatorViewport);
    width = width || 1;
    height = height || 1;
    var scale = (0, _webMercatorUtils.zoomToScale)(zoom);
    altitude = Math.max(0.75, altitude);
    var center = (0, _webMercatorUtils.lngLatToWorld)([longitude, latitude], scale);
    center[2] = 0;
    var projectionMatrix = (0, _webMercatorUtils.getProjectionMatrix)({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      nearZMultiplier: nearZMultiplier || 1 / height,
      farZMultiplier: farZMultiplier || 1.01
    });
    var viewMatrix = (0, _webMercatorUtils.getViewMatrix)({
      height: height,
      center: center,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      flipY: true
    });
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(WebMercatorViewport).call(this, {
      width: width,
      height: height,
      viewMatrix: viewMatrix,
      projectionMatrix: projectionMatrix
    }));
    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;
    _this.scale = scale;
    _this.center = center;
    _this.pixelsPerMeter = (0, _webMercatorUtils.getDistanceScales)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this))).pixelsPerMeter[2];
    Object.freeze((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    return _this;
  }

  (0, _createClass2.default)(WebMercatorViewport, [{
    key: "projectFlat",
    value: function projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return (0, _webMercatorUtils.lngLatToWorld)(lngLat, scale);
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return (0, _webMercatorUtils.worldToLngLat)(xy, scale);
    }
  }, {
    key: "getMapCenterByLngLatPosition",
    value: function getMapCenterByLngLatPosition(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;
      var fromLocation = (0, _webMercatorUtils.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
      var toLocation = (0, _webMercatorUtils.lngLatToWorld)(lngLat, this.scale);
      var translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
      var newCenter = vec2.add([], this.center, translate);
      return (0, _webMercatorUtils.worldToLngLat)(newCenter, this.scale);
    }
  }, {
    key: "getLocationAtPoint",
    value: function getLocationAtPoint(_ref3) {
      var lngLat = _ref3.lngLat,
          pos = _ref3.pos;
      return this.getMapCenterByLngLatPosition({
        lngLat: lngLat,
        pos: pos
      });
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = (0, _fitBounds3.default)(Object.assign({
        width: width,
        height: height,
        bounds: bounds
      }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({
        width: width,
        height: height,
        longitude: longitude,
        latitude: latitude,
        zoom: zoom
      });
    }
  }]);
  return WebMercatorViewport;
}(_viewport.default);

exports.default = WebMercatorViewport;

},{"./fit-bounds":459,"./viewport":464,"./web-mercator-utils":465,"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":18,"@babel/runtime/helpers/createClass":20,"@babel/runtime/helpers/getPrototypeOf":23,"@babel/runtime/helpers/inherits":24,"@babel/runtime/helpers/interopRequireDefault":25,"@babel/runtime/helpers/interopRequireWildcard":26,"@babel/runtime/helpers/possibleConstructorReturn":35,"gl-matrix/vec2":409}],467:[function(require,module,exports){
const OBJLoader = require('@loaders.gl/obj').OBJLoader
const load = require('@loaders.gl/core').load
const SimpleMeshLayer = require('@deck.gl/mesh-layers').SimpleMeshLayer
const MapboxLayer = require('@deck.gl/mapbox').MapboxLayer

mapboxgl.accessToken = 'pk.eyJ1IjoiZGVsbGlzZCIsImEiOiJjam9obzZpMDQwMGQ0M2tsY280OTh2M2o5In0.XtnbkAMU7nIMkq7amsiYdw'
//mapboxgl.accessToken = 'pk.eyJ1IjoiZGVsbGlzZCIsImEiOiJjandmbGc5MG8xZGg1M3pudXl6dTQ3NHhtIn0.6eYbb2cN8YUexz_F0ZCqUQ';
// let map = null = new mapboxgl.Map({
//     container: 'map',
//     style: 'mapbox://styles/mapbox/light-v9',
//     center: [-75.6294, 45.3745], 
//     zoom: 11, 
//     bearing: -30,
//     hash: true
// });

let map = null;

document.addEventListener('DOMContentLoaded', () => {
    loadMap()
})

let toggleOptions = {
    dark: true,
    satellite: false,
    stage3west: false,
    stage3south: false,
    stage3north: false
}

/**
 * Read the current state of toggle options from the url params and/or the url bar
 * URL params override local storage data, except for dark mode (which isn't present in url)
 * Satellite view overrides dark mode in all cases
 */
function syncToggleOptionsState() {
    // Dark mode
    let mql = window.matchMedia('(prefers-color-scheme: dark)')
    if (mql.matches) {
        toggleOptions.dark = true;
    } else if ('dark' in localStorage) {
        toggleOptions.dark = localStorage['dark']
    }

    mql.addListener((media) => {
        if (!toggleOptions.satellite) {
            toggleOptions.dark = media.matches
        }
    })
}

let firstSymbolId;
let count = 0;

let train, bus, streetcar, subway;

async function loadObj() {
    const data = await load('data/coach.obj', OBJLoader)
    map.addLayer(new MapboxLayer({
        type: SimpleMeshLayer,
        data: [
            {
                position: [-79.368624, 43.646828],
                angle: -15
            },
            {
                position: [-79.36863, 43.646828],
                angle: -15
            }
        ],
        id: 'mesh',
        mesh: data,
        getColor: [255, 0, 0],
    }))

    console.log(data)
}

function setupDataDisplay() {

    // loadJson('data/stage2south.json', (data) => {
    //     trillium = data;
    //     count++;
    //     loadLine(data, 'trillium');
    // });

    // loadJson('data/stage2east.json', (data) => {
    //     confederationEast = data;
    //     count++;
    //     loadLine(data, "confederation-east");
    // });

    // loadJson('data/stage2west.json', (data) => {
    //     confederationWest = data;
    //     count++;
    //     loadLine(data, "confederation-west");
    // });

    // loadJson('data/stage1.json', (data) => {
    //     confederation = data;
    //     count++;
    //     loadLine(data, "confederation");
    // });

    // loadJson('data/stage3kanata.json', (data) => {
    //     kanata = data
    //     count++
    //     loadLine(data, "kanata")
    // })

    loadObj()

    let layers = map.getStyle().layers;
    // Find the index of the first symbol layer in the map style
    for (let i = 0; i < layers.length; i++) {
        if (layers[i].type === 'symbol') {
            firstSymbolId = layers[i].id;
            break;
        }
    }

    map.addSource('train', {
        type: 'geojson',
        data: 'data/train.geojson'
    });

    map.addLayer({
        id: "train",
        type: "line",
        source: 'train',
        filter: ['!=', 'name', 'Outline'],
        layout: {
            "line-join": "round",
            "line-cap": "round"
        },
        paint: {
            "line-color": '#256C2F',
            "line-width": 2
        }
    }, firstSymbolId);

    map.addLayer({
        'id': '3d-buildings',
        'source': 'composite',
        'source-layer': 'building',
        'filter': ['==', 'extrude', 'true'],
        'type': 'fill-extrusion',
        'minzoom': 15,
        'paint': {
            'fill-extrusion-color': '#aaa',

            // use an 'interpolate' expression to add a smooth transition effect to the
            // buildings as the user zooms in
            'fill-extrusion-height': [
                "interpolate", ["linear"],
                ["zoom"],
                15, 0,
                15.05, ["get", "height"]
            ],
            'fill-extrusion-base': [
                "interpolate", ["linear"],
                ["zoom"],
                15, 0,
                15.05, ["get", "min_height"]
            ],
            'fill-extrusion-opacity': .6
        }
    }, firstSymbolId);
}

function clearData() {
    map.removeLayer('belfast')
    map.removeLayer('walkley')
    map.removeLayer('moodie')

    removeLine('confederation')
    removeLine('confederation-east')
    removeLine('confederation-west')
    removeLine('trillium')
}

function removeLine(name) {
    map.remove(`${name}-tracks`)
    map.remove(`${name}-platforms`)
    map.remove(`${name}-labels`)
    map.remove(`${name}-labels-hover`)
}

function loadLine(line, name) {
    map.addSource(name, {
        'type': 'geojson',
        attribution: 'Data: City of Ottawa',
        data: line
    });

    map.addLayer({
        id: `${name}-tracks`,
        type: 'line',
        source: name,
        filter: ['==', 'type', 'tracks'],
        layout: {
            "line-join": "round",
            "line-cap": "round"
        },
        paint: {
            "line-color": ['get', 'color'],
            "line-width": 3
        }
    }, firstSymbolId);

    map.addLayer({
        id: `${name}-platforms`,
        type: 'fill',
        source: name,
        filter: ['==', 'type', 'station-platforms'],
        paint: {
            "fill-color": ['get', 'color'],
            'fill-opacity': 0.6
        }
    });

    map.addLayer({
        id: `${name}-labels`,
        type: 'symbol',
        source: name,
        filter: ['==', 'type', 'station-label'],
        minzoom: 10,
        layout: {
            //"text-field": "{OBJECTID}"
            "icon-image": "station",
            "text-field": "{name}",
            "text-anchor": "left",
            "text-offset": [0.75, 0],
            "text-optional": true,
            "icon-optional": false,
            "icon-allow-overlap": true,
            "text-size": 14
        },
        paint: {
            "text-halo-width": 1,
            "text-color": toggleOptions.dark ? "#FFFFFF" : "#212121",
            "text-halo-color": toggleOptions.dark ? "#212121" : "#FFFFFF"
        }
    });

    map.addLayer({
        id: `${name}-labels-hover`,
        type: 'symbol',
        source: name,
        minzoom: 10,
        filter: ['all', ['==', 'name', ""],
            ['==', 'type', 'station-label']
        ],
        layout: {
            "text-field": "{name}",
            "text-anchor": "left",
            "text-offset": [0.75, 0],
            "text-allow-overlap": true,
            "text-size": 14
        },
        paint: {
            "text-halo-width": 1,
            "text-color": toggleOptions.dark ? "#FFFFFF" : "#212121",
            "text-halo-color": toggleOptions.dark ? "#212121" : "#FFFFFF"
        }
    });

    map.on('click', `${name}-labels`, (e) => {
        if (e.features[0].properties.url != null) {
            window.parent.location.href = `https://www.otrainfans.ca/${e.features[0].properties.url}`
        }
    })

    let lastFeatureId;
    // Using mousemove is more accurate than mouseenter/mouseleave for hover effects
    map.on('mousemove', (e) => {
        let fs = map.queryRenderedFeatures(e.point, {
            layers: [`${name}-labels`]
        });
        if (fs.length > 0) {
            map.getCanvas().style.cursor = 'pointer';

            let f = fs[0];
            if (f.properties.name !== lastFeatureId) {
                lastFeatureId = f.properties.name;

                // Show this element on the "hover labels" layer
                map.setFilter(`${name}-labels-hover`, ['all', ['==', 'name', f.properties.name],
                    ['==', 'type', 'station-label']
                ]);
            }
        } else {
            map.getCanvas().style.cursor = '';
            // Reset the "hover labels" layer
            map.setFilter(`${name}-labels-hover`, ['all', ['==', 'name', ""],
                ['==', 'type', 'station-label']
            ]);
            lastFeatureId = undefined;
        }
    });

}

function getLngLatFromFeatures(features) {
    let points = [];
    for (let feature of features.filter((e) => e.properties.type === "station-label")) {
        points.push(feature.geometry.coordinates)
    }

    return points;
}

function loadMap(style = "mapbox://styles/mapbox/dark-v9") {
    if (map != null) {
        map.remove()
    }

    map = new mapboxgl.Map({
        container: 'map-container',
        style: style,
        center: [-79.395540, 43.664166],
        zoom: 11,
        bearing: -30,
        hash: true
    })

    map.on('load', () => {
        setupDataDisplay()
    })
}

// Toggle the map between light and dark modes
document.getElementById('dark-toggle').addEventListener('click', () => {
    if (toggleOptions.dark && !toggleOptions.satellite) {
        loadMap('mapbox://styles/mapbox/light-v9')
        document.getElementById('toggle-container').classList.remove('dark')
    } else {
        loadMap('mapbox://styles/mapbox/dark-v9')
        document.getElementById('toggle-container').classList.add('dark')
    }
    toggleOptions.satellite = false;
    toggleOptions.dark = !toggleOptions.dark;
})

// Toggle the map between satellite mode and whatever light/dark mode was previously active
document.getElementById('satellite-toggle').addEventListener('click', () => {
    if (toggleOptions.satellite) {
        if (toggleOptions.dark) {
            loadMap('mapbox://styles/mapbox/light-v9')
        } else {
            loadMap('mapbox://styles/mapbox/dark-v9')
        }
    } else {
        loadMap('mapbox://styles/mapbox/satellite-streets-v9')
    }
    toggleOptions.satellite = !toggleOptions.satellite;
})
},{"@deck.gl/mapbox":135,"@deck.gl/mesh-layers":137,"@loaders.gl/core":148,"@loaders.gl/obj":224}]},{},[467]);
